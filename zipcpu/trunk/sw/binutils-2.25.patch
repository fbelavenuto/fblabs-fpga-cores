diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/archures.c binutils-2.25/bfd/archures.c
--- binutils-2.25-original/bfd/archures.c	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/bfd/archures.c	2016-02-04 21:12:06.471473513 -0500
@@ -496,6 +496,8 @@
 .#define bfd_mach_aarch64_ilp32	32
 .  bfd_arch_nios2,
 .#define bfd_mach_nios2	0
+.  bfd_arch_zip,
+.#define bfd_mach_zip	0
 .  bfd_arch_last
 .  };
 */
@@ -623,6 +625,7 @@
 extern const bfd_arch_info_type bfd_xgate_arch;
 extern const bfd_arch_info_type bfd_z80_arch;
 extern const bfd_arch_info_type bfd_z8k_arch;
+extern const bfd_arch_info_type bfd_zip_arch;
 
 static const bfd_arch_info_type * const bfd_archures_list[] =
   {
@@ -709,6 +712,7 @@
     &bfd_xgate_arch,
     &bfd_z80_arch,
     &bfd_z8k_arch,
+    &bfd_zip_arch,
 #endif
   0
 };
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/bfd-in2.h binutils-2.25/bfd/bfd-in2.h
--- binutils-2.25-original/bfd/bfd-in2.h	2014-11-04 04:54:41.000000000 -0500
+++ binutils-2.25/bfd/bfd-in2.h	2016-04-19 07:41:48.387151802 -0400
@@ -2283,6 +2283,8 @@
 #define bfd_mach_aarch64_ilp32 32
   bfd_arch_nios2,
 #define bfd_mach_nios2 0
+  bfd_arch_zip,
+#define bfd_mach_zip   0
   bfd_arch_last
   };
 
@@ -6066,6 +6068,25 @@
 
 /* Adapteva EPIPHANY - 8 bit immediate for 16 bit mov instruction.  */
   BFD_RELOC_EPIPHANY_IMM8,
+
+/* ZIP CPU value (not address) relocations.  */
+  BFD_RELOC_ZIP_VALUE,
+  BFD_RELOC_ZIP_OPB_IMM,
+  BFD_RELOC_ZIP_OPB_OFFSET,
+  BFD_RELOC_ZIP_OPB_PCREL,
+  BFD_RELOC_ZIP_OPB_GOTREL,
+  BFD_RELOC_ZIP_MOV_OFFSET,
+  BFD_RELOC_ZIP_MOV_PCREL,
+  BFD_RELOC_ZIP_MOV_GOTREL,
+  BFD_RELOC_ZIP_LDI,
+  BFD_RELOC_ZIP_LLO,
+  BFD_RELOC_ZIP_LHI,
+  BFD_RELOC_ZIP_BREV,
+
+/* This is the same as the ZIP_VALUE relocation, save only that the value is
+right shifted by two, since it is an address and Zip addresses increment
+by one per word, not one per byte.  */
+  BFD_RELOC_ZIP_ADDRESS,
   BFD_RELOC_UNUSED };
 
 typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/config.bfd binutils-2.25/bfd/config.bfd
--- binutils-2.25-original/bfd/config.bfd	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/bfd/config.bfd	2016-02-04 21:12:06.475473480 -0500
@@ -1692,6 +1692,10 @@
     targ_underscore=yes
     ;;
 
+  zip*)
+    targ_defvec=zip_elf32_vec
+    ;;
+
   *-*-ieee*)
     targ_defvec=ieee_vec
     ;;
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/configure binutils-2.25/bfd/configure
--- binutils-2.25-original/bfd/configure	2014-12-23 09:22:04.000000000 -0500
+++ binutils-2.25/bfd/configure	2016-02-04 21:12:06.475473480 -0500
@@ -14178,6 +14178,10 @@
   x86_64-*-netbsd* | x86_64-*-openbsd*)
 	COREFILE=netbsd-core.lo
 	;;
+
+  zip*)
+    COREFILE=netbsd-core.lo
+    ;;
   esac
 
   case "$COREFILE" in
@@ -15617,6 +15621,7 @@
     xtensa_elf32_le_vec)	 tb="$tb xtensa-isa.lo xtensa-modules.lo elf32-xtensa.lo elf32.lo $elf" ;;
     z80_coff_vec)		 tb="$tb coff-z80.lo reloc16.lo" ;;
     z8k_coff_vec)		 tb="$tb coff-z8k.lo reloc16.lo cofflink.lo" ;;
+    zip_elf32_vec)		 tb="$tb elf32-zip.lo elf32.lo $elf" ;;
 
     # These appear out of order in targets.c
     srec_vec)			 tb="$tb srec.lo" ;;
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/configure.ac binutils-2.25/bfd/configure.ac
--- binutils-2.25-original/bfd/configure.ac	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/bfd/configure.ac	2016-02-04 21:12:06.487473383 -0500
@@ -488,6 +488,9 @@
   x86_64-*-netbsd* | x86_64-*-openbsd*)
 	COREFILE=netbsd-core.lo
 	;;
+  zip*)
+	COREFILE=netbsd-core.lo
+	;;
   esac
 
   case "$COREFILE" in
@@ -1018,6 +1021,7 @@
     xtensa_elf32_le_vec)	 tb="$tb xtensa-isa.lo xtensa-modules.lo elf32-xtensa.lo elf32.lo $elf" ;;
     z80_coff_vec)		 tb="$tb coff-z80.lo reloc16.lo" ;;
     z8k_coff_vec)		 tb="$tb coff-z8k.lo reloc16.lo cofflink.lo" ;;
+    zip_elf32_vec)		 tb="$tb elf32-zip.lo elf32.lo $elf" ;;
 
     # These appear out of order in targets.c
     srec_vec)			 tb="$tb srec.lo" ;;
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/cpu-zip.c binutils-2.25/bfd/cpu-zip.c
--- binutils-2.25-original/bfd/cpu-zip.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/bfd/cpu-zip.c	2016-02-04 21:16:34.933317218 -0500
@@ -0,0 +1,65 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Filename: 	tc-zip.c
+//
+// Project:	Zip CPU backend for GNU Binutils
+//
+// Purpose:	BFD support for the Zip CPU architecture.
+//
+//		This file is part of BFD, the Binary File Descriptor library.
+//
+// Creator:	Dan Gisselquist, Ph.D.
+//		Gisselquist Technology, LLC
+//
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (C) 2016, Gisselquist Technology, LLC
+//
+// This program is free software (firmware): you can redistribute it and/or
+// modify it under the terms of  the GNU General Public License as published
+// by the Free Software Foundation, either version 3 of the License, or (at
+// your option) any later version.
+//
+// This program is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this program.  (It's in the $(ROOT)/doc directory, run make with no
+// target there if the PDF file isn't present.)  If not, see
+// <http://www.gnu.org/licenses/> for a copy.
+//
+// License:	GPL, v3, as defined and found on www.gnu.org,
+//		http://www.gnu.org/licenses/gpl.html
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type
+bfd_zip_arch =
+{
+  32,				// There's 32 bits_per_word.
+  32,				// There's 34 bits_per_address.
+  32,				// There's 32 bits_per_byte.
+  bfd_arch_zip,			// One of enum bfd_architecture, defined
+				// in archures.c and provided in
+				// generated header files.
+  bfd_mach_zip,			// Random BFD-internal number for this
+				// machine, similarly listed in
+				// archures.c.  Not emitted in output.
+  "zip",			// The arch_name.
+  "zip",			// The printable name is the same.
+  2,				// Section alignment power; each section
+				// is aligned to (only) 2^2 (i.e. 4) bytes.
+  TRUE,				// This is the default "machine".
+  bfd_default_compatible,	// Architecture comparison function
+  bfd_default_scan,		// String to architecture conversion
+  bfd_arch_default_fill,	// Default fill.
+  NULL				// Pointer to next bfd_arch_info_type in
+				// the same family. 
+};
+
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/doc/archures.texi binutils-2.25/bfd/doc/archures.texi
--- binutils-2.25-original/bfd/doc/archures.texi	2014-12-23 09:37:35.000000000 -0500
+++ binutils-2.25/bfd/doc/archures.texi	2016-02-04 21:12:06.487473383 -0500
@@ -463,6 +463,8 @@
 #define bfd_mach_aarch64_ilp32 32
   bfd_arch_nios2,
 #define bfd_mach_nios2 0
+  bfd_arch_zip,
+#define bfd_mach_zip   0
   bfd_arch_last
   @};
 @end example
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/doc/reloc.texi binutils-2.25/bfd/doc/reloc.texi
--- binutils-2.25-original/bfd/doc/reloc.texi	2014-12-23 09:37:35.000000000 -0500
+++ binutils-2.25/bfd/doc/reloc.texi	2016-02-04 21:12:06.487473383 -0500
@@ -3999,6 +3999,24 @@
 @deffn {} BFD_RELOC_EPIPHANY_IMM8
 Adapteva EPIPHANY - 8 bit immediate for 16 bit mov instruction.
 @end deffn
+@deffn {} BFD_RELOC_ZIP_VALUE
+@deffnx {} BFD_RELOC_ZIP_OPB_IMM
+@deffnx {} BFD_RELOC_ZIP_OPB_OFFSET
+@deffnx {} BFD_RELOC_ZIP_OPB_PCREL
+@deffnx {} BFD_RELOC_ZIP_OPB_GOTREL
+@deffnx {} BFD_RELOC_ZIP_MOV_OFFSET
+@deffnx {} BFD_RELOC_ZIP_MOV_PCREL
+@deffnx {} BFD_RELOC_ZIP_MOV_GOTREL
+@deffnx {} BFD_RELOC_ZIP_LDI
+@deffnx {} BFD_RELOC_ZIP_LLO
+@deffnx {} BFD_RELOC_ZIP_LHI
+ZIP CPU value (not address) relocations.
+@end deffn
+@deffn {} BFD_RELOC_ZIP_ADDRESS
+This is the same as the ZIP_VALUE relocation, save only that the value is
+right shifted by two, since it is an address and Zip addresses increment
+by one per word, not one per byte.
+@end deffn
 
 @example
 
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/elf32-zip.c binutils-2.25/bfd/elf32-zip.c
--- binutils-2.25-original/bfd/elf32-zip.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/bfd/elf32-zip.c	2016-04-21 10:09:50.311094483 -0400
@@ -0,0 +1,1280 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Filename: 	tc-zip.c
+//
+// Project:	Zip CPU backend for GNU Binutils
+//
+// Purpose:	Zip-specific support for 32-bit ELF.
+//
+//	This file is part of BFD, the Binary File Descriptor library.
+//
+// Creator:	Dan Gisselquist, Ph.D.
+//		Gisselquist Technology, LLC
+//
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (C) 2016, Gisselquist Technology, LLC
+//
+// This program is free software (firmware): you can redistribute it and/or
+// modify it under the terms of  the GNU General Public License as published
+// by the Free Software Foundation, either version 3 of the License, or (at
+// your option) any later version.
+//
+// This program is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this program.  (It's in the $(ROOT)/doc directory, run make with no
+// target there if the PDF file isn't present.)  If not, see
+// <http://www.gnu.org/licenses/> for a copy.
+//
+// License:	GPL, v3, as defined and found on www.gnu.org,
+//		http://www.gnu.org/licenses/gpl.html
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/zip.h"
+#include <limits.h>
+#include <stdint.h>
+
+/*
+bfd_reloc_status_type
+zip_elf_pcrel_reloc (bfd *, arelent *, asymbol *, void *,
+		      asection *, bfd *, char **);
+*/
+#define	zip_relocation	bfd_elf_generic_reloc
+static bfd_reloc_status_type
+zip_brev_relocation(bfd *, arelent *, asymbol *, void *, asection *,
+		bfd *, char **error_messsage);
+static uint32_t zip_bitreverse(uint32_t v);
+
+/* Forward declarations.  */
+static reloc_howto_type zip_elf_howto_table [] =
+{
+  /* This reloc does nothing.  */
+  HOWTO (R_ZIP_NONE,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	/* special_function */
+	 "R_ZIP_NONE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 32 bit absolute relocation.  */
+  HOWTO (R_ZIP_VALUE,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 zip_relocation,	/* special_function */
+	 "R_ZIP_VALUE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00000000,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* An 18 bit operand B immediate.  */
+  HOWTO (R_ZIP_OPB_IMM,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 18,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	/* special_function */
+	 "R_ZIP_OPB_IMM",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00000000,		/* src_mask */
+	 0x0003ffff,		/* dst_mask */
+	 FALSE),			/* pcrel_offset */
+
+  /* An 18 bit relocation.  */
+  HOWTO (R_ZIP_OPB_OFFSET,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 14,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	/* special_function */
+	 "R_ZIP_OPB_OFFSET",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00000000,		/* src_mask */
+	 0x00003fff,		/* dst_mask-14 bits */
+	 FALSE),			/* pcrel_offset */
+
+  /* An 18 bit operand B immediate, but relative to the current PC.  */
+  HOWTO (R_ZIP_OPB_PCREL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 18,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	/* special_function */
+	 "R_ZIP_OPB_PCREL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00000000,		/* src_mask */
+	 0x0003ffff,		/* dst_mask-14 bits */
+	 FALSE),		/* pcrel_offset */
+
+  /* An 18 bit operand B immediate, but relative to the Global Offset Table. */
+  HOWTO (R_ZIP_OPB_GOTREL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 18,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	/* special_function */
+	 "R_ZIP_OPB_GOTREL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00000000,		/* src_mask */
+	 0x0003ffff,		/* dst_mask-14 bits */
+	 FALSE),		/* pcrel_offset */
+
+  /* */
+  HOWTO (R_ZIP_MOV_OFFSET,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 13,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	 /* special_function */
+	 "R_ZIP_MOV_OFFSET",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x00001fff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* */
+  HOWTO (R_ZIP_MOV_PCREL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 13,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	 /* special_function */
+	 "R_ZIP_MOV_PCREL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x00001fff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* */
+  HOWTO (R_ZIP_MOV_GOTREL,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 13,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	 /* special_function */
+	 "R_ZIP_MOV_GOTREL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x00001fff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_ZIP_LDI,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	 /* special_function */
+	 "R_ZIP_LDI",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x007fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_ZIP_LLO,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	 /* special_function */
+	 "R_ZIP_LLO",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_ZIP_LHI,		/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_relocation,	 /* special_function */
+	 "R_ZIP_LHI",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_ZIP_BREV,		/* type -- LDIHI, but with bitreverse */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 zip_brev_relocation,	 /* special_function--needed for the bitreverse */
+	 "R_ZIP_BREV",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0003ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_ZIP_BROKEN_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	 /* special_function */
+	 "R_ZIP_BROKEN_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ff,		/* dst_mask */
+	 FALSE)		/* pcrel_offset */
+};
+
+/* This structure is used to map BFD reloc codes to Zip ELF relocations */
+
+struct elf_reloc_map
+{
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned int elf_reloc_val;
+};
+
+static const struct elf_reloc_map zip_reloc_map [] =
+{
+  { BFD_RELOC_NONE,		R_ZIP_NONE },
+  { BFD_RELOC_ZIP_VALUE,	R_ZIP_VALUE },
+  { BFD_RELOC_ZIP_OPB_IMM,	R_ZIP_OPB_IMM },
+  { BFD_RELOC_ZIP_OPB_OFFSET,	R_ZIP_OPB_OFFSET },
+  { BFD_RELOC_ZIP_OPB_PCREL,	R_ZIP_OPB_PCREL },
+  { BFD_RELOC_ZIP_OPB_GOTREL,	R_ZIP_OPB_GOTREL },
+  { BFD_RELOC_ZIP_MOV_OFFSET,	R_ZIP_MOV_OFFSET },
+  { BFD_RELOC_ZIP_MOV_PCREL,	R_ZIP_MOV_PCREL },
+  { BFD_RELOC_ZIP_MOV_GOTREL,	R_ZIP_MOV_GOTREL },
+  { BFD_RELOC_ZIP_LDI,		R_ZIP_LDI },
+  { BFD_RELOC_ZIP_LLO,		R_ZIP_LLO },
+  { BFD_RELOC_ZIP_LHI,		R_ZIP_LHI },
+  { BFD_RELOC_ZIP_BREV,		R_ZIP_BREV },
+  { BFD_RELOC_14,		R_ZIP_OPB_OFFSET },
+  { BFD_RELOC_16,		R_ZIP_LLO },
+  { BFD_RELOC_32,		R_ZIP_VALUE }
+};
+
+/* Given a BFD reloc code, return the howto structure for the corresponding
+ * Zip ELF relocation. */
+static reloc_howto_type *
+zip_elf_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
+			bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof (zip_reloc_map) / sizeof (zip_reloc_map[0]); i++)
+    if (zip_reloc_map [i].bfd_reloc_val == code)
+      return & zip_elf_howto_table [(int)zip_reloc_map[i].elf_reloc_val];
+
+  return NULL;
+}
+
+static reloc_howto_type *
+zip_elf_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED, const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < sizeof (zip_elf_howto_table) / sizeof (zip_elf_howto_table[0]);
+       i++)
+    if (zip_elf_howto_table[i].name != NULL
+	&& strcasecmp (zip_elf_howto_table[i].name, r_name) == 0)
+      return &zip_elf_howto_table[i];
+
+  return NULL;
+}
+
+/* Given an ELF reloc, fill in the howto field of a relent. */
+static void
+zip_elf_info_to_howto(bfd * abfd ATTRIBUTE_UNUSED,
+			 arelent * cache_ptr,
+			 Elf_Internal_Rela * dst)
+{
+	unsigned int r;
+
+	r = ELF32_R_TYPE(dst->r_info);
+  	BFD_ASSERT (r < (unsigned int) R_ZIP_max);
+  	cache_ptr->howto = &zip_elf_howto_table [r];
+}
+
+static bfd_boolean
+zip_elf_relocate_section(bfd *output_bfd,
+			struct bfd_link_info *info,
+			bfd *input_bfd,
+			asection *input_section,
+			bfd_byte *contents,
+			Elf_Internal_Rela *relocs,
+			Elf_Internal_Sym *local_syms,
+			asection **local_sections)
+{
+	Elf_Internal_Shdr	*symtab_hdr;
+	struct	elf_link_hash_entry	**sym_hashes;
+	Elf_Internal_Rela	*rel, *relend;
+
+	symtab_hdr = &elf_tdata(input_bfd)->symtab_hdr;
+	sym_hashes = elf_sym_hashes(input_bfd);
+	relend = relocs+input_section->reloc_count;
+
+	for(rel=relocs; rel<relend; rel++) {
+		reloc_howto_type *howto;
+		unsigned long r_symndx;
+		Elf_Internal_Sym	*sym;
+		asection		*sec;
+		struct elf_link_hash_entry	*h;
+		bfd_vma				relocation;
+		bfd_reloc_status_type		r;
+		const char 			*name = NULL;
+		int				r_type;
+
+		r_type = ELF32_R_TYPE(rel->r_info);
+		r_symndx = ELF32_R_SYM(rel->r_info);
+
+		if ((r_type < 0) || (r_type >= (int)R_ZIP_max))
+		{
+			bfd_set_error(bfd_error_bad_value);
+			return FALSE;
+		}
+
+		howto = zip_elf_howto_table + ELF32_R_TYPE(rel->r_info);
+		h = NULL;
+		sym = NULL;
+		sec = NULL;
+
+		if (r_symndx < symtab_hdr->sh_info)
+		{
+			sym = local_syms + r_symndx;
+			sec = local_sections[r_symndx];
+			relocation = _bfd_elf_rela_local_sym(output_bfd, sym, &sec, rel);
+			name = bfd_elf_string_from_elf_section
+				(input_bfd, symtab_hdr->sh_link, sym->st_name);
+			name = (name == NULL) ? bfd_section_name(inpu_bfd, sec)
+					: name;
+		} else {
+			bfd_boolean unresolved_reloc, warned, ignored;
+
+			RELOC_FOR_GLOBAL_SYMBOL(info, input_bfd, input_section,
+				rel, r_symndx, symtab_hdr, sym_hashes, h, sec,
+				relocation, unresolved_reloc, warned, ignored);
+		}
+
+		if ((sec != NULL)&&(discarded_section(sec)))
+			RELOC_AGAINST_DISCARDED_SECTION(info, input_bfd,
+				input_section, rel, 1, relend, howto, 0,
+				contents);
+
+		if (info->relocatable)
+			continue;
+
+		if (howto->type == R_ZIP_BREV) {
+			if (rel->r_offset > bfd_get_section_limit(input_bfd, input_section)) {
+				r = bfd_reloc_outofrange;
+			} else {
+				uint32_t	brev_reloc;
+				bfd_byte	*location;
+				bfd_vma		x;
+
+				location = contents + rel->r_offset * bfd_octets_per_byte(input_bfd);
+
+				relocation += rel->r_addend;
+				brev_reloc= zip_bitreverse(relocation);
+				x = bfd_get_32(input_bfd, location);
+				x = ((x & ~howto->dst_mask)
+				|(((x & howto->src_mask)+brev_reloc)&howto->dst_mask));
+				bfd_put_32(input_bfd, x, location);
+				r = bfd_reloc_ok;
+			}
+		} else {
+			r = _bfd_final_link_relocate(howto, input_bfd,
+				input_section,
+				contents, rel->r_offset,
+				relocation,
+				rel->r_addend);
+		}
+
+
+		if (r != bfd_reloc_ok)
+		{
+			const char *msg = NULL;
+
+			switch(r)
+			{
+				case bfd_reloc_overflow:
+					r = info->callbacks->reloc_overflow(
+						info, (h?&h->root:NULL),
+						name, howto->name, 
+						(bfd_vma)0, input_bfd,
+						input_section, rel->r_offset);
+					break;
+				case bfd_reloc_undefined:
+					r = info->callbacks->undefined_symbol(
+						info, name, input_bfd,
+						input_section, rel->r_offset,
+						TRUE);
+					break;
+				case bfd_reloc_outofrange:
+					msg = _("internal error: out of range error");
+					break;
+				case bfd_reloc_notsupported:
+					msg = _("internal error: unsupported relocation");
+					break;
+				case bfd_reloc_dangerous:
+					msg = _("internal error: dangerous relocation");
+					break;
+				default:
+					msg = _("internal error: unknown error");
+					break;
+			}
+
+			if (msg)
+				r = info->callbacks->warning(info, msg, name,
+					input_bfd, input_section,
+					rel->r_offset);
+
+			if (!r)
+				return FALSE;
+		}
+	}
+	return TRUE;
+}
+
+static bfd_boolean
+zip_define_common_symbol(bfd *output_bfd,
+		struct bfd_link_info *info ATTRIBUTE_UNUSED,
+		struct	bfd_link_hash_entry *h) {
+  bfd_vma size;
+  asection *section;
+
+  BFD_ASSERT (h != NULL && h->type == bfd_link_hash_common);
+
+  size = h->u.c.size * bfd_octets_per_byte(output_bfd);
+  section = h->u.c.p->section;
+  h->u.c.p->alignment_power = 0;
+
+  /* Change the symbol from common to defined.  */
+  h->type = bfd_link_hash_defined;
+  h->u.def.section = section;
+	// section->size is in octets, not bytes
+  h->u.def.value = section->size/bfd_octets_per_byte(output_bfd);
+
+  /* Increase the size of the section.  */
+  section->size += size;
+
+  /* Make sure the section is allocated in memory, and make sure that
+     it is no longer a common section.  */
+  section->flags |= SEC_ALLOC;
+  section->flags &= ~SEC_IS_COMMON;
+  return TRUE;
+}
+#define bfd_elf32_bfd_define_common_symbol	zip_define_common_symbol
+
+static uint32_t
+zip_bitreverse(uint32_t v) {
+	unsigned r = 0, b;
+
+	for(b=0; b<32; b++, v>>=1)
+		r = (r<<1)|(v&1);
+
+	return r;
+}
+
+static bfd_reloc_status_type
+zip_brev_relocation(bfd *abfd ATTRIBUTE_UNUSED,
+		arelent *reloc_entry,
+		asymbol *symbol,
+		void *data ATTRIBUTE_UNUSED,
+		asection *input_section,
+		bfd *output_bfd,
+		char **error_messsage ATTRIBUTE_UNUSED)
+{
+	bfd_vma	relocation;
+	bfd_size_type octets = reloc_entry->address * bfd_octets_per_byte(abfd);
+	bfd_vma output_base = 0;
+	reloc_howto_type *howto = reloc_entry->howto;
+
+	if ((output_bfd != NULL)
+		&&((symbol->flags & BSF_SECTION_SYM)==0)
+		&&((! reloc_entry->howto->partial_inplace)
+			|| (reloc_entry->addend == 0))) {
+		reloc_entry->address += input_section->output_offset;
+		return bfd_reloc_ok;
+	}
+
+	// Otherwise, we need to adjust our file itself with this value ...
+	if (reloc_entry->address > bfd_get_section_limit(abfd, input_section))
+		return bfd_reloc_outofrange;
+
+	// Get symbol value */
+	if (bfd_is_com_section(symbol->section))
+		relocation = 0;
+	else
+		relocation = symbol->value;
+
+	/* Convert input-section relative symbol value to absolute */
+	if (((output_bfd)&&(!howto->partial_inplace))
+			||(symbol->section->output_section == NULL))
+		output_base = 0;
+	else
+		output_base = symbol->section->output_section->vma;
+
+	relocation += output_base + symbol->section->output_offset;
+
+	/* Add in supplied addend. */
+	relocation += reloc_entry->addend;
+
+	// BREV does not handle PC relative offsets
+	// if howto->pcrel_offset ...
+
+	//
+	if (output_bfd != NULL) {
+		reloc_entry->addend = relocation;
+		reloc_entry->address += input_section->output_offset;
+		if (!howto->partial_inplace) {
+			return bfd_reloc_ok;
+		}
+	}
+
+	// Ignore overflow checking ... we don't know (yet) whether or not we
+	// even have an overflow at this point.   That is, if we could.  We're
+	// encoding the top 16 (18) bits of a number, overflow is ... not a 
+	// problem.
+	//
+	// if howto->complain_on_overflow ...
+
+	// relocation >>= howto->rightshift;	// = 0
+	// relocation <<= howto->bitpos;		// = 0
+
+	// Logic (nearly) copied from reloc.c:bfd_perform_relocation
+	unsigned	x = bfd_get_32(abfd, (bfd_byte *)data + octets);
+
+	// Here's why we are going through this pain!
+	x = zip_bitreverse((unsigned)x);
+
+	// Now we can continue as before....
+	x = ((x&(~howto->dst_mask))
+		|(((x&howto->src_mask)+relocation)&howto->dst_mask));
+	bfd_put_32(abfd, (bfd_vma)x, (bfd_byte *)data + octets);
+
+	return bfd_reloc_ok;
+}
+
+// Zip Defines
+#define	TARGET_BIG_SYM	zip_elf32_vec
+#define	TARGET_BIG_NAME	"elf32-zip"
+
+#ifdef TARGET_BYTES_BIG_ENDIAN
+#if (TARGET_BYTES_BIG_ENDIAN == 0)
+#undef	TARGET_BIG_SYM
+#undef	TARGET_BIG_NAME
+
+#define	TARGET_LITTLE_SYM	zip_elf32_vec
+#define	TARGET_LITTLE_NAME	"elf32-zip"
+#endif
+#endif
+
+#define	ELF_ARCH	bfd_arch_zip
+// #define ELF_TARGET_ID		ZIP_ELF_DATA
+#define	ELF_MACHINE_CODE	EM_ZIP
+
+#define	ELF_MAXPAGESIZE		0x1000
+#define	ARCH_SIZE		32
+
+#define	bfd_elf32_bfd_reloc_type_lookup	zip_elf_reloc_type_lookup
+#define	bfd_elf32_bfd_reloc_name_lookup	zip_elf_reloc_name_lookup
+#define	elf_info_to_howto_rel	0
+#define	elf_info_to_howto	zip_elf_info_to_howto
+#define	elf_backend_relocate_section	zip_elf_relocate_section
+#define	elf_backend_rela_normal		1
+
+// Default ELF32 defines from elf32-target.h that we would've normally included
+// here, had we not been a OCTETS_PER_BYTE=4 machine
+
+#define	bfd_elf32_close_and_cleanup _bfd_elf_close_and_cleanup
+#define bfd_elf32_bfd_free_cached_info _bfd_free_cached_info
+#define bfd_elf32_get_section_contents _bfd_generic_get_section_contents
+#define bfd_elf32_canonicalize_dynamic_symtab \
+  _bfd_elf_canonicalize_dynamic_symtab
+#define bfd_elf32_get_synthetic_symtab _bfd_elf_get_synthetic_symtab
+#define bfd_elf32_canonicalize_reloc	_bfd_elf_canonicalize_reloc
+#define bfd_elf32_find_nearest_line	_bfd_elf_find_nearest_line
+#define bfd_elf32_find_line		_bfd_elf_find_line
+#define bfd_elf32_find_inliner_info	_bfd_elf_find_inliner_info
+#define bfd_elf32_read_minisymbols	_bfd_elf_read_minisymbols
+#define bfd_elf32_minisymbol_to_symbol	_bfd_elf_minisymbol_to_symbol
+#define bfd_elf32_get_dynamic_symtab_upper_bound \
+  _bfd_elf_get_dynamic_symtab_upper_bound
+#define bfd_elf32_get_lineno		_bfd_elf_get_lineno
+#define bfd_elf32_get_reloc_upper_bound _bfd_elf_get_reloc_upper_bound
+#define bfd_elf32_get_symbol_info	_bfd_elf_get_symbol_info
+#define bfd_elf32_canonicalize_symtab	_bfd_elf_canonicalize_symtab
+#define bfd_elf32_get_symtab_upper_bound _bfd_elf_get_symtab_upper_bound
+#define bfd_elf32_make_empty_symbol	_bfd_elf_make_empty_symbol
+#define bfd_elf32_new_section_hook	_bfd_elf_new_section_hook
+#define bfd_elf32_set_arch_mach		_bfd_elf_set_arch_mach
+#define bfd_elf32_set_section_contents	_bfd_elf_set_section_contents
+#define bfd_elf32_sizeof_headers	_bfd_elf_sizeof_headers
+#define bfd_elf32_write_object_contents _bfd_elf_write_object_contents
+#define bfd_elf32_write_corefile_contents _bfd_elf_write_corefile_contents
+
+#define bfd_elf32_get_section_contents_in_window \
+  _bfd_generic_get_section_contents_in_window
+
+#define elf_backend_can_refcount 0
+#define elf_backend_want_got_plt 0
+#define elf_backend_plt_readonly 0
+#define elf_backend_want_plt_sym 0
+#define elf_backend_plt_not_loaded 0
+#define elf_backend_plt_alignment 2
+#define elf_backend_want_dynbss 1
+#define elf_backend_want_p_paddr_set_to_zero 0
+#define elf_backend_default_execstack 1
+#define elf_backend_caches_rawsize 0
+#define elf_backend_stack_align 16
+
+#define bfd_elf32_bfd_debug_info_start	bfd_void
+#define bfd_elf32_bfd_debug_info_end	bfd_void
+#define bfd_elf32_bfd_debug_info_accumulate \
+  ((void (*) (bfd*, struct bfd_section *)) bfd_void)
+
+#define bfd_elf32_bfd_get_relocated_section_contents \
+  bfd_generic_get_relocated_section_contents
+
+#define bfd_elf32_bfd_relax_section bfd_generic_relax_section
+
+#define elf_backend_can_gc_sections 0
+#define elf_backend_can_refcount 0
+#define elf_backend_want_got_sym 1
+#define elf_backend_gc_keep		_bfd_elf_gc_keep
+#define elf_backend_gc_mark_dynamic_ref	bfd_elf_gc_mark_dynamic_ref_symbol
+#define elf_backend_gc_mark_hook	_bfd_elf_gc_mark_hook
+#define elf_backend_gc_mark_extra_sections _bfd_elf_gc_mark_extra_sections
+#define elf_backend_gc_sweep_hook	NULL
+#define bfd_elf32_bfd_gc_sections bfd_elf_gc_sections
+
+#ifndef bfd_elf32_bfd_merge_sections
+#define bfd_elf32_bfd_merge_sections \
+  _bfd_elf_merge_sections
+#endif
+
+#ifndef bfd_elf32_bfd_is_group_section
+#define bfd_elf32_bfd_is_group_section bfd_elf_is_group_section
+#endif
+
+#ifndef bfd_elf32_bfd_discard_group
+#define bfd_elf32_bfd_discard_group bfd_generic_discard_group
+#endif
+
+#ifndef bfd_elf32_section_already_linked
+#define bfd_elf32_section_already_linked \
+  _bfd_elf_section_already_linked
+#endif
+
+#ifndef bfd_elf32_bfd_define_common_symbol
+#define bfd_elf32_bfd_define_common_symbol bfd_generic_define_common_symbol
+#endif
+
+#ifndef bfd_elf32_bfd_lookup_section_flags
+#define bfd_elf32_bfd_lookup_section_flags bfd_elf_lookup_section_flags
+#endif
+
+#ifndef bfd_elf32_bfd_make_debug_symbol
+#define bfd_elf32_bfd_make_debug_symbol \
+  ((asymbol * (*) (bfd *, void *, unsigned long)) bfd_nullvoidptr)
+#endif
+
+#ifndef bfd_elf32_bfd_copy_private_symbol_data
+#define bfd_elf32_bfd_copy_private_symbol_data \
+  _bfd_elf_copy_private_symbol_data
+#endif
+
+#ifndef bfd_elf32_bfd_copy_private_section_data
+#define bfd_elf32_bfd_copy_private_section_data \
+  _bfd_elf_copy_private_section_data
+#endif
+#ifndef bfd_elf32_bfd_copy_private_header_data
+#define bfd_elf32_bfd_copy_private_header_data \
+  _bfd_elf_copy_private_header_data
+#endif
+#ifndef bfd_elf32_bfd_copy_private_bfd_data
+#define bfd_elf32_bfd_copy_private_bfd_data \
+  _bfd_elf_copy_private_bfd_data
+#endif
+#ifndef bfd_elf32_bfd_print_private_bfd_data
+#define bfd_elf32_bfd_print_private_bfd_data \
+  _bfd_elf_print_private_bfd_data
+#endif
+#ifndef bfd_elf32_bfd_merge_private_bfd_data
+#define bfd_elf32_bfd_merge_private_bfd_data \
+  ((bfd_boolean (*) (bfd *, bfd *)) bfd_true)
+#endif
+#ifndef bfd_elf32_bfd_set_private_flags
+#define bfd_elf32_bfd_set_private_flags \
+  ((bfd_boolean (*) (bfd *, flagword)) bfd_true)
+#endif
+#ifndef bfd_elf32_bfd_is_local_label_name
+#define bfd_elf32_bfd_is_local_label_name _bfd_elf_is_local_label_name
+#endif
+#ifndef bfd_elf32_bfd_is_target_special_symbol
+#define bfd_elf32_bfd_is_target_special_symbol \
+  ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
+#endif
+
+#ifndef bfd_elf32_get_dynamic_reloc_upper_bound
+#define bfd_elf32_get_dynamic_reloc_upper_bound \
+  _bfd_elf_get_dynamic_reloc_upper_bound
+#endif
+#ifndef bfd_elf32_canonicalize_dynamic_reloc
+#define bfd_elf32_canonicalize_dynamic_reloc \
+  _bfd_elf_canonicalize_dynamic_reloc
+#endif
+
+#define bfd_elf32_bfd_link_hash_table_create _bfd_elf_link_hash_table_create
+#define bfd_elf32_bfd_link_add_symbols	bfd_elf_link_add_symbols
+#define bfd_elf32_bfd_final_link	bfd_elf_final_link
+
+#define bfd_elf32_bfd_link_just_syms	_bfd_elf_link_just_syms
+
+#define bfd_elf32_bfd_copy_link_hash_symbol_type \
+  _bfd_elf_copy_link_hash_symbol_type
+
+#define bfd_elf32_bfd_link_split_section _bfd_generic_link_split_section
+#define bfd_elf32_archive_p bfd_generic_archive_p
+#define bfd_elf32_write_archive_contents _bfd_write_archive_contents
+#define bfd_elf32_mkobject bfd_elf_make_object
+#define bfd_elf32_mkcorefile bfd_elf_mkcorefile
+#define bfd_elf32_mkarchive _bfd_generic_mkarchive
+#define bfd_elf32_print_symbol bfd_elf_print_symbol
+#define elf_symbol_leading_char 0
+
+#define elf_backend_arch_data NULL
+
+#ifndef ELF_TARGET_ID
+#define ELF_TARGET_ID	GENERIC_ELF_DATA
+#endif
+
+#ifndef ELF_OSABI
+#define ELF_OSABI ELFOSABI_NONE
+#endif
+
+#define ELF_COMMONPAGESIZE ELF_MAXPAGESIZE
+#define ELF_MINPAGESIZE ELF_COMMONPAGESIZE
+
+#if ELF_COMMONPAGESIZE > ELF_MAXPAGESIZE
+# error ELF_COMMONPAGESIZE > ELF_MAXPAGESIZE
+#endif
+#if ELF_MINPAGESIZE > ELF_COMMONPAGESIZE
+# error ELF_MINPAGESIZE > ELF_COMMONPAGESIZE
+#endif
+
+#ifndef ELF_DYNAMIC_SEC_FLAGS
+/* Note that we set the SEC_IN_MEMORY flag for these sections.  */
+#define ELF_DYNAMIC_SEC_FLAGS			\
+  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS	\
+   | SEC_IN_MEMORY | SEC_LINKER_CREATED)
+#endif
+
+#define elf_backend_collect		FALSE
+#define elf_backend_type_change_ok	FALSE
+
+#define elf_backend_sym_is_global		0
+#define elf_backend_object_p			0
+#define elf_backend_symbol_processing		0
+#define elf_backend_symbol_table_processing	0
+#define elf_backend_get_symbol_type		0
+#define elf_backend_archive_symbol_lookup _bfd_elf_archive_symbol_lookup
+#define elf_backend_name_local_section_symbols	0
+#define elf_backend_section_processing		0
+#define elf_backend_section_from_shdr	_bfd_elf_make_section_from_shdr
+#define elf_backend_section_flags		0
+#define elf_backend_get_sec_type_attr	_bfd_elf_get_sec_type_attr
+#define elf_backend_section_from_phdr	_bfd_elf_make_section_from_phdr
+#define elf_backend_fake_sections		0
+#define elf_backend_section_from_bfd_section	0
+#define elf_backend_add_symbol_hook		0
+#define elf_backend_link_output_symbol_hook	0
+#define elf_backend_create_dynamic_sections	0
+#define elf_backend_omit_section_dynsym _bfd_elf_link_omit_section_dynsym
+#define elf_backend_relocs_compatible _bfd_elf_default_relocs_compatible
+#define elf_backend_check_relocs	0
+#define elf_backend_check_directives	0
+#define elf_backend_notice_as_needed	_bfd_elf_notice_as_needed
+#define elf_backend_adjust_dynamic_symbol 0
+#define elf_backend_always_size_sections 0
+#define elf_backend_size_dynamic_sections 0
+#define elf_backend_init_index_section \
+ ((void (*) (bfd *, struct bfd_link_info *)) bfd_void)
+#define elf_backend_finish_dynamic_symbol	0
+#define elf_backend_finish_dynamic_sections	0
+#define elf_backend_begin_write_processing	0
+#define elf_backend_final_write_processing	0
+#define elf_backend_additional_program_headers	0
+#define elf_backend_modify_segment_map	0
+#ifndef elf_backend_modify_program_headers
+#define elf_backend_modify_program_headers	0
+#endif
+#ifndef elf_backend_ecoff_debug_swap
+#define elf_backend_ecoff_debug_swap	0
+#endif
+#ifndef elf_backend_bfd_from_remote_memory
+#define elf_backend_bfd_from_remote_memory _bfd_elf32_bfd_from_remote_memory
+#endif
+#ifndef elf_backend_got_header_size
+#define elf_backend_got_header_size	0
+#endif
+#ifndef elf_backend_got_elt_size
+#define elf_backend_got_elt_size _bfd_elf_default_got_elt_size
+#endif
+#ifndef elf_backend_obj_attrs_vendor
+#define elf_backend_obj_attrs_vendor		NULL
+#endif
+#ifndef elf_backend_obj_attrs_section
+#define elf_backend_obj_attrs_section		NULL
+#endif
+#ifndef elf_backend_obj_attrs_arg_type
+#define elf_backend_obj_attrs_arg_type		NULL
+#endif
+#ifndef elf_backend_obj_attrs_section_type
+#define elf_backend_obj_attrs_section_type		SHT_GNU_ATTRIBUTES
+#endif
+#ifndef elf_backend_obj_attrs_order
+#define elf_backend_obj_attrs_order		NULL
+#endif
+#define elf_backend_obj_attrs_handle_unknown	NULL
+#define elf_backend_static_tls_alignment	1
+#define elf_backend_post_process_headers	_bfd_elf_post_process_headers
+#define elf_backend_print_symbol_all		NULL
+#define elf_backend_output_arch_local_syms	NULL
+#define elf_backend_output_arch_syms		NULL
+#define elf_backend_copy_indirect_symbol  _bfd_elf_link_hash_copy_indirect
+#define elf_backend_hide_symbol		_bfd_elf_link_hash_hide_symbol
+#define elf_backend_fixup_symbol		NULL
+#define elf_backend_merge_symbol_attribute	NULL
+#define elf_backend_get_target_dtag		NULL
+#define elf_backend_ignore_undef_symbol		NULL
+#define elf_backend_emit_relocs			_bfd_elf_link_output_relocs
+#define elf_backend_count_relocs		NULL
+#define elf_backend_grok_prstatus		NULL
+#define elf_backend_grok_psinfo			NULL
+#define elf_backend_write_core_note		NULL
+#define elf_backend_lookup_section_flags_hook	NULL
+#define elf_backend_reloc_type_class		_bfd_elf_reloc_type_class
+#define elf_backend_discard_info		NULL
+#define elf_backend_ignore_discarded_relocs	NULL
+#define elf_backend_action_discarded _bfd_elf_default_action_discarded
+#define elf_backend_eh_frame_address_size _bfd_elf_eh_frame_address_size
+#define elf_backend_can_make_relative_eh_frame	_bfd_elf_can_make_relative
+#define elf_backend_can_make_lsda_relative_eh_frame	_bfd_elf_can_make_relative
+#define elf_backend_encode_eh_address		_bfd_elf_encode_eh_address
+#define elf_backend_write_section		NULL
+#define elf_backend_mips_irix_compat		NULL
+#define elf_backend_mips_rtype_to_howto		NULL
+
+/* Previously, backends could only use SHT_REL or SHT_RELA relocation
+   sections, but not both.  They defined USE_REL to indicate SHT_REL
+   sections, and left it undefined to indicated SHT_RELA sections.
+   For backwards compatibility, we still support this usage.  */
+#ifndef USE_REL
+#define USE_REL 0
+#endif
+
+/* Use these in new code.  */
+#define elf_backend_may_use_rel_p USE_REL
+#define elf_backend_may_use_rela_p !USE_REL
+#define elf_backend_default_use_rela_p !USE_REL
+#define elf_backend_rela_plts_and_copies_p elf_backend_default_use_rela_p
+
+#ifndef elf_backend_rela_normal
+#define elf_backend_rela_normal 0
+#endif
+
+#define elf_backend_plt_sym_val NULL
+#define elf_backend_relplt_name NULL
+
+#define ELF_MACHINE_ALT1 0
+#define ELF_MACHINE_ALT2 0
+
+#ifndef elf_backend_size_info
+#define elf_backend_size_info _bfd_elf32_size_info
+#endif
+
+#define elf_backend_special_sections NULL
+#define elf_backend_sign_extend_vma 0
+#define elf_backend_link_order_error_handler _bfd_default_error_handler
+#define elf_backend_common_definition _bfd_elf_common_definition
+#define elf_backend_common_section_index _bfd_elf_common_section_index
+#define elf_backend_common_section _bfd_elf_common_section
+
+#define elf_backend_merge_symbol NULL
+#define elf_backend_hash_symbol _bfd_elf_hash_symbol
+#define elf_backend_is_function_type _bfd_elf_is_function_type
+#define elf_backend_maybe_function_sym _bfd_elf_maybe_function_sym
+
+#define elf_match_priority \
+  (ELF_ARCH == bfd_arch_unknown ? 2 : ELF_OSABI == ELFOSABI_NONE ? 1 : 0)
+
+extern const struct elf_size_info _bfd_elf32_size_info;
+
+static struct elf_backend_data elf32_bed =
+{
+  ELF_ARCH,			/* arch */
+  ELF_TARGET_ID,		/* target_id */
+  ELF_MACHINE_CODE,		/* elf_machine_code */
+  ELF_OSABI,			/* elf_osabi  */
+  ELF_MAXPAGESIZE,		/* maxpagesize */
+  ELF_MINPAGESIZE,		/* minpagesize */
+  ELF_COMMONPAGESIZE,		/* commonpagesize */
+  ELF_DYNAMIC_SEC_FLAGS,	/* dynamic_sec_flags */
+  elf_backend_arch_data,
+  elf_info_to_howto,
+  elf_info_to_howto_rel,
+  elf_backend_sym_is_global,
+  elf_backend_object_p,
+  elf_backend_symbol_processing,
+  elf_backend_symbol_table_processing,
+  elf_backend_get_symbol_type,
+  elf_backend_archive_symbol_lookup,
+  elf_backend_name_local_section_symbols,
+  elf_backend_section_processing,
+  elf_backend_section_from_shdr,
+  elf_backend_section_flags,
+  elf_backend_get_sec_type_attr,
+  elf_backend_section_from_phdr,
+  elf_backend_fake_sections,
+  elf_backend_section_from_bfd_section,
+  elf_backend_add_symbol_hook,
+  elf_backend_link_output_symbol_hook,
+  elf_backend_create_dynamic_sections,
+  elf_backend_omit_section_dynsym,
+  elf_backend_relocs_compatible,
+  elf_backend_check_relocs,
+  elf_backend_check_directives,
+  elf_backend_notice_as_needed,
+  elf_backend_adjust_dynamic_symbol,
+  elf_backend_always_size_sections,
+  elf_backend_size_dynamic_sections,
+  elf_backend_init_index_section,
+  elf_backend_relocate_section,
+  elf_backend_finish_dynamic_symbol,
+  elf_backend_finish_dynamic_sections,
+  elf_backend_begin_write_processing,
+  elf_backend_final_write_processing,
+  elf_backend_additional_program_headers,
+  elf_backend_modify_segment_map,
+  elf_backend_modify_program_headers,
+  elf_backend_gc_keep,
+  elf_backend_gc_mark_dynamic_ref,
+  elf_backend_gc_mark_hook,
+  elf_backend_gc_mark_extra_sections,
+  elf_backend_gc_sweep_hook,
+  elf_backend_post_process_headers,
+  elf_backend_print_symbol_all,
+  elf_backend_output_arch_local_syms,
+  elf_backend_output_arch_syms,
+  elf_backend_copy_indirect_symbol,
+  elf_backend_hide_symbol,
+  elf_backend_fixup_symbol,
+  elf_backend_merge_symbol_attribute,
+  elf_backend_get_target_dtag,
+  elf_backend_ignore_undef_symbol,
+  elf_backend_emit_relocs,
+  elf_backend_count_relocs,
+  elf_backend_grok_prstatus,
+  elf_backend_grok_psinfo,
+  elf_backend_write_core_note,
+  elf_backend_lookup_section_flags_hook,
+  elf_backend_reloc_type_class,
+  elf_backend_discard_info,
+  elf_backend_ignore_discarded_relocs,
+  elf_backend_action_discarded,
+  elf_backend_eh_frame_address_size,
+  elf_backend_can_make_relative_eh_frame,
+  elf_backend_can_make_lsda_relative_eh_frame,
+  elf_backend_encode_eh_address,
+  elf_backend_write_section,
+  elf_backend_mips_irix_compat,
+  elf_backend_mips_rtype_to_howto,
+  elf_backend_ecoff_debug_swap,
+  elf_backend_bfd_from_remote_memory,
+  elf_backend_plt_sym_val,
+  elf_backend_common_definition,
+  elf_backend_common_section_index,
+  elf_backend_common_section,
+  elf_backend_merge_symbol,
+  elf_backend_hash_symbol,
+  elf_backend_is_function_type,
+  elf_backend_maybe_function_sym,
+  elf_backend_link_order_error_handler,
+  elf_backend_relplt_name,
+  ELF_MACHINE_ALT1,
+  ELF_MACHINE_ALT2,
+  &elf_backend_size_info,
+  elf_backend_special_sections,
+  elf_backend_got_header_size,
+  elf_backend_got_elt_size,
+  elf_backend_obj_attrs_vendor,
+  elf_backend_obj_attrs_section,
+  elf_backend_obj_attrs_arg_type,
+  elf_backend_obj_attrs_section_type,
+  elf_backend_obj_attrs_order,
+  elf_backend_obj_attrs_handle_unknown,
+  elf_backend_static_tls_alignment,
+  elf_backend_stack_align,
+  elf_backend_collect,
+  elf_backend_type_change_ok,
+  elf_backend_may_use_rel_p,
+  elf_backend_may_use_rela_p,
+  elf_backend_default_use_rela_p,
+  elf_backend_rela_plts_and_copies_p,
+  elf_backend_rela_normal,
+  elf_backend_sign_extend_vma,
+  elf_backend_want_got_plt,
+  elf_backend_plt_readonly,
+  elf_backend_want_plt_sym,
+  elf_backend_plt_not_loaded,
+  elf_backend_plt_alignment,
+  elf_backend_can_gc_sections,
+  elf_backend_can_refcount,
+  elf_backend_want_got_sym,
+  elf_backend_want_dynbss,
+  elf_backend_want_p_paddr_set_to_zero,
+  elf_backend_default_execstack,
+  elf_backend_caches_rawsize
+};
+
+/* Forward declaration for use when initialising alternative_target field.  */
+#ifdef TARGET_LITTLE_SYM
+extern const bfd_target TARGET_LITTLE_SYM;
+#endif
+
+#ifdef TARGET_BIG_SYM
+const bfd_target TARGET_BIG_SYM =
+{
+  /* name: identify kind of target */
+  TARGET_BIG_NAME,
+
+  /* flavour: general indication about file */
+  bfd_target_elf_flavour,
+
+  /* byteorder: data is big endian */
+  BFD_ENDIAN_BIG,
+
+  /* header_byteorder: header is also big endian */
+  BFD_ENDIAN_BIG,
+
+  /* object_flags: mask of all file flags */
+  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | HAS_SYMS | HAS_LOCALS
+   | DYNAMIC | WP_TEXT | D_PAGED | BFD_COMPRESS | BFD_DECOMPRESS),
+
+  /* section_flags: mask of all section flags */
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY
+   | SEC_CODE | SEC_DATA | SEC_DEBUGGING | SEC_EXCLUDE | SEC_SORT_ENTRIES
+   | SEC_SMALL_DATA | SEC_MERGE | SEC_STRINGS | SEC_GROUP),
+
+   /* leading_symbol_char: is the first char of a user symbol
+      predictable, and if so what is it */
+  elf_symbol_leading_char,
+
+  /* ar_pad_char: pad character for filenames within an archive header
+     FIXME:  this really has nothing to do with ELF, this is a characteristic
+     of the archiver and/or os and should be independently tunable */
+  '/',
+
+  /* ar_max_namelen: maximum number of characters in an archive header
+     FIXME:  this really has nothing to do with ELF, this is a characteristic
+     of the archiver and should be independently tunable.  The System V ABI,
+     Chapter 7 (Formats & Protocols), Archive section sets this as 15.  */
+  15,
+
+  elf_match_priority,
+
+  /* Routines to byte-swap various sized integers from the data sections */
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
+    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
+    bfd_getb16, bfd_getb_signed_16, bfd_putb16,
+
+  /* Routines to byte-swap various sized integers from the file headers */
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
+    bfd_getb32, bfd_getb_signed_32, bfd_putb32,
+    bfd_getb16, bfd_getb_signed_16, bfd_putb16,
+
+  /* bfd_check_format: check the format of a file being read */
+  { _bfd_dummy_target,		/* unknown format */
+    bfd_elf32_object_p,		/* assembler/linker output (object file) */
+    bfd_elf32_archive_p,	/* an archive */
+    bfd_elf32_core_file_p	/* a core file */
+  },
+
+  /* bfd_set_format: set the format of a file being written */
+  { bfd_false,
+    bfd_elf32_mkobject,
+    bfd_elf32_mkarchive,
+    bfd_elf32_mkcorefile
+  },
+
+  /* bfd_write_contents: write cached information into a file being written */
+  { bfd_false,
+    bfd_elf32_write_object_contents,
+    bfd_elf32_write_archive_contents,
+    bfd_elf32_write_corefile_contents,
+  },
+
+  BFD_JUMP_TABLE_GENERIC (bfd_elf32),
+  BFD_JUMP_TABLE_COPY (bfd_elf32),
+  BFD_JUMP_TABLE_CORE (bfd_elf32),
+#ifdef bfd_elf32_archive_functions
+  BFD_JUMP_TABLE_ARCHIVE (bfd_elf32_archive),
+#else
+  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
+#endif
+  BFD_JUMP_TABLE_SYMBOLS (bfd_elf32),
+  BFD_JUMP_TABLE_RELOCS (bfd_elf32),
+  BFD_JUMP_TABLE_WRITE (bfd_elf32),
+  BFD_JUMP_TABLE_LINK (bfd_elf32),
+  BFD_JUMP_TABLE_DYNAMIC (bfd_elf32),
+
+  /* Alternative endian target.  */
+#ifdef TARGET_LITTLE_SYM
+  & TARGET_LITTLE_SYM,
+#else
+  NULL,
+#endif
+
+  /* backend_data: */
+  &elf32_bed
+};
+#endif
+
+#ifdef TARGET_LITTLE_SYM
+const bfd_target TARGET_LITTLE_SYM =
+{
+  /* name: identify kind of target */
+  TARGET_LITTLE_NAME,
+
+  /* flavour: general indication about file */
+  bfd_target_elf_flavour,
+
+  /* byteorder: data is little endian */
+  BFD_ENDIAN_LITTLE,
+
+  /* header_byteorder: header is also little endian */
+  BFD_ENDIAN_LITTLE,
+
+  /* object_flags: mask of all file flags */
+  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG | HAS_SYMS | HAS_LOCALS
+   | DYNAMIC | WP_TEXT | D_PAGED | BFD_COMPRESS | BFD_DECOMPRESS),
+
+  /* section_flags: mask of all section flags */
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY
+   | SEC_CODE | SEC_DATA | SEC_DEBUGGING | SEC_EXCLUDE | SEC_SORT_ENTRIES
+   | SEC_SMALL_DATA | SEC_MERGE | SEC_STRINGS | SEC_GROUP),
+
+   /* leading_symbol_char: is the first char of a user symbol
+      predictable, and if so what is it */
+  elf_symbol_leading_char,
+
+  /* ar_pad_char: pad character for filenames within an archive header
+     FIXME:  this really has nothing to do with ELF, this is a characteristic
+     of the archiver and/or os and should be independently tunable */
+  '/',
+
+  /* ar_max_namelen: maximum number of characters in an archive header
+     FIXME:  this really has nothing to do with ELF, this is a characteristic
+     of the archiver and should be independently tunable.  The System V ABI,
+     Chapter 7 (Formats & Protocols), Archive section sets this as 15.  */
+  15,
+
+  elf_match_priority,
+
+  /* Routines to byte-swap various sized integers from the data sections */
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+    bfd_getl16, bfd_getl_signed_16, bfd_putl16,
+
+  /* Routines to byte-swap various sized integers from the file headers */
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+    bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+    bfd_getl16, bfd_getl_signed_16, bfd_putl16,
+
+  /* bfd_check_format: check the format of a file being read */
+  { _bfd_dummy_target,		/* unknown format */
+    bfd_elf32_object_p,		/* assembler/linker output (object file) */
+    bfd_elf32_archive_p,	/* an archive */
+    bfd_elf32_core_file_p	/* a core file */
+  },
+
+  /* bfd_set_format: set the format of a file being written */
+  { bfd_false,
+    bfd_elf32_mkobject,
+    bfd_elf32_mkarchive,
+    bfd_elf32_mkcorefile
+  },
+
+  /* bfd_write_contents: write cached information into a file being written */
+  { bfd_false,
+    bfd_elf32_write_object_contents,
+    bfd_elf32_write_archive_contents,
+    bfd_elf32_write_corefile_contents,
+  },
+
+  BFD_JUMP_TABLE_GENERIC (bfd_elf32),
+  BFD_JUMP_TABLE_COPY (bfd_elf32),
+  BFD_JUMP_TABLE_CORE (bfd_elf32),
+#ifdef bfd_elf32_archive_functions
+  BFD_JUMP_TABLE_ARCHIVE (bfd_elf32_archive),
+#else
+  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
+#endif
+  BFD_JUMP_TABLE_SYMBOLS (bfd_elf32),
+  BFD_JUMP_TABLE_RELOCS (bfd_elf32),
+  BFD_JUMP_TABLE_WRITE (bfd_elf32),
+  BFD_JUMP_TABLE_LINK (bfd_elf32),
+  BFD_JUMP_TABLE_DYNAMIC (bfd_elf32),
+
+  /* Alternative endian target.  */
+#ifdef TARGET_BIG_SYM
+  & TARGET_BIG_SYM,
+#else
+  NULL,
+#endif
+
+  /* backend_data: */
+  &elf32_bed
+};
+#endif
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/elf.c binutils-2.25/bfd/elf.c
--- binutils-2.25-original/bfd/elf.c	2014-12-23 03:47:10.000000000 -0500
+++ binutils-2.25/bfd/elf.c	2016-02-21 18:53:19.020534440 -0500
@@ -9945,6 +9945,10 @@
 				     sym->st_value + addend);
 }
 
+/*
+ * Must return the section offset in bytes, that is, in the target's
+ * address space, rather than in the hosts 'octets'.
+ */
 bfd_vma
 _bfd_elf_section_offset (bfd *abfd,
 			 struct bfd_link_info *info,
@@ -9962,8 +9966,8 @@
       if ((sec->flags & SEC_ELF_REVERSE_COPY) != 0)
 	{
 	  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
-	  bfd_size_type address_size = bed->s->arch_size / 8;
-	  offset = sec->size - offset - address_size;
+	  bfd_size_type address_size = bed->s->arch_size / 8; // Octets
+	  offset = (sec->size -address_size)/bfd_octets_per_byte(abfd) - offset;
 	}
       return offset;
     }
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/elflink.c binutils-2.25/bfd/elflink.c
--- binutils-2.25-original/bfd/elflink.c	2014-12-23 03:47:10.000000000 -0500
+++ binutils-2.25/bfd/elflink.c	2016-03-10 09:53:38.011710873 -0500
@@ -1348,7 +1348,7 @@
 	return FALSE;
 
       if (sym->st_size > h->size)
-	h->size = sym->st_size;
+	h->size = sym->st_size; // Symbol sizes are in bytes, not octets
 
       *size_change_ok = TRUE;
     }
@@ -3008,7 +3008,7 @@
   s = bfd_get_linker_section (hash_table->dynobj, ".dynamic");
   BFD_ASSERT (s != NULL);
 
-  newsize = s->size + bed->s->sizeof_dyn;
+  newsize = s->size + bed->s->sizeof_dyn; // Octets
   newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
   if (newcontents == NULL)
     return FALSE;
@@ -3017,7 +3017,7 @@
   dyn.d_un.d_val = val;
   bed->s->swap_dyn_out (hash_table->dynobj, &dyn, newcontents + s->size);
 
-  s->size = newsize;
+  s->size = newsize; // Octets
   s->contents = newcontents;
 
   return TRUE;
@@ -3417,7 +3417,7 @@
 		continue;
 	    }
 
-	  sz = s->size;
+	  sz = s->size; // Octets
 	  msg = (char *) bfd_alloc (abfd, sz + 1);
 	  if (msg == NULL)
 	    goto error_return;
@@ -3436,7 +3436,7 @@
 	    {
 	      /* Clobber the section size so that the warning does
 		 not get copied into the output file.  */
-	      s->size = 0;
+	      s->size = 0; // Octets
 
 	      /* Also set SEC_EXCLUDE, so that symbols defined in
 		 the warning section don't get copied to the output.  */
@@ -3829,7 +3829,7 @@
 
       flags = BSF_NO_FLAGS;
       sec = NULL;
-      value = isym->st_value;
+      value = isym->st_value; // Bytes
       common = bed->common_definition (isym);
 
       bind = ELF_ST_BIND (isym->st_info);
@@ -3869,7 +3869,7 @@
 	  sec = bfd_com_section_ptr;
 	  /* What ELF calls the size we call the value.  What ELF
 	     calls the value we call the alignment.  */
-	  value = isym->st_size;
+	  value = isym->st_size; // Bytes, not octets
 	}
       else
 	{
@@ -3884,7 +3884,7 @@
 	      isym->st_shndx = SHN_UNDEF;
 	    }
 	  else if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
-	    value -= sec->vma;
+	    value -= sec->vma; // Bytes
 	}
 
       name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
@@ -5946,17 +5946,17 @@
 	  const char *name;
 
 	  cdefs = 0;
-	  size = 0;
+	  size = 0; // Octets
 
 	  /* Make space for the base version.  */
-	  size += sizeof (Elf_External_Verdef);
-	  size += sizeof (Elf_External_Verdaux);
+	  size += sizeof (Elf_External_Verdef); // Octets
+	  size += sizeof (Elf_External_Verdaux); // Octets
 	  ++cdefs;
 
 	  /* Make space for the default version.  */
 	  if (info->create_default_symver)
 	    {
-	      size += sizeof (Elf_External_Verdef);
+	      size += sizeof (Elf_External_Verdef); // Octets
 	      ++cdefs;
 	    }
 
@@ -5976,7 +5976,7 @@
 		size += sizeof (Elf_External_Verdaux);
 	    }
 
-	  s->size = size;
+	  s->size = size; // Octets
 	  s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
 	  if (s->contents == NULL && s->size != 0)
 	    return FALSE;
@@ -6210,7 +6210,7 @@
 	    bfd_byte *p;
 
 	    /* Build the version dependency section.  */
-	    size = 0;
+	    size = 0; // Octets
 	    crefs = 0;
 	    for (t = elf_tdata (output_bfd)->verref;
 		 t != NULL;
@@ -6218,13 +6218,13 @@
 	      {
 		Elf_Internal_Vernaux *a;
 
-		size += sizeof (Elf_External_Verneed);
+		size += sizeof (Elf_External_Verneed); // Octets
 		++crefs;
 		for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
 		  size += sizeof (Elf_External_Vernaux);
 	      }
 
-	    s->size = size;
+	    s->size = size; // Octets, not bytes
 	    s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
 	    if (s->contents == NULL)
 	      return FALSE;
@@ -6460,7 +6460,7 @@
 	  s = bfd_get_linker_section (dynobj, ".hash");
 	  BFD_ASSERT (s != NULL);
 	  hash_entry_size = elf_section_data (s)->this_hdr.sh_entsize;
-	  s->size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
+	  s->size = ((2 + bucketcount + dynsymcount) * hash_entry_size);//octets
 	  s->contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
 	  if (s->contents == NULL)
 	    return FALSE;
@@ -6519,7 +6519,7 @@
 	      /* Empty .gnu.hash section is special.  */
 	      BFD_ASSERT (cinfo.min_dynindx == -1);
 	      free (cinfo.hashcodes);
-	      s->size = 5 * 4 + bed->s->arch_size / 8;
+	      s->size = 5 * 4 + bed->s->arch_size / 8; // In octets
 	      contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
 	      if (contents == NULL)
 		return FALSE;
@@ -7478,7 +7478,7 @@
 		  Elf_Internal_Sym *isymbuf,
 		  size_t locsymcount,
 		  size_t symidx,
-		  bfd_vma val)
+		  bfd_vma val) // in bytes
 {
   struct elf_link_hash_entry **sym_hashes;
   struct elf_link_hash_entry *h;
@@ -7549,7 +7549,7 @@
 	  asection *sec = flinfo->sections [i];
 
 	  *result = _bfd_elf_rel_local_sym (input_bfd, sym, &sec, 0);
-	  *result += sec->output_offset + sec->output_section->vma;
+	  *result += sec->output_offset + sec->output_section->vma; // bytes
 #ifdef DEBUG
 	  printf ("Found symbol with value %8.8lx\n",
 		  (unsigned long) *result);
@@ -7591,7 +7591,7 @@
   for (curr = sections; curr; curr = curr->next)
     if (strcmp (curr->name, name) == 0)
       {
-	*result = curr->vma;
+	*result = curr->vma; // Value returned is in bytes
 	return TRUE;
       }
 
@@ -7606,6 +7606,10 @@
 	{
 	  if (strncmp (".end", name + len, 4) == 0)
 	    {
+              // TODO: Octets per byte -- needs to adjust the calling
+              // convention, though, so that the BFD in question is available
+              // or otherwise so that we know the number of octets per byte.
+	      // *result = curr->vma + curr->size / bfd_octets_per_byte(abfd);
 	      *result = curr->vma + curr->size;
 	      return TRUE;
 	    }
@@ -7919,8 +7923,8 @@
   else
     shift = (8 * wordsz) - (start + len);
 
-  /* FIXME: octets_per_byte.  */
-  x = get_value (wordsz, chunksz, input_bfd, contents + rel->r_offset);
+  x = get_value (wordsz, chunksz, input_bfd,
+		contents + rel->r_offset * bfd_octets_per_byte(input_bfd));
 
 #ifdef DEBUG
   printf ("Doing complex reloc: "
@@ -7953,7 +7957,8 @@
 	  (unsigned long) ((relocation & mask) << shift), (unsigned long) x);
 #endif
   /* FIXME: octets_per_byte.  */
-  put_value (wordsz, chunksz, input_bfd, x, contents + rel->r_offset);
+  put_value (wordsz, chunksz, input_bfd, x,
+		contents + rel->r_offset * bfd_octets_per_byte(input_bfd));
   return r;
 }
 
@@ -8248,7 +8253,7 @@
   size = 0;
   for (lo = dynamic_relocs->map_head.link_order; lo != NULL; lo = lo->next)
     if (lo->type == bfd_indirect_link_order)
-      size += lo->u.indirect.section->size;
+      size += lo->u.indirect.section->size;	// in octets
 
   if (size != dynamic_relocs->size)
     return 0;
@@ -8289,8 +8294,11 @@
 	  }
 	erel = o->contents;
 	erelend = o->contents + o->size;
-	/* FIXME: octets_per_byte.  */
-	p = sort + o->output_offset / ext_size * sort_elt;
+	// output_offset is in bytes, not octets
+	// ext_size is the size of the relocation (file octets)
+	// sort_elt is in octets
+	// sort and p are both pointers to octets
+	p = sort + o->output_offset * bfd_octets_per_byte(abfd) / ext_size * sort_elt;
 
 	while (erel < erelend)
 	  {
@@ -8334,8 +8342,11 @@
 
 	erel = o->contents;
 	erelend = o->contents + o->size;
-	/* FIXME: octets_per_byte.  */
-	p = sort + o->output_offset / ext_size * sort_elt;
+	// output_offset is in bytes, not octets
+	// ext_size is the size of the relocation (file octets)
+	// sort_elt is in octets
+	// sort and p are both pointers to octets
+	p = sort + o->output_offset * bfd_octets_per_byte(abfd) / ext_size * sort_elt;
 	while (erel < erelend)
 	  {
 	    struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
@@ -9215,7 +9226,7 @@
   asection *o;
   const struct elf_backend_data *bed;
   struct elf_link_hash_entry **sym_hashes;
-  bfd_size_type address_size;
+  bfd_size_type address_size; // Octets
   bfd_vma r_type_mask;
   int r_sym_shift;
   bfd_boolean have_file_sym = FALSE;
@@ -9392,15 +9403,15 @@
 	 we assume that they also have a reasonable value for
 	 output_section.  Any special sections must be set up to meet
 	 these requirements.  */
-      osym.st_value += isec->output_offset;
+      osym.st_value += isec->output_offset; // Bytes
       if (!flinfo->info->relocatable)
 	{
-	  osym.st_value += isec->output_section->vma;
+	  osym.st_value += isec->output_section->vma; // Bytes
 	  if (ELF_ST_TYPE (osym.st_info) == STT_TLS)
 	    {
 	      /* STT_TLS symbols are relative to PT_TLS segment base.  */
 	      BFD_ASSERT (elf_hash_table (flinfo->info)->tls_sec != NULL);
-	      osym.st_value -= elf_hash_table (flinfo->info)->tls_sec->vma;
+	      osym.st_value-=elf_hash_table (flinfo->info)->tls_sec->vma;//bytes
 	    }
 	}
 
@@ -9416,13 +9427,13 @@
     {
       r_type_mask = 0xff;
       r_sym_shift = 8;
-      address_size = 4;
+      address_size = 4; // Octets
     }
   else
     {
       r_type_mask = 0xffffffff;
       r_sym_shift = 32;
-      address_size = 8;
+      address_size = 8; // Octets
     }
 
   /* Relocate the contents of each section.  */
@@ -9485,7 +9496,7 @@
 		  if (sym.st_shndx == SHN_BAD)
 		    return FALSE;
 
-		  sym.st_value += o->output_offset;
+		  sym.st_value += o->output_offset; // Bytes
 
 		  indx = bfd_get_symcount (output_bfd);
 		  ret = elf_link_output_sym (flinfo, name, &sym, o, NULL);
@@ -9560,7 +9571,7 @@
 				 ".fini_array") == 0))
 	      && (o->name[6] == 0 || o->name[6] == '.'))
 	    {
-	      if (o->size != o->reloc_count * address_size)
+	      if (o->size != o->reloc_count * address_size) // Octets
 		{
 		  (*_bfd_error_handler)
 		    (_("error: %B: size of section %A is not "
@@ -9644,7 +9655,7 @@
 		  && !flinfo->info->relocatable)
 		{
 		  bfd_vma val;
-		  bfd_vma dot = (rel->r_offset
+		  bfd_vma dot = (rel->r_offset // bytes
 				 + o->output_offset + o->output_section->vma);
 #ifdef DEBUG
 		  printf ("Encountered a complex symbol!");
@@ -9655,7 +9666,7 @@
 			  r_symndx, sym_name);
 		  printf (" reloc : info %8.8lx, addr %8.8lx\n",
 			  (unsigned long) rel->r_info,
-			  (unsigned long) rel->r_offset);
+			  (unsigned long) rel->r_offset); // bytes
 #endif
 		  if (!eval_symbol (&val, &sym_name, input_bfd, flinfo, dot,
 				    isymbuf, locsymcount, s_type == STT_SRELC))
@@ -9761,9 +9772,9 @@
 			     * bed->s->int_rels_per_ext_rel);
 	      rel_hash_list = rel_hash;
 	      rela_hash_list = NULL;
-	      last_offset = o->output_offset;
+	      last_offset = o->output_offset;	// In bytes
 	      if (!flinfo->info->relocatable)
-		last_offset += o->output_section->vma;
+		last_offset += o->output_section->vma;	// In bytes
 	      for (next_erel = 0; irela < irelaend; irela++, next_erel++)
 		{
 		  unsigned long r_symndx;
@@ -9793,19 +9804,19 @@
 			 offset as the last reloc.  elf_eh_frame.c and
 			 bfd_elf_discard_info rely on reloc offsets
 			 being ordered.  */
-		      irela->r_offset = last_offset;
+		      irela->r_offset = last_offset; // in bytes
 		      irela->r_info = 0;
 		      irela->r_addend = 0;
 		      continue;
 		    }
 
-		  irela->r_offset += o->output_offset;
+		  irela->r_offset += o->output_offset; // Bytes
 
 		  /* Relocs in an executable have to be virtual addresses.  */
 		  if (!flinfo->info->relocatable)
-		    irela->r_offset += o->output_section->vma;
+		    irela->r_offset += o->output_section->vma; // Bytes
 
-		  last_offset = irela->r_offset;
+		  last_offset = irela->r_offset; // Bytes
 
 		  r_symndx = irela->r_info >> r_sym_shift;
 		  if (r_symndx == STN_UNDEF)
@@ -9875,7 +9886,7 @@
 			      && sec->kept_section->output_section != NULL)
 			    {
 			      osec = sec->kept_section->output_section;
-			      irela->r_addend -= osec->vma;
+			      irela->r_addend -= osec->vma; // Units are bytes
 			    }
 
 			  if (!bfd_is_abs_section (osec))
@@ -9883,10 +9894,10 @@
 			      r_symndx = osec->target_index;
 			      if (r_symndx == STN_UNDEF)
 				{
-				  irela->r_addend += osec->vma;
+				  irela->r_addend += osec->vma;//Units are bytes
 				  osec = _bfd_nearby_section (output_bfd, osec,
 							      osec->vma);
-				  irela->r_addend -= osec->vma;
+				  irela->r_addend -= osec->vma; // Bytes
 				  r_symndx = osec->target_index;
 				}
 			    }
@@ -9895,7 +9906,7 @@
 		      /* Adjust the addend according to where the
 			 section winds up in the output section.  */
 		      if (rela_normal)
-			irela->r_addend += sec->output_offset;
+			irela->r_addend += sec->output_offset; // Both are in bytes
 		    }
 		  else
 		    {
@@ -9929,10 +9940,10 @@
 			  if (sym.st_shndx == SHN_BAD)
 			    return FALSE;
 
-			  sym.st_value += sec->output_offset;
+			  sym.st_value += sec->output_offset; // Bytes
 			  if (!flinfo->info->relocatable)
 			    {
-			      sym.st_value += osec->vma;
+			      sym.st_value += osec->vma; // Bytes
 			      if (ELF_ST_TYPE (sym.st_info) == STT_TLS)
 				{
 				  /* STT_TLS symbols are relative to PT_TLS
@@ -10018,33 +10029,32 @@
 	  break;
 	default:
 	  {
-	    /* FIXME: octets_per_byte.  */
 	    if (! (o->flags & SEC_EXCLUDE))
 	      {
-		file_ptr offset = (file_ptr) o->output_offset;
-		bfd_size_type todo = o->size;
+		file_ptr offset_octets = (file_ptr) o->output_offset * bfd_octets_per_byte(output_bfd);
+		bfd_size_type todo_octets = o->size;
 		if ((o->flags & SEC_ELF_REVERSE_COPY))
 		  {
 		    /* Reverse-copy input section to output.  */
 		    do
 		      {
-			todo -= address_size;
+			todo_octets -= address_size;
 			if (! bfd_set_section_contents (output_bfd,
 							o->output_section,
-							contents + todo,
-							offset,
+							contents + todo_octets,
+							offset_octets,
 							address_size))
 			  return FALSE;
-			if (todo == 0)
+			if (todo_octets == 0)
 			  break;
-			offset += address_size;
+			offset_octets += address_size;
 		      }
 		    while (1);
 		  }
 		else if (! bfd_set_section_contents (output_bfd,
 						     o->output_section,
 						     contents,
-						     offset, todo))
+						     offset_octets, todo_octets))
 		  return FALSE;
 	      }
 	  }
@@ -10086,7 +10096,7 @@
       return FALSE;
     }
 
-  addend = link_order->u.reloc.p->addend;
+  addend = link_order->u.reloc.p->addend; // bytes, not octets
 
   if (esdo->rel.hdr)
     reldata = &esdo->rel;
@@ -10128,7 +10138,7 @@
 	  /* It seems that we ought to add the symbol value to the
 	     addend here, but in practice it has already been added
 	     because it was passed to constructor_callback.  */
-	  addend += section->output_section->vma + section->output_offset;
+	  addend += section->output_section->vma +section->output_offset;//bytes
 	}
       else if (h != NULL)
 	{
@@ -10187,7 +10197,9 @@
 	  break;
 	}
       ok = bfd_set_section_contents (output_bfd, output_section, buf,
-				     link_order->offset, size);
+				     link_order->offset
+					* bfd_octets_per_byte(output_bfd),
+				     size);
       free (buf);
       if (! ok)
 	return FALSE;
@@ -10196,13 +10208,13 @@
   /* The address of a reloc is relative to the section in a
      relocatable file, and is a virtual address in an executable
      file.  */
-  offset = link_order->offset;
+  offset = link_order->offset; // Bytes, not octets
   if (! info->relocatable)
-    offset += output_section->vma;
+    offset += output_section->vma; // Bytes, not octets
 
   for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
     {
-      irel[i].r_offset = offset;
+      irel[i].r_offset = offset; // Bytes, not octets
       irel[i].r_info = 0;
       irel[i].r_addend = 0;
     }
@@ -10220,7 +10232,7 @@
     }
   else
     {
-      irel[0].r_addend = addend;
+      irel[0].r_addend = addend;	// Bytes, not octets
       erel += reldata->count * bed->s->sizeof_rela;
       (*bed->s->swap_reloca_out) (output_bfd, irel, erel);
     }
@@ -10261,7 +10273,7 @@
   else
     {
       s = elf_shdrp[elfsec]->bfd_section;
-      return s->output_section->vma + s->output_offset;
+      return s->output_section->vma + s->output_offset; // Bytes, not octets
     }
 }
 
@@ -10364,15 +10376,14 @@
 	 compare_link_order);
 
   /* Change the offsets of the sections.  */
-  offset = 0;
+  offset = 0; // Octets
   for (n = 0; n < seen_linkorder; n++)
     {
       s = sections[n]->u.indirect.section;
-      offset &= ~(bfd_vma) 0 << s->alignment_power;
-      s->output_offset = offset;
-      sections[n]->offset = offset;
-      /* FIXME: octets_per_byte.  */
-      offset += sections[n]->size;
+      offset &= ~(bfd_vma) 0 << s->alignment_power;	// Octets
+      s->output_offset = offset / bfd_octets_per_byte(abfd); // into bytes
+      sections[n]->offset = offset;	// Octets again
+      offset += sections[n]->size;	// Octets
     }
 
   free (sections);
@@ -11409,10 +11420,10 @@
 	    continue;
 	  if (strcmp (o->name, ".dynstr") != 0)
 	    {
-	      /* FIXME: octets_per_byte.  */
 	      if (! bfd_set_section_contents (abfd, o->output_section,
 					      o->contents,
-					      (file_ptr) o->output_offset,
+					      (file_ptr) o->output_offset
+						* bfd_octets_per_byte(abfd),
 					      o->size))
 		goto error_return;
 	    }
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/hosts/zipbsd.h binutils-2.25/bfd/hosts/zipbsd.h
--- binutils-2.25-original/bfd/hosts/zipbsd.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/bfd/hosts/zipbsd.h	2016-02-04 21:13:23.750852163 -0500
@@ -0,0 +1,50 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Filename: 	tc-zip.h
+//
+// Project:	Zip CPU backend for GNU Binutils
+//
+// Purpose:	
+//
+// Creator:	Dan Gisselquist, Ph.D.
+//		Gisselquist Technology, LLC
+//
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (C) 2016, Gisselquist Technology, LLC
+//
+// This program is free software (firmware): you can redistribute it and/or
+// modify it under the terms of  the GNU General Public License as published
+// by the Free Software Foundation, either version 3 of the License, or (at
+// your option) any later version.
+//
+// This program is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this program.  (It's in the $(ROOT)/doc directory, run make with no
+// target there if the PDF file isn't present.)  If not, see
+// <http://www.gnu.org/licenses/> for a copy.
+//
+// License:	GPL, v3, as defined and found on www.gnu.org,
+//		http://www.gnu.org/licenses/gpl.html
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+#ifndef	_ZIPBSD_H
+#define	_ZIPBSD_H
+
+#include <machine/param.h>
+#include <machine/vmparam.h>
+
+#undef	ALIGN
+#define	HOST_PAGE_SIZE	NBPG
+#define	HOST_MACHINE_ARCH	bfd_arch_zip
+
+#define	HOST_TEXT_START_ADDR	USRTEXT
+#define	HOST_STACK_END_ADDR	USRSTACK
+#define	NO_CORE_COMMAND
+
+#endif /* _ZIPBSD_H */
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/libbfd.h binutils-2.25/bfd/libbfd.h
--- binutils-2.25-original/bfd/libbfd.h	2014-11-04 04:54:41.000000000 -0500
+++ binutils-2.25/bfd/libbfd.h	2016-04-19 07:41:48.395151746 -0400
@@ -2953,6 +2953,19 @@
   "BFD_RELOC_EPIPHANY_SIMM11",
   "BFD_RELOC_EPIPHANY_IMM11",
   "BFD_RELOC_EPIPHANY_IMM8",
+  "BFD_RELOC_ZIP_VALUE",
+  "BFD_RELOC_ZIP_OPB_IMM",
+  "BFD_RELOC_ZIP_OPB_OFFSET",
+  "BFD_RELOC_ZIP_OPB_PCREL",
+  "BFD_RELOC_ZIP_OPB_GOTREL",
+  "BFD_RELOC_ZIP_MOV_OFFSET",
+  "BFD_RELOC_ZIP_MOV_PCREL",
+  "BFD_RELOC_ZIP_MOV_GOTREL",
+  "BFD_RELOC_ZIP_LDI",
+  "BFD_RELOC_ZIP_LLO",
+  "BFD_RELOC_ZIP_LHI",
+  "BFD_RELOC_ZIP_BREV",
+  "BFD_RELOC_ZIP_ADDRESS",
  "@@overflow: BFD_RELOC_UNUSED@@",
 };
 #endif
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/Makefile.am binutils-2.25/bfd/Makefile.am
--- binutils-2.25-original/bfd/Makefile.am	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/bfd/Makefile.am	2016-02-04 21:12:06.487473383 -0500
@@ -166,7 +166,8 @@
 	cpu-xstormy16.lo \
 	cpu-xtensa.lo \
 	cpu-z80.lo \
-	cpu-z8k.lo
+	cpu-z8k.lo \
+	cpu-zip.lo
 
 ALL_MACHINES_CFILES = \
 	cpu-aarch64.c \
@@ -250,7 +251,8 @@
 	cpu-xstormy16.c \
 	cpu-xtensa.c \
 	cpu-z80.c \
-	cpu-z8k.c
+	cpu-z8k.c \
+	cpu-zip.c
 
 # The .o files needed by all of the 32 bit vectors that are configured into
 # target_vector in targets.c if configured with --enable-targets=all.
@@ -368,6 +370,7 @@
 	elf32-xgate.lo \
 	elf32-xstormy16.lo \
 	elf32-xtensa.lo \
+	elf32-zip.lo \
 	elf32.lo \
 	elflink.lo \
 	elfxx-sparc.lo \
@@ -555,6 +558,7 @@
 	elf32-xgate.c \
 	elf32-xstormy16.c \
 	elf32-xtensa.c \
+	elf32-zip.c \
 	elf32.c \
 	elflink.c \
 	elfxx-sparc.c \
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/Makefile.in binutils-2.25/bfd/Makefile.in
--- binutils-2.25-original/bfd/Makefile.in	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/bfd/Makefile.in	2016-02-04 21:12:06.487473383 -0500
@@ -467,7 +467,8 @@
 	cpu-xstormy16.lo \
 	cpu-xtensa.lo \
 	cpu-z80.lo \
-	cpu-z8k.lo
+	cpu-z8k.lo \
+	cpu-zip.lo 
 
 ALL_MACHINES_CFILES = \
 	cpu-aarch64.c \
@@ -551,7 +552,8 @@
 	cpu-xstormy16.c \
 	cpu-xtensa.c \
 	cpu-z80.c \
-	cpu-z8k.c
+	cpu-z8k.c \
+	cpu-zip.c
 
 
 # The .o files needed by all of the 32 bit vectors that are configured into
@@ -670,6 +672,7 @@
 	elf32-xgate.lo \
 	elf32-xstormy16.lo \
 	elf32-xtensa.lo \
+	elf32-zip.lo \
 	elf32.lo \
 	elflink.lo \
 	elfxx-sparc.lo \
@@ -857,6 +860,7 @@
 	elf32-xgate.c \
 	elf32-xstormy16.c \
 	elf32-xtensa.c \
+	elf32-zip.c \
 	elf32.c \
 	elflink.c \
 	elfxx-sparc.c \
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/merge.c binutils-2.25/bfd/merge.c
--- binutils-2.25-original/bfd/merge.c	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/bfd/merge.c	2016-03-26 21:00:07.454199674 -0400
@@ -794,8 +794,7 @@
   if (secinfo->first_str == NULL)
     return TRUE;
 
-  /* FIXME: octets_per_byte.  */
-  pos = sec->output_section->filepos + sec->output_offset;
+  pos = sec->output_section->filepos + sec->output_offset * bfd_octets_per_byte(output_bfd);
   if (bfd_seek (output_bfd, pos, SEEK_SET) != 0)
     return FALSE;
 
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/reloc.c binutils-2.25/bfd/reloc.c
--- binutils-2.25-original/bfd/reloc.c	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/bfd/reloc.c	2016-04-21 10:10:44.122704152 -0400
@@ -1362,7 +1362,7 @@
     }
 
   return _bfd_relocate_contents (howto, input_bfd, relocation,
-				 contents + address);
+				 contents + address * bfd_octets_per_byte(input_bfd));
 }
 
 /* Relocate a given location using a given value and howto.  */
@@ -7325,7 +7325,38 @@
   BFD_RELOC_EPIPHANY_IMM8
 ENUMDOC
   Adapteva EPIPHANY - 8 bit immediate for 16 bit mov instruction.
-
+ENUM
+  BFD_RELOC_ZIP_VALUE
+ENUMX
+  BFD_RELOC_ZIP_OPB_IMM
+ENUMX
+  BFD_RELOC_ZIP_OPB_OFFSET
+ENUMX
+  BFD_RELOC_ZIP_OPB_PCREL
+ENUMX
+  BFD_RELOC_ZIP_OPB_GOTREL
+ENUMX
+  BFD_RELOC_ZIP_MOV_OFFSET
+ENUMX
+  BFD_RELOC_ZIP_MOV_PCREL
+ENUMX
+  BFD_RELOC_ZIP_MOV_GOTREL
+ENUMX
+  BFD_RELOC_ZIP_LDI
+ENUMX
+  BFD_RELOC_ZIP_LLO
+ENUMX
+  BFD_RELOC_ZIP_LHI
+ENUMX
+  BFD_RELOC_ZIP_BREV
+ENUMDOC
+  ZIP CPU value (not address) relocations.
+ENUM
+  BFD_RELOC_ZIP_ADDRESS
+ENUMDOC
+  This is the same as the ZIP_VALUE relocation, save only that the value is
+  right shifted by two, since it is an address and Zip addresses increment
+  by one per word, not one per byte.
 
 ENDSENUM
   BFD_RELOC_UNUSED
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/syms.c binutils-2.25/bfd/syms.c
--- binutils-2.25-original/bfd/syms.c	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/bfd/syms.c	2016-02-21 19:49:49.593989776 -0500
@@ -1081,11 +1081,11 @@
 		  return FALSE;
 		}
 
-	      val = bfd_get_32 (abfd, info->stabs + r->address);
+	      val = bfd_get_32 (abfd, info->stabs + r->address * bfd_octets_per_byte(abfd));
 	      val &= r->howto->src_mask;
 	      sym = *r->sym_ptr_ptr;
 	      val += sym->value + sym->section->vma + r->addend;
-	      bfd_put_32 (abfd, (bfd_vma) val, info->stabs + r->address);
+	      bfd_put_32 (abfd, (bfd_vma) val, info->stabs + r->address * bfd_octets_per_byte(abfd));
 	    }
 	}
 
diff -Naur '--exclude=*.swp' binutils-2.25-original/bfd/targets.c binutils-2.25/bfd/targets.c
--- binutils-2.25-original/bfd/targets.c	2014-11-04 04:54:41.000000000 -0500
+++ binutils-2.25/bfd/targets.c	2016-02-04 21:12:06.491473352 -0500
@@ -892,6 +892,7 @@
 extern const bfd_target xtensa_elf32_le_vec;
 extern const bfd_target z80_coff_vec;
 extern const bfd_target z8k_coff_vec;
+extern const bfd_target zip_elf32_vec;
 
 /* These are always included.  */
 extern const bfd_target srec_vec;
@@ -1411,6 +1412,8 @@
 	&z80_coff_vec,
 
 	&z8k_coff_vec,
+
+	&zip_elf32_vec,
 #endif /* not SELECT_VECS */
 
 /* Always support S-records, for convenience.  */
diff -Naur '--exclude=*.swp' binutils-2.25-original/binutils/readelf.c binutils-2.25/binutils/readelf.c
--- binutils-2.25-original/binutils/readelf.c	2014-12-23 03:47:10.000000000 -0500
+++ binutils-2.25/binutils/readelf.c	2016-02-04 21:12:06.491473352 -0500
@@ -154,6 +154,7 @@
 #include "elf/xgate.h"
 #include "elf/xstormy16.h"
 #include "elf/xtensa.h"
+#include "elf/zip.h"
 
 #include "getopt.h"
 #include "libiberty.h"
@@ -744,6 +745,7 @@
     case EM_XTENSA_OLD:
     case EM_MICROBLAZE:
     case EM_MICROBLAZE_OLD:
+    case EM_ZIP:
       return TRUE;
 
     case EM_68HC05:
@@ -1409,6 +1411,10 @@
 	case EM_ALTERA_NIOS2:
 	  rtype = elf_nios2_reloc_type (type);
 	  break;
+
+	case EM_ZIP:
+	  rtype = elf_zip_reloc_type (type);
+	  break;
 	}
 
       if (rtype == NULL)
@@ -2178,6 +2184,7 @@
     case EM_TILEGX:		return "Tilera TILE-Gx multicore architecture family";
     case EM_CUDA:		return "NVIDIA CUDA architecture";
     case EM_XGATE:		return "Motorola XGATE embedded processor";
+    case EM_ZIP:		return "Gisselquist Technology Zip CPU";
     default:
       snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
       return buff;
@@ -10836,6 +10843,9 @@
     case EM_XTENSA_OLD:
     case EM_XTENSA:
       return reloc_type == 1; /* R_XTENSA_32.  */
+    case EM_ZIP:
+#warning "I have no idea what this does"
+      return reloc_type == 1; /* R_XTENSA_32.  */
     default:
       error (_("Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n"),
 	     elf_header.e_machine);
@@ -10896,6 +10906,9 @@
     case EM_XTENSA_OLD:
     case EM_XTENSA:
       return reloc_type == 14; /* R_XTENSA_32_PCREL.  */
+    case EM_ZIP:
+#warning "This is probably a bug--I have no idea what I am doing"
+      return reloc_type == 1; /* R_ZIP_VALUE  */
     default:
       /* Do not abort or issue an error message here.  Not all targets use
 	 pc-relative 32-bit relocs in their DWARF debug information and we
@@ -11092,6 +11105,7 @@
     case EM_ALTERA_NIOS2: /* R_NIOS2_NONE.  */
     case EM_NIOS32:  /* R_NIOS_NONE.  */
     case EM_OR1K:    /* R_OR1K_NONE. */
+    case EM_ZIP:    /* R_ZIP_NONE. */
       return reloc_type == 0;
     case EM_AARCH64:
       return reloc_type == 0 || reloc_type == 256;
diff -Naur '--exclude=*.swp' binutils-2.25-original/config.sub binutils-2.25/config.sub
--- binutils-2.25-original/config.sub	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/config.sub	2016-02-04 21:12:13.283418736 -0500
@@ -314,7 +314,7 @@
 	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
-	| z8k | z80)
+	| z8k | z80 | zip)
 		basic_machine=$basic_machine-unknown
 		;;
 	c54x)
@@ -440,7 +440,7 @@
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
 	| xstormy16-* | xtensa*-* \
 	| ymp-* \
-	| z8k-* | z80-*)
+	| z8k-* | z80-* | zip-*)
 		;;
 	# Recognize the basic CPU types without company name, with glob match.
 	xtensa*)
@@ -1249,6 +1249,10 @@
 		basic_machine=z80-unknown
 		os=-sim
 		;;
+	zip*)
+		basic_machine=zip
+		os=-elf
+		;;
 	none)
 		basic_machine=none-none
 		os=-none
diff -Naur '--exclude=*.swp' binutils-2.25-original/configure.ac binutils-2.25/configure.ac
--- binutils-2.25-original/configure.ac	2014-12-23 09:38:42.000000000 -0500
+++ binutils-2.25/configure.ac	2016-02-04 21:12:13.303418575 -0500
@@ -1165,6 +1165,9 @@
   vax-*-*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
+  zip*)
+    noconfigdirs="$noconfigdirs ${libgcj} gdb sim gprof"
+    ;;
 esac
 
 # If we aren't building newlib, then don't build libgloss, since libgloss
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/app.c binutils-2.25/gas/app.c
--- binutils-2.25-original/gas/app.c	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/gas/app.c	2016-02-18 20:03:11.233908743 -0500
@@ -468,7 +468,7 @@
 	 next output character in the appropriate state.  */
       switch (state)
 	{
-	case -1:
+	case -1:	// Need to copy from out_string, not input file
 	  ch = *out_string++;
 	  if (*out_string == '\0')
 	    {
@@ -478,7 +478,7 @@
 	  PUT (ch);
 	  continue;
 
-	case -2:
+	case -2:	// While in slash-star, star-slash comment
 	  for (;;)
 	    {
 	      do
@@ -515,7 +515,7 @@
 	  UNGET (' ');
 	  continue;
 
-	case 4:
+	case 4:	// After putting out .linefile, put out digits
 	  ch = GET ();
 	  if (ch == EOF)
 	    goto fromeof;
@@ -529,7 +529,7 @@
 		{
 		  quotechar = ch;
 		  state = 5;
-		  old_state = 3;
+		  old_state = 3;	// But ... the old state was 4 ... ??
 		  PUT (ch);
 		}
 	      else
@@ -542,7 +542,7 @@
 	    }
 	  continue;
 
-	case 5:
+	case 5:	// Parse a string
 	  /* We are going to copy everything up to a quote character,
 	     with special handling for a backslash.  We try to
 	     optimize the copying in the simple case without using the
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/config/tc-zip.c binutils-2.25/gas/config/tc-zip.c
--- binutils-2.25-original/gas/config/tc-zip.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/gas/config/tc-zip.c	2016-04-20 18:52:24.189215496 -0400
@@ -0,0 +1,2317 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Filename: 	tc-zip.c
+//
+// Project:	Zip CPU backend for GNU Binutils
+//
+// Purpose:	
+//
+// Creator:	Dan Gisselquist, Ph.D.
+//		Gisselquist Technology, LLC
+//
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (C) 2016, Gisselquist Technology, LLC
+//
+// This program is free software (firmware): you can redistribute it and/or
+// modify it under the terms of  the GNU General Public License as published
+// by the Free Software Foundation, either version 3 of the License, or (at
+// your option) any later version.
+//
+// This program is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this program.  (It's in the $(ROOT)/doc directory, run make with no
+// target there if the PDF file isn't present.)  If not, see
+// <http://www.gnu.org/licenses/> for a copy.
+//
+// License:	GPL, v3, as defined and found on www.gnu.org,
+//		http://www.gnu.org/licenses/gpl.html
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+#include "as.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "frags.h"
+#include "struc-symbol.h"
+#include "symbols.h"
+#include "config/tc-zip.h"
+#include "elf/zip.h"
+
+// #define	ZIP_DEBUG
+
+const	char	comment_chars[] = ";#";
+const	char	line_comment_chars[] = ";#";
+// Characters which separate lines (newline need to be listed)
+const	char	line_separator_chars[] = "";
+
+// Characters defining floating point numbers, such as 0f<floatingpt#>
+const	char	FLT_CHARS[] = "fFrR";
+
+// Characters that may be used for an exponent in floating point numbers
+const	char	EXP_CHARS[] = "eE";
+
+static int	vliw_mergable = 0; // tc_check_label, tc_frob_label
+static int	zip_param_got = 0, zip_param_vliw = 0;
+
+void	md_begin(void) {
+	vliw_mergable = 0;
+	//
+	// While the following alignment lines may seem reasonable, the
+	// alignment is done in the bfd in bytes, not octets, so it just adds
+	// useless and unnecessary data to the file.
+	//
+	// record_alignment(text_section, 2);
+	// record_alignment(data_section, 2);
+	//
+	lex_type['('] = lex_type['A'];
+}
+
+void	md_end(void) { }
+
+int	zip_address_bytes(void) { return 4; }
+void	zip_cons_align(int s ATTRIBUTE_UNUSED) {
+	// printf("CONS-ALIGN\n");
+
+	// Unlike the section alignment, *this* alignment is done in host
+	// bytes, which are (must be) octets.  Therefore, we align any
+	// data structure to every four octets.
+	//
+	frag_align(2, // Desired alignment is 2^this number
+		0, // Fill character
+		3); // Maximum number of characters to emit to get alignment
+}
+
+const	pseudo_typeS	md_pseudo_table[] = 
+{
+	{ "ascii",   stringer, 32+0},
+	{ "asciz",   stringer, 32+1},
+	{ "string",  stringer, 32+1},
+	{ "string8", stringer, 32+1},
+	{ "string16",stringer, 32+1},
+	// Since our smallest data structure is 4 words, .byte, .hword, .short,
+	// .word, .dc.a, .dc.b, and .dc.w directives all yield the same sized
+	// word: 4 octets (1 target byte, 4 host bytes)
+	{ "byte", cons, 4},
+	{ "hword",cons, 4},
+	{ "short",cons, 4},
+	{ "word", cons, 4},
+	{ "dc",   cons, 4},
+	{ "dc.a", cons, 4},
+	{ "dc.b", cons, 4},
+	{ "dc.w", cons, 4},
+	// The same is true for padding space(s)
+	{ "dcb",  s_space, 4},
+	{ "dcb.b",s_space, 4},
+	{ "dcb.w",s_space, 4},
+	{ "ds",   s_space, 4},
+	{ "ds.b", s_space, 4},
+	{ "ds.w", s_space, 4},
+	// { "p2align",  s_align_ptwo, -4},
+	// { "p2alignw", s_align_ptwo, -4},
+	// { "p2alignl", s_align_ptwo, -4},
+	{ NULL, NULL, 0 }
+};
+
+#define	ZIP_CC_SLEEP	0x010
+#define	ZIP_CC_GIE	0x020
+
+#define	NOOP_OPCODE	0x76000000
+
+typedef  struct {
+	bfd_reloc_code_real_type	r_type;
+	symbolS				*r_sym;
+	int				r_pcrel;
+	long				r_fr_offset;
+	fixS				*r_fix;
+	// Could also be char *name and bfd_reloc_code_real_type
+} ZIPRELOC;
+
+// In case the instruction
+#define	ZIP_MAX_NAUX	3 // Number of auxilliary instruction codes used
+typedef	struct {
+	int		i_naux;
+	unsigned	i_code,	// The actual machine language instruction
+			i_aux[ZIP_MAX_NAUX];
+	ZIP_OPCODE	i_op;
+	ZIP_CONDITION	i_cnd;
+	ZIP_REG		i_areg;	// = ZIP_RNONE for no register
+	ZIP_REG		i_breg;
+	int		i_imm;
+	ZIPRELOC	*i_rp;
+} ZIPIS;
+
+static ZIPIS *
+zip_copy_insn(const ZIPIS *old) {
+	ZIPIS *nw = (ZIPIS *)xmalloc(sizeof(ZIPIS));
+
+	memcpy((char *)nw, (char *)old, sizeof(ZIPIS));
+
+	return nw;
+}
+
+static unsigned int
+zip_brev(unsigned int v) {
+	unsigned r=0, b;
+
+	for(b=0; b<32; b++, v>>=1)
+		r = (r<<1)|(v&1);
+
+	return r;
+}
+
+/*
+ * Option processing
+ *
+ * While not yet implemented, we do have a need for multiple options.  These
+ * include:
+ *
+ *	(not yet supported)
+ *	-got	Use a global offset table to place unknown jump locations into.
+ *
+ *	(not yet supported)
+ *	-relax	Implement only relaxed instructions.  This implies that all
+ *		branches fit within 18-bits of the current PC, or equivalently
+ *		that all of the code fits within 1MB.  
+ *
+ *	(not yet supported)
+ *	-no-relax	Don't relax any instructions.  That means that all
+ *		branches will be implemented as LOD (PC),PC ; .int #Address
+ *		and all conditional branches as LOD 1(PC),PC; BRA 1; .int #addr.
+ *		This also implies LDI's of unknown values will always be
+ *		converted to LDILO/LDIHI pairs and never converted back to
+ *		LDI's--even when the final value is known.
+ *
+ *	-vliw	Attempt to compress instructions into the VLIW instruction
+ *		set.
+ *
+ *	(Something for stating the starting address of the routine in memory...)
+ *
+ *	Other (not yet supported) long options
+ *
+ *	-nopipe	Attempts to use a lock instruction will result in an error.
+ *	-nomul	Attempts to use multiply instructions will result in an error.
+ *	-nodiv	Attempts to use divide instructions will result in an error.
+ *	-nofpu	Attempts to use floating point unit insn will cause an error.
+ *	
+ *
+ */
+#define	OPTION_VLIW	(OPTION_MD_BASE+1)
+#define	OPTION_GOT	(OPTION_MD_BASE+2)
+
+const char	*md_shortopts = "";
+struct	option	md_longopts[] =
+{
+	{ "vliw", no_argument, NULL, OPTION_VLIW },
+	{ "got",  no_argument, NULL, OPTION_GOT },
+	{ NULL, no_argument, NULL, 0}
+};
+size_t	md_longopts_size = sizeof(md_longopts);
+
+/* We have no target specific options yet, so these next two fucntions are
+ * are empty.
+ */
+int
+md_parse_option(int c, char *arg ATTRIBUTE_UNUSED)
+{
+	// printf("Option %d, %s\n", c, (arg)?arg : "(Null)");
+	if (c==0)
+		return 1;
+	switch(c) {
+		case 0: return 1;
+		case OPTION_VLIW: zip_param_vliw = 1; return 1; break;
+		case OPTION_GOT : zip_param_got  = 1; return 1; break;
+		default: break;
+	}
+	return 0;
+}
+
+void
+md_show_usage(FILE *stream ATTRIBUTE_UNUSED)
+{
+	fprintf(stream, _("Zip CPU options:\n"));
+	fprintf(stream, _("\n"
+"-vliw\t\tAttempt to compress instructions into two instructions per word.\n"));
+	//fprintf(stream, _(
+// "-got\t\tGenerate position independent code by referencing all symbols\n"
+// "\t\tthrough a Global Offset Table.\n"));
+}
+
+
+symbolS *
+md_undefined_symbol(char *name ATTRIBUTE_UNUSED)
+{
+//#warning "This is where other architectures check for any GOT references"
+	return NULL;
+}
+
+void
+md_operand(expressionS *op ATTRIBUTE_UNUSED)
+{
+	/* Empty for now -- what is this for? */
+}
+
+#ifdef	ZIP_DEBUG
+static void
+zip_dump_sym(symbolS *sym)
+{
+	if (!sym) {
+		printf("SYM(NULL)");
+	} else {
+		printf("SYM(%s) %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s - 0x%08x\n",
+			S_GET_NAME(sym),
+			(S_IS_LOCAL(sym))?"Local ":"",
+			(S_IS_DEFINED(sym))?"Defined ":"",
+			(S_IS_EXTERNAL(sym))?"extern ":"",
+			(S_IS_FUNCTION(sym))?"(func) ":"",
+			(S_IS_WEAK(sym))?"Weak ":"",
+			(S_IS_WEAKREFD(sym))?"(Weak Ref-D) ":"",
+			(S_IS_WEAKREFR(sym))?"(Weak Refr) ":"",
+			(S_IS_DEBUG(sym))?"DEBUG ":"",
+			(S_IS_VOLATILE(sym))?"Volatile ":"",
+			(S_IS_FORWARD_REF(sym))?"Fwd Ref ":"",
+			(S_IS_COMMON(sym))?"Common ":"",
+			(S_GET_SEGMENT(sym)==absolute_section)?"AbsoluteS ":"",
+			(S_GET_SEGMENT(sym)==expr_section)?"ExpressionS ":"",
+			(S_GET_SEGMENT(sym)==reg_section)?"RegisterS ":"",
+			(S_GET_SEGMENT(sym)==undefined_section)?"UndefinedS ":"",
+			(symbol_resolved_p(sym))?"Resolved ":"",
+			(unsigned)S_GET_VALUE(sym));
+	}
+}
+
+static void
+zip_dump_insn(ZIPIS *insn) {
+	printf("INSN:DUMP ");
+	switch(insn->i_op) {
+		case ZIPO_SUB:   printf("%7s", "SUB"); break;
+		case ZIPO_AND:   printf("%7s", "AND"); break;
+		case ZIPO_ADD:   printf("%7s", "ADD"); break;
+		case ZIPO_OR:    printf("%7s", "OR"); break;
+		case ZIPO_XOR:   printf("%7s", "XOR"); break;
+		case ZIPO_LSR:   printf("%7s", "LSR"); break;
+		case ZIPO_LSL:   printf("%7s", "LSL"); break;
+		case ZIPO_ASR:   printf("%7s", "ASR"); break;
+		case ZIPO_LDI:   printf("%7s", "LDI"); break;
+#ifndef	LONG_MPY
+		case ZIPO_LDIHI: printf("%7s", "LDIHI"); break;
+#endif
+		case ZIPO_LDILO: printf("%7s", "LDILO"); break;
+		case ZIPO_MPYU: printf("%7s", "MPYU"); break;
+		case ZIPO_MPYS: printf("%7s", "MPYS"); break;
+		case ZIPO_BREV: printf("%7s", "BREV"); break;
+		case ZIPO_POPC: printf("%7s", "POPC"); break;
+		case ZIPO_ROL:  printf("%7s", "ROL"); break;
+		case ZIPO_MOV:  printf("%7s", "MOV"); break;
+		case ZIPO_CMP:  printf("%7s", "CMP"); break;
+		case ZIPO_TST:  printf("%7s", "TST"); break;
+		case ZIPO_LOD:  printf("%7s", "LOD"); break;
+		case ZIPO_STO:  printf("%7s", "STO"); break;
+		case ZIPO_DIVU: printf("%7s", "DIVU"); break;
+		case ZIPO_DIVS: printf("%7s", "DIVS"); break;
+		case ZIPO_FPADD: printf("%7s", "FPADD"); break;
+		case ZIPO_FPSUB: printf("%7s", "FPSUB"); break;
+		//
+		case ZIPO_NOOP: printf("%7s", "NOOP"); break;
+		case ZIPO_BREAK: printf("%7s", "BREAK"); break;
+		case ZIPO_LOCK: printf("%7s", "LOCK"); break;
+		case ZIPO_TRAP: printf("%7s", "TRAP"); break;
+		case ZIPO_CLR:  printf("%7s", "CLR"); break;
+		case ZIPO_CLRF: printf("%7s", "CLRF"); break;
+		case ZIPO_HALT: printf("%7s", "HALT"); break;
+		case ZIPO_WAIT: printf("%7s", "WAIT"); break;
+		case ZIPO_RTU:  printf("%7s", "RTU"); break;
+		case ZIPO_BRA:  printf("%7s", "BRA"); break;
+		case ZIPO_BUSY: printf("%7s", "BUSY"); break;
+		case ZIPO_JMP:  printf("%7s", "JMP"); break;
+		case ZIPO_NOT:  printf("%7s", "NOT"); break;
+		case ZIPO_NEG:  printf("%7s", "NEG"); break;
+		default:
+			printf("%d", insn->i_op); break;
+	}
+	switch(insn->i_cnd) {
+		case ZIPC_LT: printf("%-3s", ".LT"); break;
+		case ZIPC_GE: printf("%-3s", ".GE"); break;
+		case ZIPC_GT: printf("%-3s", ".GT"); break;
+		case ZIPC_NZ: printf("%-3s", ".NE"); break;
+		case ZIPC_Z: printf("%-3s", ".Z"); break;
+		case ZIPC_V: printf("%-3s", ".V"); break;
+		case ZIPC_C: printf("%-3s", ".C"); break;
+		case ZIPC_ALWAYS:
+		default:
+			break;
+	} printf(" %d", (int)insn->i_cnd);
+
+	printf("\n\tAREG = %d\n\tB = ", insn->i_areg);
+	if (insn->i_rp) {
+		if (insn->i_imm != 0)
+			printf("$%d + ", insn->i_imm);
+		printf("%s ", (insn->i_rp->r_sym) ?
+			S_GET_NAME(insn->i_rp->r_sym) : "(null)");
+	} else
+		printf("%d[%08x] (no sym)", insn->i_imm, insn->i_imm);
+	if (insn->i_breg != ZIP_RNONE)
+		printf("+ R%d", insn->i_breg);
+	printf("\n");
+	if (insn->i_rp)
+		printf("\t@%ld\n", insn->i_rp->r_fr_offset);
+	printf("\tINSN:CODE %08x", insn->i_code);
+	{
+		int	i;
+		for(i=0; (i<insn->i_naux)&&(i<ZIP_MAX_NAUX); i++)
+			printf(":%08x", insn->i_aux[i]);
+	}
+	printf("\n\tDUMPED\n");
+}
+#endif
+
+
+static const char *zip_skip_white_spaces(const char *str) {
+	if (!str)
+		return NULL;
+	while((*str)&&(isspace(*str)))
+		str++;
+	return str;
+}
+
+static const char *zip_parse_reg(const char *str, ZIP_REG *regid) {
+	const char *ustr = str;
+	int	userreg = 0;
+
+	ustr = zip_skip_white_spaces(str);
+
+	if ((ustr[0] == 'u')||(ustr[0] == 'U')) {
+		ustr = str+1;
+		userreg = 0x10;
+	}
+	
+	if (strcasecmp(ustr, "GBL")==0) {
+		*regid = userreg + 11;
+		ustr += 3;
+	} else if (strcasecmp(ustr, "FP")==0) {
+		*regid = userreg + 12;
+		ustr += 2;
+	} else if (strcasecmp(ustr, "SP")==0) {
+		*regid = userreg + 13;
+		ustr += 2;
+	} else if (strcasecmp(ustr, "CC")==0) {
+		*regid = userreg + 14;
+		ustr += 2;
+	} else if (strcasecmp(ustr, "PC")==0) {
+		*regid = userreg + 15;
+		ustr += 2;
+	} else if (('r' == tolower(ustr[0]))
+			&&(isdigit(ustr[1]))
+			&&((!isdigit(ustr[2]))
+				||(!isdigit(ustr[3])))) {
+		*regid = atoi(ustr+1);
+		if ((*regid > 15)||(*regid < 0))
+			return "Register does not exist";
+		*regid += userreg;
+
+		if (!isdigit(ustr[2]))
+			ustr+=2;
+		else
+			ustr+=3;
+	} else {
+		*regid = ZIP_RNONE;
+		return "Unknown register";
+	}
+
+	// Registers names are terminated by something other than letters
+	// and numbers.  Things like ')', ',', or '\0' should terminate a 
+	// register.  Here, we only double check that the register is not
+	// terminated by another letter or a number.
+	if ((*ustr)&&((isalpha(*ustr))||(isdigit(*ustr))))
+		return "Unrecognized register";
+
+	return NULL;
+}
+
+// Parse a 'B' operand
+static const char *
+zip_parse_bop(const char *bop, ZIPIS *insn) {
+	// There are a couple forms for what we can expect in a B operand:
+	//	The first three require no relocations ...
+	//		1. A simple number
+	//		2. Number + Register
+	//		3. Number(Register)
+	//		4. Register by itself
+	//		Good form is to replace this number with the possibility
+	//		of a constant expression ...  The number may be any of
+	//		[+-](0[xX][0-9a-fA-F]+|(0[0-7]+)|(0-9)+)
+	//	The next three may require a relocation
+	//		4. Label + Register
+	//		5. Label(Register)
+	//		6. Label (Register is implied: PC, if moving or jumping
+	//			to the PC, or GBL if loading a value or if
+	//			the offset ends up being unknown)
+	//		Good form allows an expression instead of a label,
+	//		that can be evaluated at ... sometime.
+	//
+	// We will support:
+	//	(Number|Label)?( "("Register")" | "+"Register )
+	//
+	char	lbl[strlen(bop)+5], *lblp = lbl;
+	const char	*ptr;
+	int	sgn = 0;
+	insn->i_imm = 0;
+	*lblp = '\0';
+
+	// printf("RAW-OP-B: %s %s\n", bop, (insn->i_rp)?"(i_rp != NULL)":"");
+
+	// Do we start with a number?
+	{
+		ptr = zip_skip_white_spaces(bop);
+		if ('$' == *ptr)
+			ptr = zip_skip_white_spaces(ptr+1);
+
+		if ('+' == *ptr)
+			ptr++;
+		else if ('-' == *ptr) {
+			sgn = 1;
+			ptr++;
+		}
+
+		if ('$' == *ptr)
+			ptr = zip_skip_white_spaces(ptr+1);
+		ptr = zip_skip_white_spaces(ptr);
+		if ('$' == *ptr)
+			ptr = zip_skip_white_spaces(ptr+1);
+
+		if ((*ptr)&&(isdigit(*ptr))) {
+			char *end = (char *)ptr;
+			unsigned long v = strtoul(ptr, &end, 0);
+			// We start with a number
+			if (sgn)
+				insn->i_imm = (int)(-v);
+			else
+				insn->i_imm = (int)(v);
+			ptr = (const char *)end;
+		} else if ((*ptr)&&(
+				(isalpha(*ptr))
+				||('*'==*ptr)
+				||('.'==*ptr)
+				||('_'==*ptr))) {
+			// We start with an identifier
+			// printf("OP-B ( \'%s\' ) starts with an identifier (%c)\n",
+				// bop, *ptr);
+
+			// Skip the compiler inserted prefix
+			if ('*' == *ptr)
+				ptr++;
+			while((*ptr)&&(
+					(isalpha(*ptr))
+					||(isdigit(*ptr))
+					||('_' == *ptr)
+					||('$' == *ptr)
+					||('.' == *ptr)))
+				*lblp++ = *ptr++;
+			*lblp = '\0';
+			// printf("LBL was %s\n", lbl);
+
+			// This could still be a register ... can't tell yet
+			if (sgn)
+				return "ERR: Not expecting a signed label!";
+
+			ptr = zip_skip_white_spaces(ptr);
+			if ((*ptr)&&((*ptr == '+')||(*ptr == '-'))&&(isdigit(ptr[1]))) {
+				ptr++;
+				char *end = (char *)ptr;
+				unsigned long v = strtoul(ptr, &end, 0);
+				// We start with a number
+				insn->i_imm += (int)(v);
+				ptr = (const char *)end;
+			}
+		}
+	}
+
+	ptr = zip_skip_white_spaces(ptr);
+
+	const	char *err = NULL;
+
+	if ((*ptr)&&(*ptr == '(')) {
+		// Form #3: Number(register)
+		char *end = strchr(ptr+1, ')');
+		if (NULL == end)
+			return "Un-matched \'(\', cannot find \')\'";
+		*end = '\0';
+		// printf("Looking for a register in %s\n", ptr+1);
+		err = zip_parse_reg(ptr+1, &insn->i_breg);
+		if (err)
+			return err;
+		// printf("Found a register, %s -> %d\n", ptr+1, insn->i_breg);
+	} else if ((*ptr)&&(*ptr == '+')) {
+		err = zip_parse_reg(ptr+1, &insn->i_breg);
+		if (err)
+			return err;
+	} else if ((*lbl)&&(NULL == zip_parse_reg(lbl, &insn->i_breg))) {
+		// Form: Register (only)
+		insn->i_imm = 0;
+		// printf("OP-B ( \'%s\' ) Had a register, %s -> %d\n", bop,
+			// lbl, insn->i_breg);
+		*lbl = '\0';
+	} else if (*lbl) {
+		// Form: Label or Number (only)
+		insn->i_breg = ZIP_RNONE;
+	}
+
+	if (*lbl) {
+		// printf("i_rp = %s\n", (insn->i_rp)?"(Null)":"not NULL");
+		symbolS *sym = symbol_find_or_make(lbl);
+		sym->sy_flags.sy_used = TRUE;
+		// segT seg = S_GET_SEGMENT(sym);
+#ifdef	ZIP_DEBUG
+		zip_dump_sym(sym);
+#endif
+		if (insn->i_breg == ZIP_PC) {
+			// New pc-relative relocation,
+			// ???
+			// symbolP = symbol_create(FAKE_LABEL_NAME,
+				// absolute_section, 0 &zero_address_frag);
+			// symbol_set_value_expression(symbolP, expressionP);
+			// resolve_symbol_value(symbolP);
+			insn->i_rp =(ZIPRELOC *)xmalloc(sizeof(ZIPRELOC));
+			insn->i_rp->r_sym = symbol_find_or_make(lbl);
+			insn->i_rp->r_pcrel = TRUE;
+			insn->i_rp->r_fr_offset = 0;
+			insn->i_rp->r_fix = NULL;
+			// symbol_make(name??)
+			// symbol_find_or_make(name)
+			// symbol_relc_make_sym
+			// symbol_relc_make_value
+			// symbol_find(name)
+			// symbol_find_noref(name, noref)
+			// symbol_find_exact(name)
+			// symbol_find_exact_noref(name, noref)
+			// symbol_find_or_make(name)
+			// symbol_make(name)
+			// symbol_new(name, seg, value, frag)
+			//	preferred call over symbol create
+			//	calls symbol_create internal
+			// symbol_create(name, segment, value, frag)
+			//
+			// local_symbol_make(name, section, value, frag)
+			// symbol_clone(sym, int)
+			// symbol_temp_new(seg, value, frag)
+			// symbol_temp_new_now(void)
+			// symbol_temp_make(void)
+			// colon(void)
+			//	Called when symbol: starts a line
+			//	Calls symbol_new(name, now_seg, frag_now_fix(),
+			//		frag_now);
+			//		symbol_table_insert(symbolP)
+			//
+			// expr_build_dot returns a symbol pointing to the 
+			//	current location ...
+			//
+			// Useful:
+			//	frag_now is current frag
+			//	S_SET_VALUE(symbolP, frag_now_fix()) ???
+			//	now_seg must be the current segment	
+			//	S_SET_SETGMENT(symbolP, now_seg);
+		} else if((zip_param_got)&&(insn->i_breg == ZIP_GBL)) {
+			// New GOT-relative relocation
+			insn->i_rp =(ZIPRELOC *)xmalloc(sizeof(ZIPRELOC));
+			insn->i_rp->r_sym = symbol_find_or_make(lbl);
+			insn->i_rp->r_pcrel = FALSE;
+			insn->i_rp->r_fr_offset = 0;
+			insn->i_rp->r_fix = NULL;
+		} else {
+			insn->i_rp =(ZIPRELOC *)xmalloc(sizeof(ZIPRELOC));
+			insn->i_rp->r_sym = symbol_find_or_make(lbl);
+			insn->i_rp->r_pcrel = FALSE;
+			insn->i_rp->r_fr_offset = 0;
+			insn->i_rp->r_fix = NULL;
+		}
+	}
+
+	/*
+	if ((*lbl)&&(insn->i_imm == 0))
+		printf("OPB-RESULT: %s", lbl);
+	else {
+		printf("OPB-RESULT: 0x%08x", insn->i_imm);
+		if (*lbl)
+			printf(" + %s", lbl);
+	}
+	if (insn->i_breg != ZIP_RNONE)
+		printf(" + R%d", insn->i_breg);
+	printf("\n");
+	*/
+
+	return 	err;
+}
+
+static	int	fits_within(int nbits, int value) {
+	// -2 fits_within two bits
+	// -1 fits_within two bits
+	//  1 fits_within two bits
+	//  2 does not
+	//
+	if (value > 0)
+		return (value <   (1l<<(nbits-1))) ? 1:0;
+	else
+		return (value >= -(1l<<(nbits-1))) ? 1:0;
+}
+
+static const char *zip_parse(const char *line, ZIPIS *insn) {
+	const char	*err = NULL, *opstr = NULL;
+	char	*alt;
+	int	i;
+	char *cndp = NULL;
+
+#ifdef	ZIP_DEBUG
+	printf("**** Parsing %s\n", line);
+#endif
+
+	insn->i_naux = 0;
+	insn->i_op   = ZIPO_NOOP;
+	insn->i_cnd  = ZIPC_ALWAYS;
+	insn->i_areg = ZIP_RNONE;
+	insn->i_breg = ZIP_RNONE;
+	insn->i_imm  = 0;
+	insn->i_rp   = NULL;
+	insn->i_code = NOOP_OPCODE;
+	for(i=0; i<ZIP_MAX_NAUX; i++)
+		insn->i_aux[i]  = NOOP_OPCODE;
+
+	// The opcode is given between whitespace and a period, or whitespace
+	// and whitespace
+	alt = strdup(zip_skip_white_spaces(line));
+	if ((*alt)=='(') {
+		// Instruction starts with condition codes-- a feature we
+		// needed to add in order to support GCC conditional execution
+		// macro
+		cndp = strtok(alt,") \t")+1;
+		if (!cndp)
+			return "Mismatched parenthesis--an attempt at a condition?";
+		if (strlen(cndp) > 2)
+			return "Invalid condition (too long)";
+
+		opstr = strtok(NULL, " \t");
+		if (!opstr)
+			return "Condition not followed by valid opcode";
+	} else {
+		opstr = strtok(alt, " \t"); // Get our opcode
+		if (!opstr) {
+			free(alt);
+			return "Invalid Instruction";
+		}
+	}
+
+	typedef enum	{
+		TWO_OP,		// Standard for most instructions
+		IMM_OP,		// Immediate operand only
+		BACKWARDS_TWO,	// Only used by STO REG,Off(REG)
+		NO_OP,		// Used by NOOP, BUSY, HALT, RTU,LOCK,BREAK,etc
+		ONE_OR_TWO_OP,	// Only used by TST
+		MAYBE_ONE_IMM,	// Only used by BREAK
+		ONE_REGISTER,	// Only used by CLR, CLRF, and NOT
+		OP_ADDRESS,	// Only used by BRA, BRA.C, and LINK
+		OP_B,		// Only used by TRAP and JMP
+		TWO_REGISTER,	// Only used by FP instructions
+		ILLEGAL_FORM	// Never used, for debugging only
+	} FORMTYPE;
+
+	FORMTYPE	insn_form = ILLEGAL_FORM; // Make sure we set this
+
+	// See if our token contains a '.' within it
+	//	GCC allows conditions beginning a line, as in ...
+	//		(CND)	Opcode	B,A
+	//	such a condition, if present, was detected above.
+	//
+	//	If not, we now look for a condition written in our original
+	//	format of ...
+	//		Opcode.CND B,A
+	//	and we look for it here.
+	//
+	if (!cndp) {
+		cndp = strchr(opstr, '.');
+		// If we found such a condition, we need to fix the opstr
+		// so that it no longer includes the condition.  Hence, let's
+		// place a NULL within the alt string and push our condition
+		// forward to the first non '.' value.
+		if (cndp)
+			*cndp++ = '\0';
+	}
+
+	if (strcasecmp(opstr, "SUB")==0) {
+		insn->i_op = ZIPO_SUB;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "AND")==0) {
+		insn->i_op = ZIPO_AND;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "ADD")==0) {
+		insn->i_op = ZIPO_ADD;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "OR")==0) {
+		insn->i_op = ZIPO_OR;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "XOR")==0) {
+		insn->i_op = ZIPO_XOR;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "LSR")==0) {
+		insn->i_op = ZIPO_LSR;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "LSL")==0) {
+		insn->i_op = ZIPO_LSL;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "ASR")==0) {
+		insn->i_op = ZIPO_ASR;
+		insn_form = TWO_OP;
+#ifdef	LONG_MPY
+	} else if (strcasecmp(opstr, "MPY")==0) {
+		insn_form = TWO_OP;
+		insn->i_op = ZIPO_MPY;
+#else
+	} else if((strcasecmp(opstr, "LDIHI")==0)
+			||(strcasecmp(opstr, "LHI")==0)) {
+		insn_form = TWO_OP;
+		insn->i_op = ZIPO_LDIHI;
+#endif
+	} else if((strcasecmp(opstr, "LDILO")==0)
+			||(strcasecmp(opstr, "LLO")==0)) {
+		insn->i_op = ZIPO_LDILO;
+		insn_form = TWO_OP;
+	// } else if (strcasecmp(opstr, "MPY")==0) {
+	//	insn->i_op = ZIPO_MPY;
+	//	insn_form = TWO_OP
+#ifdef	LONG_MPY
+	} else if (strcasecmp(opstr, "MPYUHI")==0) {	// MPUHI
+		insn->i_op = ZIPO_MPYUHI;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "MPYSHI")==0) {	// MPSHI
+		insn->i_op = ZIPO_MPYSHI;
+		insn_form = TWO_OP;
+#else
+	} else if (strcasecmp(opstr, "MPYU")==0) {	// MPUHI
+		insn->i_op = ZIPO_MPYU;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "MPYS")==0) {	// MPSHI
+		insn->i_op = ZIPO_MPYS;
+		insn_form = TWO_OP;
+#endif
+	} else if (strcasecmp(opstr, "BREV")==0) {
+		insn->i_op = ZIPO_BREV;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "POPC")==0) {
+		insn->i_op = ZIPO_POPC;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "ROL")==0) {
+		insn->i_op = ZIPO_ROL;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "MOV")==0) {
+		insn->i_op = ZIPO_MOV;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "CMP")==0) {
+		insn->i_op = ZIPO_CMP;
+		insn_form = TWO_OP;
+	} else if ((strcasecmp(opstr, "TST")==0)
+		||(strcasecmp(opstr, "TEST")==0)) {
+		insn->i_op = ZIPO_TST;
+		insn_form = ONE_OR_TWO_OP;
+	} else if (strcasecmp(opstr, "LOD")==0) {
+		insn->i_op = ZIPO_LOD;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "STO")==0) {
+		insn->i_op = ZIPO_STO;
+		insn_form = BACKWARDS_TWO;
+	} else if (strcasecmp(opstr, "DIVU")==0) {
+		insn->i_op = ZIPO_DIVU;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "DIVS")==0) {
+		insn->i_op = ZIPO_DIVS;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "LDI")==0) {
+		insn->i_op = ZIPO_LDI;
+		insn_form = IMM_OP;
+	} else if (strcasecmp(opstr, "FPADD")==0) {
+		insn->i_op = ZIPO_FPADD;
+		insn_form = TWO_REGISTER;
+	} else if (strcasecmp(opstr, "FPSUB")==0) {
+		insn->i_op = ZIPO_FPSUB;
+		insn_form = TWO_REGISTER;
+	} else if (strcasecmp(opstr, "FPMUL")==0) {
+		insn->i_op = ZIPO_FPMUL;
+		insn_form = TWO_REGISTER;
+	} else if (strcasecmp(opstr, "FPDIV")==0) {
+		insn->i_op = ZIPO_FPDIV;
+		insn_form = TWO_REGISTER;
+	} else if (strcasecmp(opstr, "FPCVT")==0) {
+		insn->i_op = ZIPO_FPCVT;
+		insn_form = TWO_OP;
+	} else if (strcasecmp(opstr, "FPINT")==0) {
+		insn->i_op = ZIPO_FPINT;
+		insn_form = TWO_REGISTER;
+	} else if ((strcasecmp(opstr, "NOP")==0)
+			||(strcasecmp(opstr, "NOOP")==0)) {
+		insn->i_op = ZIPO_NOOP;
+		insn_form = NO_OP;
+	} else if ((strcasecmp(opstr, "BRK")==0)
+		||(strcasecmp(opstr, "BREAK")==0)) {
+		insn->i_op = ZIPO_BREAK;
+		insn->i_imm= 0;
+		insn_form = MAYBE_ONE_IMM;
+	} else if (strcasecmp(opstr, "LOCK")==0) {
+		insn->i_op = ZIPO_LOCK;
+		insn_form = NO_OP;
+	// Now for some derived instructions
+	} else if (strcasecmp(opstr, "LINK")==0) {
+		insn->i_op = ZIPO_LINK;
+		insn_form = OP_ADDRESS;
+	} else if (strcasecmp(opstr, "TRAP")==0) {
+		insn->i_op = ZIPO_TRAP;
+		insn_form = OP_B;
+	} else if (strcasecmp(opstr, "CLR")==0) {
+		insn->i_op = ZIPO_CLR;
+		insn_form = ONE_REGISTER;
+	} else if (strcasecmp(opstr, "CLRF")==0) {
+		insn->i_op = ZIPO_CLRF;
+		insn_form = ONE_REGISTER;
+	} else if (strcasecmp(opstr, "BRA")==0) {
+		insn->i_op = ZIPO_BRA;
+		insn_form = OP_ADDRESS;
+	} else if (strcasecmp(opstr, "BZ")==0) {
+		insn->i_op = ZIPO_BRA;
+		insn->i_cnd = ZIPC_Z;
+		insn_form = OP_ADDRESS;
+	} else if (strcasecmp(opstr, "BNZ")==0) {
+		insn->i_op = ZIPO_BRA;
+		insn->i_cnd = ZIPC_NZ;
+		insn_form = OP_ADDRESS;
+	} else if (strcasecmp(opstr, "BGE")==0) {
+		insn->i_op = ZIPO_BRA;
+		insn->i_cnd = ZIPC_GE;
+		insn_form = OP_ADDRESS;
+	} else if (strcasecmp(opstr, "BGT")==0) {
+		insn->i_op = ZIPO_BRA;
+		insn->i_cnd = ZIPC_GT;
+		insn_form = OP_ADDRESS;
+	} else if (strcasecmp(opstr, "BLT")==0) {
+		insn->i_op = ZIPO_BRA;
+		insn->i_cnd = ZIPC_LT;
+		insn_form = OP_ADDRESS;
+	} else if (strcasecmp(opstr, "BC")==0) {
+		insn->i_op = ZIPO_BRA;
+		insn->i_cnd = ZIPC_C;
+		insn_form = OP_ADDRESS;
+	} else if (strcasecmp(opstr, "BV")==0) {
+		insn->i_op = ZIPO_BRA;
+		insn->i_cnd = ZIPC_V;
+		insn_form = OP_ADDRESS;
+	} else if (strcasecmp(opstr, "HALT")==0) {
+		insn->i_op = ZIPO_HALT;
+		insn->i_imm = ZIP_CC_SLEEP;
+		insn->i_areg= ZIP_CC;
+		insn_form = NO_OP;
+	} else if (strcasecmp(opstr, "WAIT")==0) {
+		insn->i_op = ZIPO_WAIT;
+		insn->i_imm = ZIP_CC_SLEEP | ZIP_CC_GIE;
+		insn->i_areg= ZIP_CC;
+		insn_form = NO_OP;
+	} else if ((strcasecmp(opstr, "RTU")==0)
+			||(strcasecmp(opstr, "IRET")==0)) {
+		insn->i_op = ZIPO_RTU;
+		insn->i_imm = ZIP_CC_GIE;
+		insn->i_areg = ZIP_CC;
+		insn_form = NO_OP;
+	} else if (strcasecmp(opstr, "BUSY")==0) {
+		insn->i_op = ZIPO_BUSY;
+		insn->i_imm= -1;
+		insn->i_areg = ZIP_PC;
+		insn->i_breg = ZIP_PC;
+		insn_form = NO_OP;
+	} else if (strcasecmp(opstr, "JMP")==0) {
+		insn->i_op = ZIPO_JMP;
+		insn->i_areg = ZIP_PC;
+		insn_form = OP_B;
+	} else if (strcasecmp(opstr, "NOT")==0) {
+		insn->i_op = ZIPO_NOT;
+		insn->i_imm = -1;
+		insn_form = ONE_REGISTER;
+	} else if (strcasecmp(opstr, "NEG")==0) {
+		insn->i_op = ZIPO_NEG;
+		insn->i_imm = 0;
+		insn_form = ONE_OR_TWO_OP;
+	} else {
+		free(alt);
+		return "Unrecognized op-code";
+	}
+
+	if (cndp) {
+		// We have a condition
+		if (insn->i_cnd != ZIPC_ALWAYS) {
+			err = "Instruction cannot take an additional condition";
+		} else {
+			if (strcasecmp(cndp, "LT")==0) {
+				insn->i_cnd = ZIPC_LT;
+			} else if (strcasecmp(cndp, "Z")==0) {
+				insn->i_cnd = ZIPC_Z;
+			} else if (strcasecmp(cndp, "NZ")==0) {
+				insn->i_cnd = ZIPC_NZ;
+			} else if (strcasecmp(cndp, "NE")==0) {
+				insn->i_cnd = ZIPC_NZ;
+			} else if (strcasecmp(cndp, "GT")==0) {
+				insn->i_cnd = ZIPC_GT;
+			} else if (strcasecmp(cndp, "GE")==0) {
+				insn->i_cnd = ZIPC_GE;
+			} else if (strcasecmp(cndp, "C")==0) {
+				insn->i_cnd = ZIPC_C;
+			} else if (strcasecmp(cndp, "V")==0) {
+				insn->i_cnd = ZIPC_V;
+			} else {
+				err = "Unrecognized condition";
+			}
+		}
+	} if (err) {
+		free(alt);
+		return err;
+	}
+
+	// Two (possible) tokens left:
+	//	the left of the comma, and the right of the comma
+	const char	*left, *right, *eol;
+
+	if (strchr(line, ',')!=NULL)
+		left = strtok(NULL, ",");
+	else
+		left  = strtok(NULL, " \t,");
+	right = (left)  ? strtok(NULL, " \t") : NULL;
+	eol   = (right) ? strtok(NULL, " \t") : NULL;
+	if (eol != NULL) {
+		free(alt);
+		return "Too many tokens on one line";
+	}
+
+	/*
+	printf("LEFT = %s, RIGHT = %s%s\n", (left)?left:"(null)", (right)?right:"(null)",
+		(insn->i_rp)?", (i_rp != NULL)":"");
+	*/
+
+	switch(insn_form) {
+		case TWO_OP:
+			err = zip_parse_bop(left,insn);
+			if (!err)
+				err = zip_parse_reg(right,&insn->i_areg);
+			break;
+		case IMM_OP:
+			err = zip_parse_bop(left,insn);
+			if ((!err)&&(insn->i_breg == ZIP_RNONE))
+				err = zip_parse_reg(right,&insn->i_areg);
+			else if (!err)
+				err = "LDI can only load immediates, not registers";
+			break;
+		case BACKWARDS_TWO:
+			err = zip_parse_reg(left,&insn->i_areg);
+			if (!err)
+				err = zip_parse_bop(right,insn);
+			break;
+		case MAYBE_ONE_IMM:
+			if (NULL != right)
+				err = "Wrong number of operands!";
+			else if (left) {
+				err = zip_parse_bop(left,insn);
+				if ((!err)&&(insn->i_breg != ZIP_RNONE))
+					err = "BREAK arguments can only be immediates";
+			}
+			break;
+		case NO_OP:
+			if ((NULL != left)||(NULL != right))
+				err = "Wrong number of operands!";
+			break;
+		case ONE_OR_TWO_OP:
+			// This is a reference to the test instruction, which
+			// can either be TEST a,Rx, or TEST Rx.
+			if (NULL != right) {
+				err = zip_parse_bop(left,insn);
+				if (!err)
+					err = zip_parse_reg(right,&insn->i_areg);
+				if (!err)
+					err = zip_parse_bop(left,insn);
+			} else {
+				zip_parse_reg(left, &insn->i_areg);
+				insn->i_breg = ZIP_RNONE;
+				insn->i_imm = -1;
+			} break;
+		case ONE_REGISTER:
+			// CLR, CLRF, or NOT
+			insn->i_breg = ZIP_RNONE;
+			if (NULL != right)
+				err = "Instruction opcode expects only one operand";
+			else
+				err = zip_parse_reg(left,&insn->i_areg);
+			break;
+		case OP_ADDRESS:
+			// BRA instruction
+			//	This is different from OP_B below, in that this
+			//	form implies a PC relative addressing, which
+			//	may not be clear from the operands given
+			if (NULL != right)
+				err = "Instruction opcode expects only one operand";
+			else {
+				if ((NULL == strchr(left,'('))
+					&&(NULL == strchr(left,'+'))) {
+					char	longerstr[strlen(left)+6];
+					// If not stated, assume PC relative
+					strcpy(longerstr,left);
+					strcat(longerstr, "(PC)");
+					err = zip_parse_bop(longerstr, insn);
+				} else
+					err = zip_parse_bop(left, insn);
+			}
+			
+			break;
+		case OP_B: // Operand B only (A is implied)
+			// JMP or TRAP instruction
+			if (NULL != right)
+				err = "Instruction opcode expects only one operand";
+			else
+				err = zip_parse_bop(left, insn);
+			if (insn->i_op == ZIPO_JMP)
+				insn->i_areg = ZIP_PC;
+			else
+				insn->i_areg = ZIP_CC;
+			break;
+		case TWO_REGISTER:
+			// These are the floating point instructions, which
+			// can't handle immediate offsets.
+			err = zip_parse_reg(right, &insn->i_areg);
+			if (!err)
+				err = zip_parse_reg(left, &insn->i_breg);
+			break;
+		default:	// case ILLEGAL_FORM
+			err = "Unknown instruction format!";
+			break;
+	}
+
+	if (err)
+		return (err);
+
+	switch(insn->i_op) {
+		case ZIPO_SUB: case ZIPO_AND: case ZIPO_ADD: case ZIPO_OR:
+		case ZIPO_XOR: case ZIPO_LSR: case ZIPO_LSL: case ZIPO_ASR:
+		case ZIPO_LDILO:
+		case ZIPO_DIVU: case ZIPO_DIVS:
+		case ZIPO_LDI: case ZIPO_LDIn:
+		case ZIPO_BREV: case ZIPO_POPC: case ZIPO_ROL:
+#ifdef	LONG_MPY
+		case ZIPO_MPYUHI: case ZIPO_MPYSHI:
+		case ZIPO_MPY:
+#else
+		case ZIPO_MPYU: case ZIPO_MPYS:
+		case ZIPO_LDIHI:
+#endif
+			break;
+		case ZIPO_MOV:
+			if (insn->i_breg == ZIP_RNONE)
+				insn->i_op = ZIPO_LDI;
+			break;
+		case ZIPO_FPCVT:
+			break;
+		case ZIPO_CMP: case ZIPO_TST:
+			break;
+		case ZIPO_LOD:
+			break;
+		case ZIPO_STO:
+			break;
+		case ZIPO_FPADD: case ZIPO_FPSUB:
+		case ZIPO_FPMUL: case ZIPO_FPDIV:
+		case ZIPO_FPINT:
+			if (0x0e == (insn->i_areg & 0x0f))
+				err = "Floating point operations cannot result in CC or PC regs";
+			else if (insn->i_rp)
+				err = "Relocations not applicable for floating point ops";
+			break;
+		case ZIPO_LINK:
+			// err = zip_parse_bop(right,&breg,&imm, rp);
+			err = "Link instruction not (yet) implemented";
+			break;
+		case ZIPO_TRAP:
+			insn->i_areg = ZIP_CC;
+			if (insn->i_breg == ZIP_RNONE)
+				insn->i_op = ZIPO_LDI;
+			else
+				insn->i_op = ZIPO_MOV;
+			break;
+		case ZIPO_CLR:
+			insn->i_op = ZIPO_LDI;
+			insn->i_imm = 0;
+			break;
+		case ZIPO_CLRF:
+			insn->i_op = ZIPO_XOR;
+			insn->i_imm = 0;
+			insn->i_breg = insn->i_areg;
+			break;
+		case ZIPO_JMP:
+			insn->i_op = ZIPO_MOV; // fall through
+			break;
+		case ZIPO_BRA: // Leave as ZIPO_BRA until we assemble it
+			insn->i_areg = ZIP_PC;
+			break;
+		case ZIPO_NOOP:
+			insn->i_op = ZIPO_FPADD;
+			insn->i_areg = ZIP_PC;
+			insn->i_breg = ZIP_RNONE;
+			insn->i_imm  = 0;
+			break;
+		case ZIPO_BREAK:
+			insn->i_op = ZIPO_FPSUB;
+			insn->i_areg = ZIP_PC;
+			insn->i_breg = ZIP_RNONE;
+			// insn->i_imm  = 0;
+			break;
+		case ZIPO_LOCK:
+			insn->i_op = ZIPO_FPMUL;
+			insn->i_areg = ZIP_PC;
+			insn->i_breg = ZIP_RNONE;
+			insn->i_imm  = 0;
+			break;
+		case ZIPO_HALT: case ZIPO_WAIT: case ZIPO_RTU:
+			insn->i_op = ZIPO_OR;
+			break;
+		case ZIPO_BUSY:
+			insn->i_op = ZIPO_MOV;
+			break;
+		case ZIPO_NOT:
+			insn->i_op = ZIPO_XOR;
+			insn->i_imm  = -1;
+			insn->i_breg = ZIP_RNONE;
+			break;
+		case ZIPO_NEG:
+			if (insn->i_breg == ZIP_RNONE) {
+				insn->i_breg = insn->i_areg;
+				// This would've been set to -1 by the ONE or
+				// TWO op code.  Here, we set it back to zero.
+				insn->i_imm  = 0;
+			}
+			// insn->i_op = ZIPO_NEG; /// Can't collapse this yet
+			break;
+		default:
+			return "Internal error -- unrecognized internal opcode";
+			break;
+	} if (err) {
+		free(alt);
+		return err;
+	}
+
+	if ((insn->i_op != ZIPO_MOV)&&(
+			((insn->i_areg != ZIP_RNONE)&&(insn->i_areg >= 0x10))
+			||((insn->i_breg != ZIP_RNONE)&&(insn->i_breg >= 0x10)))) {
+		if (insn->i_rp)
+			free(insn->i_rp);
+		free(alt);
+		return "Only MOV instructions can reference explicit user registers";
+	}
+
+	free(alt);
+
+	// We do nothing more to build the opcode here --- all we are doing
+	// is parsing.
+	return err;
+}
+
+#define	DBLREGOP(OP,CND,IMM,B,A) (((OP&0x01f)<<22)|((A&0x0f)<<27)	\
+			| ((CND&0x07)<<19)|(1<<18)|((B&0x0f)<<14)	\
+			| (IMM & 0x03fff))
+#define	IMMOP(OP,CND,IMM,A)	(((OP&0x01f)<<22)|((A&0x0f)<<27)	\
+			| ((CND&0x07)<<19)|(IMM & 0x03ffff))
+
+
+/*
+ *	VLIW support code
+ *
+ *	Assuming that the instruction (a) is not a VLIW instruction, this looks
+ *	up the immediate value encoded in the instruction.  The purpose is to
+ *	determine whether or not this instruction can be merged with the 
+ *	previous (or next) instruction in VLIW mode.
+ *
+ */
+static int
+zip_non_vliw_immediate(const unsigned a)
+{
+	ZIP_OPCODE	op = (ZIP_OPCODE)((a>>22)&0x1f);
+	int		imm;
+
+	switch(op) {
+		case	ZIPO_MOV:
+			imm = (a & 0x0fff); if (a&0x1fff) imm |= -0x1000; break;
+		case	ZIPO_LDI: 
+			imm = (a & 0x03fffff); break;
+		case	ZIPO_LDIn:
+			imm = (a & 0x03fffff); imm |= -0x0200000; break;
+		case	ZIPO_LDILO:
+#ifndef	LONG_MPY
+		case ZIPO_LDIHI: // BREVx would rm LDIHI
+#endif
+			imm = (a & 0x0ffff); break;
+		default:
+			if (a & 0x040000) {
+				imm = (a & 0x03fff);
+				if (a & 0x2000) imm |= -0x02000;
+			} else {
+				imm = (a & 0x03ffff);
+				if (a & 0x020000)
+					imm |= -0x020000;
+			}
+	}
+
+	return imm;
+}
+
+static int
+zip_can_merge(const unsigned a, const unsigned b)
+{
+	// 1. Can't merge anything that's already merged
+	if ((a|b) & 0x80000000)
+		return 0;
+	ZIP_OPCODE	opa, opb;
+	ZIP_CONDITION	ac, bc;
+
+	opa = (a>>22)&0x1f;
+	opb = (b>>22)&0x1f;
+
+	// 2. Can't merge if conditions aren't compatible
+	ac = ((a>>19)&0x07);
+	bc = ((b>>19)&0x07);
+
+	if ((opa&-2) == ZIPO_LDI)	ac = ZIPC_ALWAYS;
+	if ((opb&-2) == ZIPO_LDI)	bc = ZIPC_ALWAYS;
+
+	if ((ac == ZIPC_ALWAYS)&&(bc != ZIPC_ALWAYS))
+		return 0;
+	if ((ac != bc)||(ac & 0x4))
+		return 0;
+
+	// 3. Regarding move instructions--can only merge a move if it doesn't
+	// address user registers
+	if ((opa == ZIPO_MOV)&&(a & ((1<<18)|(1<<13))))
+		return 0;
+	if ((opb == ZIPO_MOV)&&(b & ((1<<18)|(1<<13))))
+		return 0;
+
+	// 4. Immediates -- check whether they are compatible
+	int	imma, immb;
+
+	switch(opa) {
+		case ZIPO_MOV:
+			// Move instructions are register-register in the
+			// VLIW format--no immediates are allowed.
+			if (a & 0x03fff) return 0;
+			break;
+		case	ZIPO_LDI: case ZIPO_LDIn:
+		case	ZIPO_LDILO:
+#ifndef	LONG_MPY
+		case ZIPO_LDIHI: // BREVx would rm LDIHI
+#endif
+			// LDIxx instructions have only immediates.  If the
+			// immediate doesn't fit in 5 bits, this won't work.
+			imma = zip_non_vliw_immediate(a);
+			if ((imma > 15)||(imma < -16))
+				return 0;
+			break;
+		default:
+			if (a & 0x040000) {
+				imma = a & 0x03fff;
+				if (imma !=0)
+					return 0;
+			} else {
+				imma = (a & 0x03ffff);
+				if (imma & 0x02000) // Sign extension?
+					imma |= -0x02000;
+				if ((imma < -8)||(imma > 7))
+					return 0;
+			}
+	}
+	
+	switch(opb) {
+		case ZIPO_MOV:
+			// Move instructions are register-register in the
+			// VLIW format--no immediates are allowed.
+			if (b & 0x03fff) return 0;
+			break;
+		case	ZIPO_LDI: case ZIPO_LDIn:
+		case	ZIPO_LDILO:
+#ifndef	LONG_MPY
+		case ZIPO_LDIHI:
+#endif
+			// LDIxx instructions have only immediates.  If the
+			// immediate doesn't fit in 5 bits, this won't work.
+			immb = zip_non_vliw_immediate(b);
+			if ((immb > 15)||(immb < -16))
+				return 0;
+			break;
+		default:
+			if (b & 0x040000) {
+				immb = (b & 0x03fff);
+				if (immb !=0)
+					return 0;
+			} else {
+				immb = (b & 0x03ffff);
+				if (immb & 0x02000) // Sign extension?
+					immb |= -0x02000;
+				if ((immb < -8)||(immb > 7))
+					return 0;
+			}
+	}
+
+	return 1;
+}
+
+static unsigned
+zip_insn_merge(const unsigned a, const unsigned b)
+{
+	// 1. We already know we can merge these, so skip our can-merge checks
+	ZIP_OPCODE	opa, opb;
+	ZIP_CONDITION	ac, bc;
+	unsigned int	retv = 0;
+
+	// Get our two opcodes
+	opa = (a>>22)&0x1f; opb = (b>>22)&0x1f;
+	// Truncate LDI opcodes back to their original values
+	if (opa == 0x017) opa = 0x016;
+	if (opb == 0x017) opb = 0x016;
+	retv = 0x80000000;
+	retv |= (opa << 22) | (opb << 5);
+
+	// Get our two conditions
+	ac = ((a>>19)&0x07);
+	bc = ((a>>19)&0x07);
+
+	if (opa == ZIPO_LDI)	ac = ZIPC_ALWAYS;
+	if (opb == ZIPO_LDI)	bc = ZIPC_ALWAYS;
+
+	if (bc == ac)
+		ac |= 0x4;
+
+	retv |= (ac << 19);
+
+	// Now for the destination registers
+	retv |= (a & 0x78000000);
+	retv |= (b & 0x78000000) >> (17);
+
+	// and the operand B
+	if (opa == ZIPO_LDI) // LDI -- 5-bit immediate
+		retv |= (a & 0x01f)<<14;
+	else if (opa == ZIPO_MOV) // Register move,the immediate bit better be 0
+		retv |= (a & 0x03c000)|0x040000;
+	else if (a & 0x040000) // B register value, no immediate
+		retv |= (a & 0x07c000);
+	else
+		retv |= (a & 0x0f)<<14;
+
+	// 
+	if (opb == ZIPO_LDI) // LDI -- 5-bit immediate
+		retv |= (b & 0x01f);
+	else if (opb == ZIPO_MOV)// Register move, the immediate bit better be 0
+		retv |= ((b & 0x03c000)>>14)|0x10;
+	else if (b & 0x040000) // B register value, no immediate
+		retv |= (b & 0x07c000) >> 14;
+	else
+		retv |= (b & 0x0f);
+
+	return retv;
+}
+
+void
+zip_check_label(symbolS *label ATTRIBUTE_UNUSED)
+{
+	// On any symbol, we need to make sure that we can jump to this
+	// address, therefore we cannot merge the previous instruction with
+	// another one that might follow.
+	vliw_mergable = FALSE;
+}
+
+static void
+zip_assemble_insn_words(fragS *fragP, segT seg, ZIPIS *insn, int relax_state,
+		long stretch)
+{
+#ifdef	ZIP_DEBUG
+	zip_dump_insn(insn);
+	if ((insn->i_rp)||(relax_state))
+		zip_dump_sym(insn->i_rp->r_sym);
+#endif
+	unsigned long	symv = 0;
+	int	sym_defined = 0, this_segment = 0, sym_known = 0;
+	symbolS	*sym = NULL;
+
+	if (insn->i_rp) {
+		fragS	*sym_frag;
+
+		sym = insn->i_rp->r_sym;
+		symv = ((sym)&&(S_IS_DEFINED(sym))) ? (S_GET_VALUE(sym)) : 0;
+		sym_frag = symbol_get_frag(sym);
+		this_segment = (S_GET_SEGMENT(sym) == seg);
+
+		symv += fragP->fr_offset;
+
+#ifdef	ZIP_DEBUG
+		{ int this_frag = (sym_frag == fragP);
+		printf("Determined symbol is %sin this frag, and %sin this segment\n", (this_frag)?"":"not ", (this_segment)?"":"not ");
+		}
+#endif
+
+		if ((stretch != 0)
+			&&( sym_frag->relax_marker != fragP->relax_marker)
+			&&(this_segment)) {
+			if ((stretch < 0)
+				||(sym_frag->region == fragP->region))
+				symv += stretch;
+			else if (symv < fragP->fr_address / OCTETS_PER_BYTE)
+				symv = fragP->fr_next->fr_address / OCTETS_PER_BYTE;
+		}
+	}
+
+	// At this point, if the symbol is "defined" that only means that
+	// the address is known--not that we can know it via GET_VALUE above
+	// here.  There are a couple of possibilities: it could be a known
+	// offset into a fragment, it could be a known offset into a segment,
+	// it could be a known memory address, or it could be a known value.
+	//
+	// If the value is an offset into our current fragment, then we can
+	// get at it via PC relative addressing.
+	//
+	// If the symbol is an offset into our current segment, often the
+	// .text segment, we may also be able to get to it via PC relative
+	// addressing.  However, we won't know until the fragment's are placed
+	// together to create this segment.  This will be before writing
+	// the file to disk.
+	//
+	// If the symbol is in the absolute segment, then we should try to 
+	// get to it via an absolute 32-bit offset reference--since we don't
+	// know (and won't know until the final link) where we are currently
+	// located within memory.
+	//
+	// The same is true of the undefined segment--we just don't know any
+	// PC offsets to that segment.
+	//
+	// But if the address is to a GOT segment, we should be able to assume
+	// it's offset from the beginning of that segment.
+	//
+	//
+	if ((relax_state)&&(insn->i_rp))
+		sym_defined = S_IS_DEFINED(insn->i_rp->r_sym);
+
+	/*
+	sym_known = (sym_defined)&&
+			((S_GET_SEGMENT(sym) == absolute_section)
+			||(S_GET_SEGMENT(sym) == expr_section)
+			||(this_frag)
+			||((this_segment)&&(fragP->fr_address != 0))
+			);
+	*/
+	sym_known = (sym_defined)&&(insn->i_rp->r_pcrel)&&(this_segment);
+	if ((sym_defined)&&(S_GET_SEGMENT(sym)==absolute_section)
+			&&(!S_FORCE_RELOC(sym, 0)))
+		sym_known = 1;
+	if ((sym_defined)&&(this_segment)&&(!S_FORCE_RELOC(sym, 0)))
+		sym_known = 1;
+#ifdef	ZIP_DEBUG
+	if (sym_known)
+		printf("%08lx@%08lx/%08lx - SYM(%s)-KNOWN %s%s%s%s%s\n",
+			(unsigned long)fragP->fr_literal, fragP->fr_address/OCTETS_PER_BYTE,
+			(unsigned long)symv, S_GET_NAME(sym),
+			(S_GET_SEGMENT(sym) == absolute_section)?" abs":"",
+			(S_GET_SEGMENT(sym) == expr_section)?" expr":"",
+			(this_frag)?" this-frag ":"",
+			((this_segment)&&(fragP->fr_address != 0))?" this-seg ":"",
+			insn->i_rp->r_pcrel?" (PC-REL)":" (ABS)");
+	else if (insn->i_rp)
+		printf("%08lx@%08lx/%08lx - SYM(%s) -- not known (yet) %s%s%s%s%s%s\n",
+			(unsigned long)fragP->fr_literal, fragP->fr_address/OCTETS_PER_BYTE,
+			(unsigned long)symv, S_GET_NAME(sym),
+			(!sym_defined)?"-- not defined":"",
+			(S_GET_SEGMENT(sym) == absolute_section)?" abs":"",
+			(S_GET_SEGMENT(sym) == expr_section)?" expr":"",
+			(this_frag)?" this-frag ":"",
+			(this_segment)?" this-seg ":"",
+			((this_segment)&&(fragP->fr_address != 0))?" this-off ":""
+			);
+
+	printf("SYM-DEF %d,%d,%d,%d, IMM = %08x\n",
+		sym_defined, sym_known, this_frag, this_segment,
+		insn->i_imm);
+#endif
+	unsigned	immv = insn->i_imm;
+	switch(insn->i_op) {
+	case ZIPO_LDI: // May or may not be conditional
+		if ((sym_known)&&(this_segment)
+			&&(fits_within(13,immv+symv-fragP->fr_address/OCTETS_PER_BYTE-insn->i_rp->r_fr_offset-1))) {
+			// Turn this into a MOV x(PC),Rx
+			insn->i_breg = ZIP_PC;
+			insn->i_op = ZIPO_MOV;
+			insn->i_naux = 0;
+			zip_assemble_insn_words(fragP, seg, insn, relax_state,
+				stretch);
+			// Tested--this works
+			return;
+		} else // Otherwise while we might know the symbol, we don't
+			// know where the segment containing it is set.  That
+			// is, sym_known means we know the offset of the
+			// symbol within its segment, not that we know its
+			// absolute address (yet).  Since we don't know the
+			// absolute address, set it to be an unknown symbol.
+			sym_known = 0;
+
+
+		insn->i_aux[0] = 0x7e000000; // NOOP -- if never used.
+		if (insn->i_rp)
+			immv += symv;
+		if ((insn->i_cnd == ZIPC_ALWAYS)
+			// and either no symbol, or we know the symbol
+			&&((!insn->i_rp)||(sym_known))
+			&&(fits_within(23, immv))) {
+
+			insn->i_naux = 0;
+			insn->i_code = ((insn->i_areg&0x0f)<<27)
+					|(ZIPO_LDI<<22)
+					|(immv & 0x07fffff);
+			if (insn->i_rp)
+				insn->i_rp->r_type = BFD_RELOC_NONE;
+		} else if (((!insn->i_rp)||(sym_known))
+			&&(fits_within(18, zip_brev(immv)))) {
+			// Can we do this with a BREV instruction using an
+			// immediate?  If so, we can then conditionally load
+			// the top 18 bist of any value ...
+			//
+			insn->i_naux = 0;
+			insn->i_code = IMMOP(ZIPO_BREV, insn->i_cnd,
+					zip_brev(immv),
+					insn->i_areg&0x0f);
+			if (insn->i_rp)
+				insn->i_rp->r_type = BFD_RELOC_NONE;
+		} else {
+			//
+			// If the symbol isn't defined, then any immv value
+			// will work--we have to come back anyway.
+			//
+
+			// BREV Extension would modify this statement
+			insn->i_naux = 1;
+			insn->i_code = IMMOP(ZIPO_BREV, insn->i_cnd,
+				zip_brev(immv)&0x01ffff, insn->i_areg);
+			// insn->i_code = IMMOP(ZIPO_LDIHI, insn->i_cnd,
+					// immv&0x0ffff,
+					// insn->i_areg);
+			insn->i_aux[0]=IMMOP(ZIPO_LDILO, insn->i_cnd,
+					(immv&0x0ffff), insn->i_areg);
+			if (insn->i_rp)
+				insn->i_rp->r_type = BFD_RELOC_ZIP_LDI;
+			else if ((zip_param_vliw)&&(zip_can_merge(insn->i_code, insn->i_aux[0]))) {
+				insn->i_code = zip_insn_merge(insn->i_code, insn->i_aux[0]);
+				insn->i_naux = 0;
+				
+			}
+		}
+#ifdef	ZIP_DEBUG
+		printf("LDI %04x:%04x,%d Instruction assembled into %08x : %08x\n",
+			(immv>>16)&0x0ffff,
+			immv & 0x0ffff, insn->i_areg,
+			insn->i_code, insn->i_aux[0]);
+#endif
+		break;
+	case ZIPO_BRA: // Includes both conditional and unconditional branches
+#ifdef	ZIP_DEBUG
+		printf("ZIPO--BRA (ADDR = %08lx, OFFSET = %08lx)\n",
+				fragP->fr_address,
+				(insn->i_rp)?insn->i_rp->r_fr_offset:0);
+#endif
+		if (insn->i_rp)
+			immv += (int)(symv
+				- fragP->fr_address/OCTETS_PER_BYTE
+				- (insn->i_rp->r_fr_offset+1));
+
+#ifdef	ZIP_DEBUG
+		if (!fits_within(18,immv))
+			printf("doesn't fit in 18 bits\n");
+#endif
+		if ((!sym_known)||(!fits_within(18,immv))) {
+			//
+			// Long jump code
+			// 
+			// I expect this to be true, since we should always
+			// be branching (or jumping) to a location defined by a
+			// symbol.
+#ifdef	ZIP_DEBUG
+			printf("BRA IMM = %08x = %d\n", immv, immv);
+#endif
+			if (insn->i_cnd == ZIPC_ALWAYS) {
+				insn->i_naux = 1;
+				insn->i_code=DBLREGOP(ZIPO_LOD,ZIPC_ALWAYS,
+					0,ZIP_PC,ZIP_PC); // Load into PC register
+				insn->i_aux[0] = 0; // Value to load
+				if (!insn->i_rp)
+					as_bad("Out of bounds branch");
+				else { // While we want a PC relative branch,
+					// this isn't it.
+					insn->i_rp->r_pcrel = FALSE;
+					insn->i_rp->r_type = BFD_RELOC_ZIP_VALUE;
+				}
+			} else {
+				insn->i_naux = 2;
+				insn->i_code=DBLREGOP(ZIPO_LOD,insn->i_cnd,
+					1,ZIP_PC,ZIP_PC); // Conditional load to PC
+				insn->i_aux[0]=IMMOP(ZIPO_ADD,ZIPC_ALWAYS,
+					1,ZIP_PC); // Skip an instruction
+				insn->i_aux[1] = 0;
+				if (!insn->i_rp)
+					as_bad("Out of bounds branch");
+				else { // While we want a PC relative branch,
+					// this isn't it.
+					insn->i_rp->r_pcrel = FALSE;
+					insn->i_rp->r_type = BFD_RELOC_ZIP_VALUE;
+				}
+			}
+		} else {
+			//
+			// We can fit, so short jump code ...
+			//
+			insn->i_naux = 0;
+			insn->i_aux[0] = NOOP_OPCODE;
+			insn->i_aux[1] = NOOP_OPCODE;
+			insn->i_code = IMMOP(ZIPO_ADD, insn->i_cnd,
+				immv, ZIP_PC); // Add value to PC
+			insn->i_rp->r_pcrel = TRUE;
+			// No relocation is required--we just did it
+			insn->i_rp->r_type = BFD_RELOC_NONE;
+			// Tested--this works
+		}
+#ifdef	ZIP_DEBUG
+		printf("BRA %08lx->%08x(%d,%d) assembled into(%d) %08x : %08x : %08x\n",
+			symv, immv, sym_defined, relax_state,
+			insn->i_naux, insn->i_code,
+			insn->i_aux[0], insn->i_aux[1]);
+#endif
+		break;
+	case ZIPO_MOV:
+		//
+		// We could go a little wild here:
+		//	MOV val,Rx
+		// Could be quietly compiled into
+		//	LDI val,Rx	(if Rx is not a user register)
+		// whereas
+		//	MOV BIGVAL(Ry),Rx
+		// could be quietly compiled into
+		//	LDI BIGVAL,Ry
+		//	ADD Rx,Ry
+		// This would give us access to full 32-bit offsets ...
+		// as long as neither Rx nor Ry was a user register
+		//
+		// For now we just handle our normal 13 bit signed immediate
+		//	offsets.
+		//		
+		if (insn->i_rp) {
+			insn->i_rp->r_pcrel = (insn->i_breg == ZIP_PC);
+			if (insn->i_rp->r_sym)
+				immv += symv;
+			if (insn->i_breg == ZIP_PC) {
+				immv +=(int)(-fragP->fr_address/OCTETS_PER_BYTE
+						-insn->i_rp->r_fr_offset-1);
+				if ((sym_known)&&(this_segment))
+					// Tested--this works
+					insn->i_rp->r_type = BFD_RELOC_NONE;
+				else
+					insn->i_rp->r_type = BFD_RELOC_ZIP_MOV_PCREL;
+//			} else if((zip_param_got)&&(insn->i_breg == ZIP_GBL)) {
+//				immv = symv;
+//				insn->i_rp->r_type = BFD_RELOC_ZIP_MOV_GOTREL;
+//				as_bad("MOV x(GOT),Ry not yet implemented");
+			} else {
+				// Do we really want to assume this is an
+				// address?
+				immv += symv;
+				insn->i_rp->r_type = BFD_RELOC_ZIP_MOV_OFFSET;
+			}
+		}
+		/*
+		// Handle offsets greater than 13 bits --- up to 32 bits
+		// Only works if we have no symbol in question, and when the
+		// target isn't the PC register (or CC for that matter).
+		else if ((!fits_within(13,insn->i_imm))
+				&&(insn->i_areg < ZIP_CC)
+				&&(insn->i_breg < ZIP_CC)) {
+			// Alternate instruction sequence:
+			//	but .... these make conditional insns from
+			//		unconditional!!
+			//	MOV.always A,Rx -> LDI A,Rx
+			//	MOV.always A(Ry),Rx -> LDI A,Rx, ADD Ry,Rx
+			// this works for conditional moves, since ADD.C
+			// doesn't set conditions
+			//	MOV.C A(Ry),Rx -> LDI.C A,Rx, ADD.C Ry,Rx
+			
+			return;
+		}
+		*/
+		insn->i_code = (0<<31)
+				|((insn->i_areg&0x0f)<<27)
+				|((insn->i_op  &0x1f)<<(31-4-5))
+				|((insn->i_cnd &0x07)<<(31-4-5-3));
+		insn->i_code |=
+			((insn->i_breg&0x0f)<<(31-17))
+			|(immv&0x01fff);
+		//
+		// Now for the extra two register bits only present in move
+		// instructions
+		//
+		insn->i_code |= (insn->i_areg&0x10)?0x40000:0;
+		insn->i_code |= (insn->i_breg&0x10)?0x02000:0;
+#ifdef	ZIP_DEBUG
+		printf("MOV Instruction assembled into %08x\n", insn->i_code);
+#endif
+		break;
+	case ZIPO_NEG:
+		insn->i_naux = 1;
+		if (insn->i_rp)
+			as_bad("NEG cannot handle symbols");
+		if ((immv == 0)&&(insn->i_areg == insn->i_breg)) {
+			insn->i_code  = IMMOP(ZIPO_SUB, insn->i_cnd, 1, insn->i_areg);
+			insn->i_aux[0]= IMMOP(ZIPO_XOR, insn->i_cnd,-1, insn->i_areg);
+
+			if ((zip_param_vliw)&&(zip_can_merge(insn->i_code, insn->i_aux[0]))) {
+				insn->i_code = zip_insn_merge(insn->i_code, insn->i_aux[0]);
+				insn->i_naux = 0;
+			}
+		} else {
+			insn->i_code = DBLREGOP(ZIPO_MOV, insn->i_cnd,
+				(-1+immv), insn->i_breg, insn->i_areg);
+			insn->i_code &= 0xfffbdfff;
+			insn->i_aux[0] = IMMOP(ZIPO_XOR, insn->i_cnd, -1,
+				insn->i_areg);
+		}
+		// printf("NEG Instruction assembled into %08x:%08x\n",
+			// insn->i_code, insn->i_aux[0]);
+		break;
+	default:
+		if (insn->i_rp) {
+			insn->i_rp->r_pcrel = FALSE;
+			immv += symv;
+			if (insn->i_breg == ZIP_PC) {
+				immv+=(int)(-fragP->fr_address/OCTETS_PER_BYTE
+						-insn->i_rp->r_fr_offset-1);
+				insn->i_rp->r_pcrel= TRUE;
+				insn->i_rp->r_type = BFD_RELOC_ZIP_OPB_PCREL;
+				if ((sym_known)&&(this_segment))
+					insn->i_rp->r_type = BFD_RELOC_NONE;
+//			} else if((zip_param_got)&&(insn->i_breg == ZIP_GBL)) {
+//				as_bad("<OP> x(GOT),Ry not yet implemented");
+//				immv += symv;
+//				insn->i_rp->r_type = BFD_RELOC_ZIP_OPB_GOTREL;
+			} else {
+				// Do we really want to assume this is an
+				// address?
+				immv += symv;
+				insn->i_rp->r_type = BFD_RELOC_ZIP_OPB_OFFSET;
+			}
+		} if (insn->i_breg != ZIP_RNONE) {
+			insn->i_code = DBLREGOP(insn->i_op, insn->i_cnd,
+				immv, insn->i_breg, insn->i_areg);
+			if (insn->i_rp) {
+				if (insn->i_breg == ZIP_PC) {
+					insn->i_rp->r_type = BFD_RELOC_ZIP_OPB_PCREL;
+					insn->i_rp->r_pcrel = TRUE;
+//				} else if((zip_param_got)&&(insn->i_breg == ZIP_GBL)) {
+//					insn->i_rp->r_type = BFD_RELOC_ZIP_OPB_GOTREL;
+				} else
+					insn->i_rp->r_type = BFD_RELOC_ZIP_OPB_OFFSET;
+			}
+		} else {
+			insn->i_code = IMMOP(insn->i_op, insn->i_cnd,
+				immv, insn->i_areg);
+			if (insn->i_rp)
+				insn->i_rp->r_type  = BFD_RELOC_ZIP_OPB_IMM;
+		}
+#ifdef	ZIP_DEBUG
+		printf("Instruction assembled into %08x%s\n", insn->i_code,
+			(insn->i_rp)?" w/ Symbol":"");
+#endif
+		break;
+	}
+}
+
+void
+md_assemble(char *line)
+{
+	// Decode an instruction from op_str
+	//	Determine the opcode
+	//		any conditions
+	//		the result register
+	//		any immediate
+	//		any "B" register
+	ZIPIS	insnv, *insn = &insnv;
+	const char *error = zip_parse(line, insn);
+	char	*p;
+
+#ifdef	ZIP_DEBUG
+	printf("ZIP-ASSEMBLE %s\n", line);
+#endif
+
+	if (error) {
+		as_bad("%s \'%s\'", error, line);
+		return;
+	}
+
+	zip_assemble_insn_words(frag_now, now_seg, insn, 0, 0);
+
+	// Then, if the instruction is valid we ...
+	//	for branches ...
+	//	  symbolS *symp = reloc->reloc_expression.X_add_symbol;
+	//	  offsetT offset = reloc->reloc_expression.X_add_number;
+	//	  char *f;
+	//	  f = frag_var(?, 4, 4, BRANCH_SUBTYPE, symp, offset, NULL);
+	//	  md_number_to_chars(f, insn->insn_code, 4); // ???
+	//
+	//
+	if ((!insn->i_rp)&&(vliw_mergable)&&(insn->i_naux == 0)&&(frag_now_fix_octets()>=4)) {
+		// ZIPI	lcode = md_number_from_chars(p, 4);
+		unsigned int	last_iword;
+		char	*buf;
+
+		buf = &frag_now->fr_literal[frag_now_fix_octets() - 4];
+#if (TARGET_BYTES_BIG_ENDIAN==0)
+		last_iword = (buf[0]&0x0ff)|((buf[1]&0x0ff)<<8)
+			|((buf[2]&0x0ff)<<16)|((buf[3]&0x0ff)<<24);
+#else
+		last_iword = (buf[3]&0x0ff)|((buf[2]&0x0ff)<<8)
+			|((buf[1]&0x0ff)<<16)|((buf[0]&0x0ff)<<24);
+#endif
+
+		if ((buf >= frag_now->fr_literal)
+				&&(zip_can_merge(last_iword,insn->i_code))){
+			p = buf;
+			insn->i_code =zip_insn_merge(last_iword, insn->i_code);
+			md_number_to_chars(p, insn->i_code, OCTETS_PER_BYTE);
+		} else {
+			p = frag_more(OCTETS_PER_BYTE*(1+insn->i_naux));
+			md_number_to_chars(p, insn->i_code, OCTETS_PER_BYTE);
+		}
+	} else {
+		int	i;
+
+		if ((insn->i_naux == 0)||(NULL == insn->i_rp)) {
+			// If we have no need of any symbols, we come here.
+			// If we have no need of any extra 4-byte instructions,
+			// we come here.
+			p = frag_more(OCTETS_PER_BYTE*(1+insn->i_naux));
+
+			if (insn->i_rp) {
+				// Generate a fixup for when we finally
+				// know where this symbol links to
+				insn->i_rp->r_fr_offset =
+					(p - frag_now->fr_literal)/OCTETS_PER_BYTE;
+				insn->i_rp->r_fix = fix_new(frag_now,
+					OCTETS_PER_BYTE * insn->i_rp->r_fr_offset, // where w/in frag?
+					4,		// 1,2, or 4 usually ... ??
+					insn->i_rp->r_sym, // Add symbol,
+					insn->i_imm, // Fixed/known offset to the symbol
+					insn->i_rp->r_pcrel, // T if PC-Relative reloc
+					insn->i_rp->r_type); // Reloc type
+				insn->i_rp = NULL;
+			}
+		} else {
+			// First, grow our fragment so we know we have the
+			// size we'll need.
+			frag_grow(OCTETS_PER_BYTE*(1+insn->i_naux));
+
+			// Then p, the place where we'd get more from, is
+			// where our instruction will be installed.  We know
+			// there's room for it there now.
+			p = frag_more(0);
+			// Record where in the frag our relaxable instruction
+			// will be installed
+			insn->i_rp->r_fr_offset = ( p - frag_now->fr_literal ) / OCTETS_PER_BYTE;
+			// Now tell the assembler about what we've done. 
+			// This'll close off the frag as well, so this is the
+			// last we'll see of this frag--even though frag_now
+			// may yet point to it (or not) for a while.
+			frag_var(rs_machine_dependent, // Relaxation type
+				OCTETS_PER_BYTE*(1+insn->i_naux),
+				OCTETS_PER_BYTE*(1+insn->i_naux),
+				rs_machine_dependent,	// Subtype
+				insn->i_rp->r_sym,	// Symbol
+				insn->i_imm,	// Offset (to be added to symbol)
+				(char *)zip_copy_insn(insn));	// Opcode
+
+		}
+		md_number_to_chars(p, insn->i_code, OCTETS_PER_BYTE);
+		for(i=0; i< insn->i_naux; i++)
+			md_number_to_chars(&p[OCTETS_PER_BYTE*(1+i)], insn->i_aux[i], OCTETS_PER_BYTE);
+
+		if (insn->i_rp) {
+			vliw_mergable = FALSE;
+		} else {
+			vliw_mergable = (zip_param_vliw)&&(insn->i_naux == 0);
+		}
+	}
+#ifdef	ZIP_DEBUG
+	zip_dump_insn(insn);
+#endif
+}
+
+/* Turn a string in input_line_pointer into a floating point constant
+ * of type type, and store the appropriate bytes in *LITP.  The number of
+ * LIITTLENUMS emitted is stored in *SIZEP.  An error message is returned, or
+ * NULL on OK.
+ */
+char	*
+md_atof(int type, char *litP, int *sizeP) {
+	int	prec;
+	LITTLENUM_TYPE	words[4];
+	char	*t;
+	int	i;
+
+	switch(type) {
+	case 'f':
+		prec = 2; break;
+	case 'd':
+		prec = 4; break;
+	default:
+		*sizeP = 0;
+		return _("bad call to md_atof");
+	}
+
+	t = atof_ieee(input_line_pointer, type, words);
+	if (t)
+		input_line_pointer = t;
+
+	*sizeP = prec * 2;
+
+	for(i=prec-1; i>= 0; i--) {
+		md_number_to_chars(litP, (valueT)words[i], 2);
+		litP += 2;
+	}
+
+	return NULL;
+}
+#define	AS_BAD_FIX(FXP,STR) as_bad_where(FXP->fx_file,FXP->fx_line,_(STR))
+
+/* Apply a fixup to the object file
+ *
+ * This function will only be called once all of the details of the fixup are
+ * known, before the object file heads to the linker (if at all).
+ */
+void
+md_apply_fix(fixS *fixP, valueT *val, segT seg ATTRIBUTE_UNUSED)
+{
+	unsigned int	iword, mask, final_fix;
+
+	final_fix = (fixP->fx_addsy == NULL) ? TRUE : FALSE;
+	
+	bfd_byte *buf = (bfd_byte *)&fixP->fx_frag->fr_literal[fixP->fx_where];
+#if (TARGET_BYTES_BIG_ENDIAN==0)
+	iword = (buf[0]&0x0ff)|((buf[1]&0x0ff)<<8)
+			|((buf[2]&0x0ff)<<16)|((buf[3]&0x0ff)<<24);
+#else
+	iword = (buf[3]&0x0ff)|((buf[2]&0x0ff)<<8)
+			|((buf[1]&0x0ff)<<16)|((buf[0]&0x0ff)<<24);
+#endif
+	(*val) &= 0x0ffffffff;
+
+#ifdef	ZIP_DEBUG
+	printf("MD-APPLY-FIX: FRAG=%08x@%08x+%08x(%d), IWORD = %08x Val=%08x (RTYP=%d->%s)%s%s, ADDEND=%08lx\n",
+		((unsigned)((unsigned long)fixP->fx_frag->fr_literal)),
+		((unsigned)((unsigned long)fixP->fx_frag->fr_address)),
+		((unsigned)((unsigned long)fixP->fx_where)),
+		((unsigned)((unsigned long)fixP->fx_size)),
+		iword, (unsigned)(*val), fixP->fx_r_type,
+		bfd_get_reloc_code_name(fixP->fx_r_type),
+		(fixP->fx_pcrel)?" PC-Rel ":" std ",
+		(fixP->fx_addsy)?"":"(Null Sym)",
+		fixP->fx_offset);
+#endif
+	switch(fixP->fx_r_type) {
+	case BFD_RELOC_NONE:
+		printf("\tNO-RELOC --- DONE\n");
+		fixP->fx_done = final_fix;
+		break;
+	case BFD_RELOC_ZIP_OPB_IMM:
+		// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_OPB_IMM\n");
+		mask = 0x3ffff; iword = (iword &(~mask))|((*val)&mask);
+		(*val) &= 0x03ffff;
+		md_number_to_chars((char *)buf, iword, OCTETS_PER_BYTE);
+		fixP->fx_done = final_fix;
+		break;
+	case BFD_RELOC_ZIP_OPB_OFFSET:
+	case BFD_RELOC_ZIP_OPB_PCREL:
+//	case BFD_RELOC_ZIP_OPB_GOTREL:
+	case BFD_RELOC_14:
+		// if (fixP->fx_r_type == BFD_RELOC_ZIP_OPB_OFFSET)
+			// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_OPB_OFFSET\n");
+		// else if (fixP->fx_r_type == BFD_RELOC_ZIP_OPB_PCREL)
+			// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_OPB_PCREL\n");
+		// else
+			// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_OPB_GOTREL\n");
+		mask = 0x3fff; iword = (iword &(~mask))|((*val)&mask);
+		(*val) &= 0x03fff;
+		md_number_to_chars((char *)buf, iword, 4);
+		fixP->fx_done = final_fix;
+		break;
+	case BFD_RELOC_ZIP_MOV_OFFSET:
+	case BFD_RELOC_ZIP_MOV_PCREL:
+	case BFD_RELOC_ZIP_MOV_GOTREL:
+		// if (fixP->fx_r_type == BFD_RELOC_ZIP_MOV_OFFSET)
+			// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_MOV_OFFSET\n");
+		// else if (fixP->fx_r_type == BFD_RELOC_ZIP_MOV_PCREL)
+			// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_MOV_PCREL\n");
+		// else
+			// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_MOV_GOTREL\n");
+		mask = 0x1fff; iword = (iword &(~mask))|((*val)&mask);
+		(*val) &= 0x01fff;
+		md_number_to_chars((char *)buf, iword, 4);
+		fixP->fx_done = final_fix;
+		break;
+	case BFD_RELOC_ZIP_LDI:
+		// If the value were known at build time, we wouldn't need
+		// to drop the lower two address bits.  However, since we're
+		// doing a fixup, we know val must reference an address,
+		// hence we shift down two bits.
+		// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_LDI\n");
+		iword |= (*val)&0x03fffff;
+		(*val) &= 0x03fffff;
+		md_number_to_chars((char *)buf, iword, 4);
+		fixP->fx_done = final_fix;
+		break;
+	case BFD_RELOC_ZIP_LLO:
+	case BFD_RELOC_16:
+		// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_LLO\n");
+		iword |= (*val)&0x0ffff;
+		(*val) &= 0x0ffff;
+		md_number_to_chars((char *)buf, iword, 4);
+		fixP->fx_done = final_fix;
+		break;
+	case BFD_RELOC_ZIP_BREV:
+		// (*val) &= 0x0fffe0000;
+		iword &= (~0x1ffff);
+		iword |= zip_brev(*val)&0x01ffff;
+		md_number_to_chars((char *)buf, iword, 4);
+		fixP->fx_done = final_fix;
+		break;
+	case BFD_RELOC_ZIP_LHI:
+		// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_LHI\n");
+		iword |= ((*val)>>16)&0x0ffff;
+		(*val) &= 0x0ffff0000;
+		md_number_to_chars((char *)buf, iword, 4);
+		fixP->fx_done = final_fix;
+		break;
+	case BFD_RELOC_32:
+	case BFD_RELOC_ZIP_VALUE:
+		// printf("\tMD-APPLY-FIX: BFD_RELOC_ZIP_VALUE/32\n");
+		iword = (*val);
+		(*val) &= 0x0ffffffff;
+		md_number_to_chars((char *)buf, iword, 4);
+		fixP->fx_done = final_fix;
+		break;
+	case BFD_RELOC_8:
+		// printf("RELOC BFD_RELOC_8 not really supported\n");
+		iword |= (*val)&0x0ff; (*val) &= 0x0ff;
+		md_number_to_chars((char *)buf, iword, 4);
+		fixP->fx_done = final_fix;
+		break;
+	default:
+		printf("RELOC #\%d not supported\n", fixP->fx_r_type);
+		// abort();
+		break;
+	}
+}
+
+/* Generate a machine-dependent relocation. */
+arelent *
+tc_gen_reloc(asection *section ATTRIBUTE_UNUSED, fixS *fixP)
+{
+#ifdef	ZIP_DEBUG
+	printf("Call to TC-GEN-RELOC(%s,FIX,%s,+%ld);\n", segment_name(section),
+			S_GET_NAME(fixP->fx_addsy),fixP->fx_offset);
+#endif
+
+	arelent	*relP;
+
+	relP = xmalloc(sizeof(arelent));
+	gas_assert(relP != 0);
+	relP->sym_ptr_ptr = (asymbol **)xmalloc(sizeof(asymbol *));
+	*relP->sym_ptr_ptr = symbol_get_bfdsym(fixP->fx_addsy);
+	relP->address = (fixP->fx_frag->fr_address + fixP->fx_where)/OCTETS_PER_BYTE;
+	// The addend value is added to the symbols value after the value is
+	// is resolved.  It is useful for PC relative addressing, as well as
+	// instructions giving offsets to symbols, such as LDI .x+50,R0. 
+	relP->addend = fixP->fx_offset;
+#ifdef	ZIP_DEBUG
+	printf("ADDEND = %08lx\n", relP->addend);
+#endif
+	relP->howto = bfd_reloc_type_lookup(stdoutput, fixP->fx_r_type);
+	if (! relP->howto) {
+		const char *name;
+		name = S_GET_NAME(fixP->fx_addsy);
+		if (name == NULL)
+			name = _("<unknown>");
+		as_fatal( _("Cannot generate relocation type for symbol %s, code %s"),
+			name, bfd_get_reloc_code_name(fixP->fx_r_type));
+	}
+	return relP;
+}
+
+int
+zip_estimate_size_before_relax(fragS *fragP, segT seg) {
+	ZIPIS	*insn = (ZIPIS *)(fragP->fr_opcode);
+	offsetT last_fix = fragP->fr_fix;
+
+	zip_assemble_insn_words(fragP, seg, insn, 1, 0);
+
+	// Goal is to estimate the total size of the fragment before any
+	// relaxations.  We need to return the difference between that
+	// new estimate of total size and the current value of fragP->fr_fix.
+#ifdef	ZIP_DEBUG
+	printf("(%s): SZ-ESTIMATE %3ld + %d*(1+%d) - %3ld = %3ld\n",
+		S_GET_NAME(insn->i_rp->r_sym),
+		insn->i_rp->r_fr_offset, OCTETS_PER_BYTE, insn->i_naux,
+		fragP->fr_fix,
+		((insn->i_rp->r_fr_offset + 1+insn->i_naux))*OCTETS_PER_BYTE - fragP->fr_fix);
+#endif
+	// zip_dump_insn(insn);
+	fragP->fr_fix =  (insn->i_rp->r_fr_offset + (1+insn->i_naux)) * OCTETS_PER_BYTE;
+	return fragP->fr_fix - last_fix;
+}
+
+#define	RELAX_STATE(FRAG)	(FRAG->fr_subtype)
+long
+zip_relax_frag(segT seg, fragS *fragP, long stretch)
+{
+	ZIPIS	*insn = (ZIPIS *)(fragP->fr_opcode);
+	char	*p =&fragP->fr_literal[insn->i_rp->r_fr_offset * OCTETS_PER_BYTE];
+	long	growth;
+	int	i, old_naux = insn->i_naux;
+
+#ifdef	ZIP_DEBUG
+	fprintf(stderr, "--- FIX --- @%08x/%08x, Sym %s (zip_relax_frag), stretch = %ld/offset = %08lx, addr=%08x\n",
+			(int)((long)(fragP->fr_literal)),
+			(unsigned)fragP->fr_address,
+			(insn->i_rp->r_sym)?  S_GET_NAME(insn->i_rp->r_sym)
+				:"(Null)",
+			stretch, insn->i_rp->r_fr_offset,
+			insn->i_imm);
+	// zip_dump_insn(insn);
+#endif
+
+	{
+		fragS	*lclfP;
+		for(lclfP = fragP; lclfP; lclfP = lclfP->fr_next)
+			gas_assert(lclfP->fr_type < 256);
+	}
+
+	// We need to rebuild the instruction since we could relax it
+	// multiple times
+	zip_assemble_insn_words(fragP, seg, insn, 1, stretch);
+	{
+		fragS	*lclfP;
+		for(lclfP = fragP; lclfP; lclfP = lclfP->fr_next)
+			gas_assert(lclfP->fr_type < 256);
+	}
+
+	md_number_to_chars(p, insn->i_code, OCTETS_PER_BYTE);
+	{
+		fragS	*lclfP;
+		for(lclfP = fragP; lclfP; lclfP = lclfP->fr_next)
+			gas_assert(lclfP->fr_type < 256);
+	}
+
+	for(i=0; i< insn->i_naux; i++)
+		md_number_to_chars(&p[OCTETS_PER_BYTE*(1+i)], insn->i_aux[i],
+				OCTETS_PER_BYTE);
+
+	{
+		fragS	*lclfP;
+		for(lclfP = fragP; lclfP; lclfP = lclfP->fr_next)
+			gas_assert(lclfP->fr_type < 256);
+	}
+
+	// The change in size of this fragment
+	growth = (insn->i_naux - old_naux) * OCTETS_PER_BYTE;
+#ifdef	ZIP_DEBUG
+	printf("GROWING BY %3ld bytes (insn->i_naux = %d->%d, fr_fix was %ld)\n",
+		growth, old_naux, insn->i_naux, fragP->fr_fix);
+	gas_assert(fragP->fr_fix >= 0);
+	gas_assert(fragP->fr_fix + growth>= 0);
+#endif
+	{
+		fragS	*lclfP;
+		for(lclfP = fragP; lclfP; lclfP = lclfP->fr_next)
+			gas_assert(lclfP->fr_type < 256);
+	}
+
+	return growth;
+}
+
+void
+zip_convert_frag(bfd *headers ATTRIBUTE_UNUSED, segT segment ATTRIBUTE_UNUSED,
+		fragS *fragP ATTRIBUTE_UNUSED)
+{
+	ZIPIS	*insn = (ZIPIS *)fragP->fr_opcode;
+	// char	*p = fragP->fr_literal+ insn->i_rp->r_fr_offset*OCTETS_PER_BYTE;
+
+#ifdef	ZIP_DEBUG
+	printf("CVT-FRAG: ADDR = %08lx, FIX = %3ld, VAR = %3ld\n",
+		fragP->fr_address, fragP->fr_fix, fragP->fr_var);
+
+	zip_dump_insn(insn);
+#endif
+
+	if ((insn->i_rp)&&(insn->i_rp->r_type != BFD_RELOC_NONE)
+			&&(!insn->i_rp->r_fix)) {
+		if (insn->i_op == ZIPO_LDI) {
+			if (insn->i_naux == 1) {
+				// BREV extension would go here
+				//
+				fix_new(fragP,
+					OCTETS_PER_BYTE * insn->i_rp->r_fr_offset, // where w/in frag?
+					4,		// 1,2, or 4 usually ... ??
+					insn->i_rp->r_sym, // Add symbol,
+					insn->i_imm,// Fixed/known offset to the symbol
+					insn->i_rp->r_pcrel, // T if PC-Relative reloc
+					BFD_RELOC_ZIP_BREV); // Reloc type
+					// BFD_RELOC_ZIP_LHI); // Reloc type
+				fix_new(fragP,
+					OCTETS_PER_BYTE * (insn->i_rp->r_fr_offset+1), // where w/in frag?
+					4,		// 1,2, or 4 usually ... ??
+					insn->i_rp->r_sym, // Add symbol,
+					insn->i_imm,// Fixed/known offset to the symbol
+					insn->i_rp->r_pcrel, // T if PC-Relative reloc
+					BFD_RELOC_ZIP_LLO); // Reloc type
+			} else {
+				insn->i_rp->r_fix = fix_new(fragP,
+					OCTETS_PER_BYTE * (insn->i_rp->r_fr_offset+1), // where w/in frag?
+					4,		// 1,2, or 4 usually ... ??
+					insn->i_rp->r_sym, // Add symbol,
+					insn->i_imm, // Fixed/known offset to the symbol
+					insn->i_rp->r_pcrel, // T if PC-Relative reloc
+					BFD_RELOC_ZIP_LDI); // Reloc type
+			}
+		} else if ((insn->i_op == ZIPO_BRA)&&(insn->i_naux >= 1)) {
+#ifdef	ZIP_DEBUG
+			printf("--- CVT-FRAG --- Creating a BRA fixup\n");
+#endif
+			fix_new(fragP,
+				OCTETS_PER_BYTE * (insn->i_rp->r_fr_offset +insn->i_naux),
+				4,		// 1,2, or 4 usually ... ??
+				insn->i_rp->r_sym, // Add symbol,
+				0, // Fixed/known offset to the symbol
+				insn->i_rp->r_pcrel, // T if PC-Relative reloc
+				BFD_RELOC_ZIP_VALUE); // Reloc type
+		} else {
+#ifdef	ZIP_DEBUG
+			printf("--- CVT-FRAG --- Creating a more generic fixup (%d)\n",
+				insn->i_rp->r_type);
+#endif
+			fix_new(fragP,
+				OCTETS_PER_BYTE * insn->i_rp->r_fr_offset, // where w/in frag?
+				4,		// 1,2, or 4 usually ... ??
+				insn->i_rp->r_sym, // Add symbol,
+				0, // Fixed/known offset to the symbol
+				insn->i_rp->r_pcrel, // T if PC-Relative reloc
+				insn->i_rp->r_type); // Reloc type
+		}
+	}
+}
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/config/tc-zip.h binutils-2.25/gas/config/tc-zip.h
--- binutils-2.25-original/gas/config/tc-zip.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/gas/config/tc-zip.h	2016-04-19 10:26:34.818991485 -0400
@@ -0,0 +1,211 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Filename: 	tc-zip.h
+//
+// Project:	Zip CPU backend for GNU Binutils
+//
+// Purpose:	
+//
+// Creator:	Dan Gisselquist, Ph.D.
+//		Gisselquist Technology, LLC
+//
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (C) 2016, Gisselquist Technology, LLC
+//
+// This program is free software (firmware): you can redistribute it and/or
+// modify it under the terms of  the GNU General Public License as published
+// by the Free Software Foundation, either version 3 of the License, or (at
+// your option) any later version.
+//
+// This program is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this program.  (It's in the $(ROOT)/doc directory, run make with no
+// target there if the PDF file isn't present.)  If not, see
+// <http://www.gnu.org/licenses/> for a copy.
+//
+// License:	GPL, v3, as defined and found on www.gnu.org,
+//		http://www.gnu.org/licenses/gpl.html
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+#ifndef	TC_ZIPCPU
+#define	TC_ZIPCPU
+
+#define	TC_ZIP	1
+
+/*
+ * OCTETS_PER_BYTE and OCTETS_PER_BYTE_POWER help to define the minimal
+ * addressable unit.  On most systems, this is 8 bits (one octet).  On the
+ * Zip CPU, however, the bus has been simplified so that every transaction is
+ * a 32-bit transaction.  Thus, in order that transactions do not overlap, the
+ * minimum addressable unit is 32-bits or 4-octets.  Note that we don't call
+ * these 4-bytes, as I think BINUTILS refers to this as a single 32-bit byte.
+ * Hence, the byte size changes as well.
+ *
+ * The trick to making this work is realizing what does (and doesn't) change
+ * as a result.  
+ *
+ *  Changes:
+ *	S_GET_VALUE(fx_addsy)
+ *	S_GET_VALUE(fx_subsy)
+ *	r_fr_offset
+ *	fr_offset
+ *  Does not change (and needs manual changing)
+ *	fr_address
+ *	fr_fix
+ *	fx_where
+ */
+#define	OCTETS_PER_BYTE_POWER	2
+#define	OCTETS_PER_BYTE		(1<<OCTETS_PER_BYTE_POWER)
+
+// #define	MD_PCREL_FROM_SECTION(FIX, SEC)	md_pcrel_from(FIX)
+// long md_pcrel_from(fixS *);
+
+/* This macro, when defined as zero, means our target in little endian.  A
+ * 1 would mean it was big endian.  In reality, the Zip CPU is neither.
+ * Endianness is a property of how the data is stored and retrieved from
+ * memory-media.  However, since the Zip CPU only reads/writes 32-bits at a
+ * time, the endianness is restricted to how the media is implemented.  Here,
+ * we define ourselves as big endian for greater compatibility with how I view
+ * the instructions--high order byte first.  (It makes the disassembler work
+ * as I think it should ... high order byte instruction first)
+ */
+#define	TARGET_BYTES_BIG_ENDIAN	1
+
+/* If WORKING_DOT_WORD is defined, GAS will not do broken word processing
+ * (*note Broken Words ...).  Otherwise, you should set 'md_short_jump_size'
+ * to the size of a short jump (a jump that is just long enough to jump
+ * around a long jmp) and 'md_long_jump_size' to the size of a long jump
+ * (a jump that can go anywhere in the function).  You should define 
+ * md_create_short_jump to create a short jump around a long jump, and define
+ * md_create_long_jump to creat a long jump.  Here, we'll just skip these
+ * and so we define WORKING_DOT_WORD.
+ */
+#define	WORKING_DOT_WORD
+
+/* TC_ADDRESS_BYTES ... Define this macro to specify the number of bytes used
+ * to store an address.  Used to implement dc.a.  The target must have a reloc
+ * for this size.
+ */
+#define	TC_ADDRESS_BYTES	zip_address_bytes
+
+/* TC_PREDICATE_START_CHAR ... I can't find this in the documentation, but I'm
+ * guessing if a line begins with this character, the line beginning will be
+ * taken care of specially.
+ */
+#define	TC_PREDICATE_START_CHAR	'('
+#define	TC_PREDICATE_END_CHAR	')'
+
+
+/* Accept numbers with a suffix, e.g. 0ffffh, 1010b. --- from TI-c4x code */
+// #define	NUMBERS_WITH_SUFFIX 1
+/* md_cons_align ... You may define this macro to do any special alignment
+ * before a data allocation pseudo-op.
+ */
+#define	md_cons_align(N)	zip_cons_align(N)
+
+/* TI implements the tic4x_do_align --- do we need it? */
+
+/* This macro is the BFD target name to use when creating the output
+* file.  This will normally depend upon the OBJ_FMT macro. */
+#define TARGET_FORMAT "elf32-zip"
+#define	TARGET_ARCH	bfd_arch_zip
+
+#define md_estimate_size_before_relax	zip_estimate_size_before_relax
+#define	md_relax_frag			zip_relax_frag
+#define md_convert_frag			zip_convert_frag
+extern long zip_relax_frag(segT, fragS *, long);
+extern int  zip_estimate_size_before_relax(fragS *, segT);
+extern void zip_convert_frag(bfd *, segT, fragS *);
+extern	int	zip_address_bytes(void);
+extern	void	zip_cons_align(int);
+
+/* These macros must be defined, but it will be a fatal assembler error if we
+* ever hit them. */
+// #define md_estimate_size_before_relax(A, B) (as_fatal (_("estimate size\n")),0)
+#define md_pcrel_from(FIX) (((FIX)->fx_where+(FIX)->fx_frag->fr_address+4)>>OCTETS_PER_BYTE_POWER)
+
+// What do we need to define here to align on 32-bit boundaries?
+#define	md_section_align(SEGMENT, SIZE) (SIZE)
+
+// Check label is called right after any label (lbl: ) is found in the 
+// assembly of the program.  We need to make certain this is called, so that
+// in VLIW mode we don't try to merge an instruction pair into a new
+// instruction sequence where the label calls for jumping into the middle
+// of that sequence.
+//
+#define	tc_check_label	zip_check_label
+extern void	zip_check_label(symbolS *);
+
+
+extern	void	md_assemble(char *op_str);
+extern	void	md_end(void);
+extern	void	md_begin(void);
+// extern	symbolS *md_undefined_symbol(char *name);
+// extern	void md_operand(expressionS *name);
+
+#if (TARGET_BYTES_BIG_ENDIAN==0)
+#define	md_number_to_chars	number_to_chars_littleendian
+#else
+#define	md_number_to_chars	number_to_chars_bigendian
+#endif
+
+// #define	TC_FORCE_RELOCATION(fixp)	zip_force_relocation(fixp)
+// extern	int	zip_force_relocation(struct fix *);
+
+
+#define	GLOBAL_OFFSET_TABLE_NAME	"_GLOBAL_OFFSET_TABLE_"
+
+//	typedef	unsigned int	ZIPI, ZIPA;
+//	typedef	int	ZIPIMM;
+
+typedef	enum {
+	ZIP_R0=0, ZIP_R1, ZIP_R2, ZIP_R3, ZIP_R4, ZIP_R5, ZIP_R6, ZIP_R7,
+	ZIP_R8, ZIP_R9, ZIP_R10, ZIP_R11, ZIP_GBL,
+		ZIP_SP, ZIP_CC, ZIP_PC,
+	ZIP_uR0, ZIP_uR1, ZIP_uR2, ZIP_uR3, ZIP_uR4, ZIP_uR5, ZIP_uR6, ZIP_uR7,
+	ZIP_uR8, ZIP_uR9, ZIP_uR10, ZIP_uR11, ZIP_uGBL,
+		ZIP_uSP, ZIP_uCC, ZIP_uPC,
+	ZIP_RNONE=48
+} ZIP_REG;
+
+typedef	enum {
+	ZIPC_ALWAYS, ZIPC_LT, ZIPC_Z, ZIPC_NZ,
+	ZIPC_GT, ZIPC_GE, ZIPC_C, ZIPC_V
+} ZIP_CONDITION;
+
+typedef	enum {
+	// 16 ALU instructions
+	ZIPO_SUB=0, ZIPO_AND, ZIPO_ADD, ZIPO_OR,	// 5'h000xx
+	ZIPO_XOR, ZIPO_LSR, ZIPO_LSL, ZIPO_ASR,		// 5'h001xx
+	ZIPO_LDIHI, ZIPO_LDILO, ZIPO_MPYU, ZIPO_MPYS,	// 5'h010xx
+	ZIPO_BREV, ZIPO_POPC, ZIPO_ROL, ZIPO_MOV,	// 5'h011xx
+	ZIPO_CMP, ZIPO_TST,				// 5'h1000x
+	ZIPO_LOD, ZIPO_STO,				// 5'h1001w
+	ZIPO_DIVU, ZIPO_DIVS,				// 5'h1010s
+	ZIPO_LDI, ZIPO_LDIn,				// 5'h1011x
+	// ZIPO_, ZIPO_DIVS,				// 5'h11000
+	ZIPO_FPADD=0x18, ZIPO_FPSUB,			// 5'h1100x
+	ZIPO_FPMUL, ZIPO_FPDIV,				// 5'h1101x
+	ZIPO_FPCVT, ZIPO_FPINT,				// 5'h1110x
+	// Pseudo-ops
+	ZIPO_NOOP, ZIPO_BREAK, ZIPO_LOCK,
+	ZIPO_LINK, ZIPO_TRAP, ZIPO_CLR, ZIPO_CLRF,
+	ZIPO_BRA,  ZIPO_BZ,   ZIPO_BNZ, ZIPO_BGE,
+	ZIPO_BGT,  ZIPO_BLT,  ZIPO_BC,  ZIPO_BV,
+	ZIPO_HALT, ZIPO_WAIT, ZIPO_RTU, ZIPO_BUSY,
+	ZIPO_JMP,  ZIPO_NOT, ZIPO_NEG
+} ZIP_OPCODE;
+
+// If LONG_MPY is defined (or not) we then use these opcodes
+#define	ZIPO_MPYUHI	ZIPO_MPYU
+#define	ZIPO_MPYSHI	ZIPO_MPYS
+#define	ZIPO_MPY	ZIPO_LDIHI
+
+#endif
+
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/configure.tgt binutils-2.25/gas/configure.tgt
--- binutils-2.25-original/gas/configure.tgt	2014-10-14 03:32:03.000000000 -0400
+++ binutils-2.25/gas/configure.tgt	2016-02-04 21:28:02.491872737 -0500
@@ -110,6 +110,7 @@
   x86_64*)		cpu_type=i386 arch=x86_64;;
   xgate)		cpu_type=xgate ;;
   xtensa*)		cpu_type=xtensa arch=xtensa ;;
+  zip*)			cpu_type=zip endian=big ;;
   *)			cpu_type=${cpu} ;;
 esac
 
@@ -463,6 +464,8 @@
 
   z8k-*-coff | z8k-*-sim)		fmt=coff ;;
 
+  zip*)					fmt=elf ;;
+
   *-*-aout | *-*-scout)			fmt=aout ;;
   *-*-dragonfly*)			fmt=elf em=dragonfly ;;
   *-*-freebsd* | *-*-kfreebsd*-gnu)	fmt=elf em=freebsd ;;
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/frags.c binutils-2.25/gas/frags.c
--- binutils-2.25-original/gas/frags.c	2014-10-14 03:32:03.000000000 -0400
+++ binutils-2.25/gas/frags.c	2016-02-20 18:52:07.305435296 -0500
@@ -125,6 +125,7 @@
           /* Not enough room in this frag.  Close it and start a new one.
              This must be done in a loop because the created frag may not
              be big enough if the current obstack chunk is used.  */
+
           frag_wane (frag_now);
           frag_new (0);
         }
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/macro.c binutils-2.25/gas/macro.c
--- binutils-2.25-original/gas/macro.c	2014-10-14 03:32:03.000000000 -0400
+++ binutils-2.25/gas/macro.c	2016-02-18 18:45:08.562909179 -0500
@@ -117,6 +117,8 @@
   size_t line_start = ptr->len;
   size_t more = get_line (ptr);
 
+	printf("Buffer and nest, from %s\n", from);
+
   if (to_len == 4 && strcasecmp (to, "ENDR") == 0)
     {
       from = NULL;
@@ -799,6 +801,8 @@
   formal_entry *loclist = NULL;
   const char *err = NULL;
 
+	printf("EXPAND-MACRO\n");
+
   sb_new (&t);
 
   while (src < in->len && !err)
@@ -1031,6 +1035,8 @@
   int is_keyword = 0;
   int narg = 0;
   const char *err = NULL;
+	printf("EXPAND-MACRO !BODY\n");
+
 
   sb_new (&t);
 
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/Makefile.am binutils-2.25/gas/Makefile.am
--- binutils-2.25-original/gas/Makefile.am	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/gas/Makefile.am	2016-02-04 21:12:13.355418158 -0500
@@ -193,6 +193,7 @@
 	config/tc-xtensa.c \
 	config/tc-z80.c \
 	config/tc-z8k.c \
+	config/tc-zip.c \
 	config/xtensa-relax.c
 
 TARGET_CPU_HFILES = \
@@ -264,6 +265,7 @@
 	config/tc-xtensa.h \
 	config/tc-z80.h \
 	config/tc-z8k.h \
+	config/tc-zip.h \
 	config/xtensa-relax.h
 
 # OBJ files in config
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/Makefile.in binutils-2.25/gas/Makefile.in
--- binutils-2.25-original/gas/Makefile.in	2014-10-14 03:32:02.000000000 -0400
+++ binutils-2.25/gas/Makefile.in	2016-02-04 21:12:13.355418158 -0500
@@ -462,6 +462,7 @@
 	config/tc-xtensa.c \
 	config/tc-z80.c \
 	config/tc-z8k.c \
+	config/tc-zip.c \
 	config/xtensa-relax.c
 
 TARGET_CPU_HFILES = \
@@ -533,6 +534,7 @@
 	config/tc-xtensa.h \
 	config/tc-z80.h \
 	config/tc-z8k.h \
+	config/tc-zip.h \
 	config/xtensa-relax.h
 
 
@@ -888,6 +890,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-xtensa.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-z80.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-z8k.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-zip.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/te-vms.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xtensa-relax.Po@am__quote@
@@ -1879,6 +1882,20 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-z8k.obj `if test -f 'config/tc-z8k.c'; then $(CYGPATH_W) 'config/tc-z8k.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-z8k.c'; fi`
 
+tc-zip.o: config/tc-zip.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-zip.o -MD -MP -MF $(DEPDIR)/tc-zip.Tpo -c -o tc-zip.o `test -f 'config/tc-zip.c' || echo '$(srcdir)/'`config/tc-zip.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-zip.Tpo $(DEPDIR)/tc-zip.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-zip.c' object='tc-zip.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-zip.o `test -f 'config/tc-zip.c' || echo '$(srcdir)/'`config/tc-zip.c
+
+tc-zip.obj: config/tc-zip.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-zip.obj -MD -MP -MF $(DEPDIR)/tc-zip.Tpo -c -o tc-zip.obj `if test -f 'config/tc-zip.c'; then $(CYGPATH_W) 'config/tc-zip.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-zip.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-zip.Tpo $(DEPDIR)/tc-zip.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-zip.c' object='tc-zip.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-zip.obj `if test -f 'config/tc-zip.c'; then $(CYGPATH_W) 'config/tc-zip.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-zip.c'; fi`
+
 xtensa-relax.o: config/xtensa-relax.c
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT xtensa-relax.o -MD -MP -MF $(DEPDIR)/xtensa-relax.Tpo -c -o xtensa-relax.o `test -f 'config/xtensa-relax.c' || echo '$(srcdir)/'`config/xtensa-relax.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/xtensa-relax.Tpo $(DEPDIR)/xtensa-relax.Po
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/read.c binutils-2.25/gas/read.c
--- binutils-2.25-original/gas/read.c	2014-10-14 03:32:03.000000000 -0400
+++ binutils-2.25/gas/read.c	2016-03-27 22:09:08.890860654 -0400
@@ -684,7 +684,8 @@
   /* We do this every time rather than just in s_bundle_align_mode
      so that we catch any affected section without needing hooks all
      over for all paths that do section changes.  It's cheap enough.  */
-  record_alignment (now_seg, bundle_align_p2 - OCTETS_PER_BYTE_POWER);
+  if (bundle_align_p2 > OCTETS_PER_BYTE_POWER)
+    record_alignment (now_seg, bundle_align_p2 - OCTETS_PER_BYTE_POWER);
 }
 
 /* Assemble one instruction.  This takes care of the bundle features
@@ -1394,6 +1395,9 @@
 static void
 do_align (int n, char *fill, int len, int max)
 {
+  if (n < OCTETS_PER_BYTE_POWER)
+    n = OCTETS_PER_BYTE_POWER;
+
   if (now_seg == absolute_section)
     {
       if (fill != NULL)
@@ -1415,7 +1419,7 @@
 #endif
 
   /* Only make a frag if we HAVE to...  */
-  if (n != 0 && !need_pass_2)
+  if ((n >= OCTETS_PER_BYTE_POWER) && !need_pass_2)
     {
       if (fill == NULL)
 	{
@@ -1434,7 +1438,8 @@
  just_record_alignment: ATTRIBUTE_UNUSED_LABEL
 #endif
 
-  record_alignment (now_seg, n - OCTETS_PER_BYTE_POWER);
+  if (n > OCTETS_PER_BYTE_POWER)
+    record_alignment (now_seg, n - OCTETS_PER_BYTE_POWER);
 }
 
 /* Handle the .align pseudo-op.  A positive ARG is a default alignment
@@ -3336,7 +3341,7 @@
 	  offsetT i;
 
 	  if (mult == 0)
-	    mult = 1;
+	    mult = OCTETS_PER_BYTE;
 	  bytes = mult * exp.X_add_number;
 	  for (i = 0; i < exp.X_add_number; i++)
 	    emit_expr (&val, mult);
@@ -3354,7 +3359,7 @@
 	  repeat = exp.X_add_number;
 	  if (mult)
 	    repeat *= mult;
-	  bytes = repeat;
+	  bytes = repeat * OCTETS_PER_BYTE;
 	  if (repeat <= 0)
 	    {
 	      if (!flag_mri)
@@ -3382,7 +3387,7 @@
 	    }
 
 	  if (!need_pass_2)
-	    p = frag_var (rs_fill, 1, 1, (relax_substateT) 0, (symbolS *) 0,
+	    p = frag_var (rs_fill, OCTETS_PER_BYTE, OCTETS_PER_BYTE, (relax_substateT) 0, (symbolS *) 0,
 			  (offsetT) repeat, (char *) 0);
 	}
       else
@@ -3400,7 +3405,7 @@
 	    }
 
 	  if (!need_pass_2)
-	    p = frag_var (rs_space, 1, 1, (relax_substateT) 0,
+	    p = frag_var (rs_space, OCTETS_PER_BYTE, OCTETS_PER_BYTE, (relax_substateT) 0,
 			  make_expr_symbol (&exp), (offsetT) 0, (char *) 0);
 	}
 
@@ -4927,6 +4932,8 @@
   while (!(((value == 0) && ((byte & 0x40) == 0))
 	   || ((value == -1) && ((byte & 0x40) != 0))));
 
+  if (OCTETS_PER_BYTE_POWER > 0)
+    size = (size + (1<<OCTETS_PER_BYTE_POWER))&((~0)<<OCTETS_PER_BYTE_POWER);
   return size;
 }
 
@@ -4942,6 +4949,8 @@
     }
   while (value != 0);
 
+  if (OCTETS_PER_BYTE_POWER > 0)
+    size = (size + (1<<OCTETS_PER_BYTE_POWER))&((~0)<<OCTETS_PER_BYTE_POWER);
   return size;
 }
 
@@ -4960,7 +4969,7 @@
 output_sleb128 (char *p, offsetT value)
 {
   char *orig = p;
-  int more;
+  int more, size;
 
   do
     {
@@ -4980,13 +4989,17 @@
     }
   while (more);
 
-  return p - orig;
+  size = p - orig;
+  if (OCTETS_PER_BYTE_POWER > 0)
+    size = (size + (1<<OCTETS_PER_BYTE_POWER))&((~0)<<OCTETS_PER_BYTE_POWER);
+  return size;
 }
 
 static inline int
 output_uleb128 (char *p, valueT value)
 {
   char *orig = p;
+  int size;
 
   do
     {
@@ -5000,7 +5013,10 @@
     }
   while (value != 0);
 
-  return p - orig;
+  size = p - orig;
+  if (OCTETS_PER_BYTE_POWER > 0)
+    size = (size + (1<<OCTETS_PER_BYTE_POWER))&((~0)<<OCTETS_PER_BYTE_POWER);
+  return size;
 }
 
 int
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/align2.d binutils-2.25/gas/testsuite/gas/all/align2.d
--- binutils-2.25-original/gas/testsuite/gas/all/align2.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/align2.d	2016-02-04 22:06:05.190524749 -0500
@@ -6,4 +6,4 @@
 .*: .*
 
 Contents of section .text:
- 0000 ff[ 	0-9a-f]*[ 	]+.*
+ 0000 000000ff[ 	]+.*
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/align.d binutils-2.25/gas/testsuite/gas/all/align.d
--- binutils-2.25-original/gas/testsuite/gas/all/align.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/align.d	2016-02-05 12:16:46.347630564 -0500
@@ -3,6 +3,7 @@
 # The RX port will always replace zeros in any aligned area with NOPs,
 # even if the user requested that they filled with zeros.
 #not-target: m32c-* rx-*
+#xfail: zip*
 
 # Test the alignment pseudo-op.
 
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/altmac2.d binutils-2.25/gas/testsuite/gas/all/altmac2.d
--- binutils-2.25-original/gas/testsuite/gas/all/altmac2.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/altmac2.d	2016-02-04 22:09:45.368750114 -0500
@@ -7,4 +7,4 @@
 .*: .*
 
 Contents of section .data:
- 0000 3e3c21.*
+ 0000 0000003e 0000003c 00000021.*
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/altmacro.d binutils-2.25/gas/testsuite/gas/all/altmacro.d
--- binutils-2.25-original/gas/testsuite/gas/all/altmacro.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/altmacro.d	2016-02-04 22:08:15.501473408 -0500
@@ -7,5 +7,8 @@
 .*: .*
 
 Contents of section .data:
- 0000 01020912 61626331 32332121 3c3e2721 .*
- 0010 3c3e27.*
+ 0000 00000001 00000002 00000009 00000012 .*
+ 0004 00000061 00000062 00000063 00000031 .*
+ 0008 00000032 00000033 00000021 00000021 .*
+ 000c 0000003c 0000003e 00000027 00000021 .*
+ 0010 0000003c 0000003e 00000027.*
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/eval.d binutils-2.25/gas/testsuite/gas/all/eval.d
--- binutils-2.25-original/gas/testsuite/gas/all/eval.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/eval.d	2016-02-04 22:10:35.336348555 -0500
@@ -4,5 +4,6 @@
 .*: .*
 
 Contents of section .data:
- 0000 01010101 010101.. ........ ........  ................
+ 0000 00000001 00000001 00000001 00000001 .*
+ 0004 00000001 00000001 00000001 .*
 #pass
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/forward.d binutils-2.25/gas/testsuite/gas/all/forward.d
--- binutils-2.25-original/gas/testsuite/gas/all/forward.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/forward.d	2016-02-04 21:59:38.133420172 -0500
@@ -4,5 +4,8 @@
 .*: .*
 
 Contents of section .data:
- 0000 01020304 ff0203fc 01020304 ff0203fc  ................
+ 0000 00000001 00000002 00000003 00000004  ................
+ 0004 ffffffff 00000002 00000003 fffffffc  ................
+ 0008 00000001 00000002 00000003 00000004  ................
+ 000c ffffffff 00000002 00000003 fffffffc  ................
 #pass
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/fwdexp.d binutils-2.25/gas/testsuite/gas/all/fwdexp.d
--- binutils-2.25-original/gas/testsuite/gas/all/fwdexp.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/fwdexp.d	2016-02-04 22:01:22.504640513 -0500
@@ -5,7 +5,7 @@
 
 RELOCATION RECORDS FOR .*
 OFFSET +TYPE +VALUE 
-0+ .*(\.data|i)(|\+0xf+e|\+0xf+c|\+0xf+8|-0x0*2|-0x0*4|-0x0*8)
+0+ .*(\.data|i)(-0x0*1)
 
 Contents of section .*
- 0+ (0+|feff|fffe|fcffffff|fffffffc|f8ffffff|f8ffffff ffffffff|ffffffff fffffff8|0+4) .*
+ 0+ (ffffffff) .*
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/incbin.d binutils-2.25/gas/testsuite/gas/all/incbin.d
--- binutils-2.25-original/gas/testsuite/gas/all/incbin.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/incbin.d	2016-02-04 22:24:08.721646746 -0500
@@ -9,6 +9,6 @@
 
 Contents of section .text:
  0000 38383838 38383838 0c313232 3333330c  88888888.122333.
- 0010 534f4d45 4d4f5245 44415441 44415441  SOMEMOREDATADATA
- 0020 38383838 38383838 0c313232 3333330c  88888888.122333.
- 0030 534f4d45 4d4f5245 44415441 44415441  SOMEMOREDATADATA
+ 0004 534f4d45 4d4f5245 44415441 44415441  SOMEMOREDATADATA
+ 0008 38383838 38383838 0c313232 3333330c  88888888.122333.
+ 000c 534f4d45 4d4f5245 44415441 44415441  SOMEMOREDATADATA
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/redef2.d binutils-2.25/gas/testsuite/gas/all/redef2.d
--- binutils-2.25-original/gas/testsuite/gas/all/redef2.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/redef2.d	2016-02-04 22:08:54.065162857 -0500
@@ -7,10 +7,10 @@
 RELOCATION RECORDS FOR .*
 .*
 0+00.*(here|\.data|\$DATA\$)
-0+08.*xtrn
-0+10.*(sym|(\.data|\$DATA\$)(\+0x0+10)?)
+0+02.*xtrn
+0+04.*(sym|(\.data|\$DATA\$)(\+0x0+4)?)
 #...
 Contents of section (\.data|\$DATA\$):
  0000 00000000 11111111 00000000 22222222[ 	]+................[ 	]*
- 0010 [01]00000[01]0 .*
+ 0004 00000004 .*
 #pass
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/redef3.d binutils-2.25/gas/testsuite/gas/all/redef3.d
--- binutils-2.25-original/gas/testsuite/gas/all/redef3.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/redef3.d	2016-02-04 22:03:41.499604332 -0500
@@ -7,10 +7,10 @@
 RELOCATION RECORDS FOR .*
 .*
 0+00.*(here|\.data)
-0+08.*xtrn
-0+10.*sym
+0+02.*xtrn
+0+04.*sym
 #...
 Contents of section \.data:
  0000 00000000 11111111 00000000 22222222[ 	]+................[ 	]*
- 0010 00000000 .*
+ 0004 00000000 .*
 #pass
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/redef.d binutils-2.25/gas/testsuite/gas/all/redef.d
--- binutils-2.25-original/gas/testsuite/gas/all/redef.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/redef.d	2016-02-04 22:02:12.604266754 -0500
@@ -4,5 +4,5 @@
 .*: .*
 
 Contents of section (\.data|\$DATA\$):
- 0000 00000000 0[04]00000[04] 0[08]00000[08] 0[0c]00000[0c][ 	]+................[ 	]*
+ 0000 00000000 00000001 00000002 00000003[ 	]+................[ 	]*
 #pass
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/relax.d binutils-2.25/gas/testsuite/gas/all/relax.d
--- binutils-2.25-original/gas/testsuite/gas/all/relax.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/relax.d	2016-02-05 06:57:26.304026502 -0500
@@ -4,10 +4,10 @@
 .*: .*
 
 Contents of section .*
- 0000 01020381 01000000 00000000 00000000.*
+ 0000 00000001 00000002 00000003 21000000.*
 #...
- 0080 00000004 ffff0500 06078380 01000000.*
+ 0024 00000004 00000005 00000006 00000007.*
+ 0028 81200000 00000000 00000000 00000000.*
 #...
- 4080 00000000 00000000 00000008 ffffffff.*
- 4090 09090909 09090909 09090909 09090909.*
+ 1028 00000000 00000008 00000009 09090909.*
 #pass
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/sleb128-2.d binutils-2.25/gas/testsuite/gas/all/sleb128-2.d
--- binutils-2.25-original/gas/testsuite/gas/all/sleb128-2.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/sleb128-2.d	2016-02-04 22:50:09.189463296 -0500
@@ -4,4 +4,4 @@
 .*: .*
 
 Contents of section (\.data|\$DATA\$):
- .* 7d2a.*
+ .* 7d000000 0000002a.*
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/sleb128-3.d binutils-2.25/gas/testsuite/gas/all/sleb128-3.d
--- binutils-2.25-original/gas/testsuite/gas/all/sleb128-3.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/sleb128-3.d	2016-02-04 22:50:19.297389692 -0500
@@ -4,4 +4,4 @@
 .*: .*
 
 Contents of section (\.data|\$DATA\$):
- .* 9c7f2a.*
+ .* 9c7f0000 0000002a.*
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/sleb128-4.d binutils-2.25/gas/testsuite/gas/all/sleb128-4.d
--- binutils-2.25-original/gas/testsuite/gas/all/sleb128-4.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/sleb128-4.d	2016-02-04 22:50:40.133237967 -0500
@@ -5,4 +5,4 @@
 .*: .*
 
 Contents of section (\.data|\$DATA\$):
- .* 83808080 082a.*
+ .* 83808080 08000000 0000002a.*
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/sleb128-5.d binutils-2.25/gas/testsuite/gas/all/sleb128-5.d
--- binutils-2.25-original/gas/testsuite/gas/all/sleb128-5.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/sleb128-5.d	2016-02-04 22:50:50.381163338 -0500
@@ -4,4 +4,4 @@
 .*: .*
 
 Contents of section (\.data|\$DATA\$):
- .* 012a.*
+ .* 01000000 0000002a.*
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/sleb128-7.d binutils-2.25/gas/testsuite/gas/all/sleb128-7.d
--- binutils-2.25-original/gas/testsuite/gas/all/sleb128-7.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/sleb128-7.d	2016-02-04 22:52:23.972481706 -0500
@@ -4,4 +4,5 @@
 .*: .*
 
 Contents of section (\.data|\$DATA\$):
- .* cb012ac5 012acb01 2ac5012a.*
+ .* cb010000 0000002a c5010000 0000002a.*
+ .* cb010000 0000002a c5010000 0000002a.*
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/sleb128.d binutils-2.25/gas/testsuite/gas/all/sleb128.d
--- binutils-2.25-original/gas/testsuite/gas/all/sleb128.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/sleb128.d	2016-02-04 22:45:46.155378037 -0500
@@ -10,21 +10,22 @@
 # 0x87654321   :           000_1000 0111_011 0_0101_01 00_0011_0 010_0001
 # 0xffffffff   :           ..................................... 111_1111
 #
- 0000 90e4d0b2 07808080 8008a186 95bb08ff .*
+ 0000 90e4d0b2 07000000 80808080 08000000 .*
+ 0004 a18695bb 08000000 ffffffff 0f000000 .*
 #
 # 0xffffffff   :           000_1111 1111_111 1_1111_11 11_1111_1 ........
 # -0x76543210  :           111_1000 1001_101 0_1011_11 00_1101_1 111_0000
 # -0x80000000  :           111_1000 0000_000 0_0000_00 00_0000_0 000_0000
 # -0x87654321  :           ........................... 11_1100_1 101_1111
 #
- 00.. ffffff0f f09bafcd 78808080 8078dff9 .*
+ 0008 f09bafcd 78000000 80808080 78000000 .*
 #
 # -0x87654321  :           111_0111 1000_100 1_1010_10 ..................
 # -0xffffffff  :           111_0000 0000_000 0_0000_00 00_0000_0 000_0001
 #    789abcdef :           111_1000 1001_101 0_1011_11 00_1101_1 110_1111
 # 0x123456     :           ........ 0010_001 1_0100_01 01_0110_0
 #
- 00.. eac47781 80808070 ef9bafcd f8acd191 .*
+ 000c dff9eac4 77000000 81808080 70000000 .*
 #
 # 0x123456     :           000_0001 ............................
 #    789abcdef :           000_0111 0110_010 1_0100_00 11_0010_0 001_0001
@@ -32,7 +33,8 @@
 #    fffffffff :           000_0000 0000_000 0_0000_00 00_0000_0 000_0001
 # -0x7ff       :                             ......... 00_0000_0
 #
- 00.. 0191e4d0 b287d3ae ee7e8180 80808080 .*
+ 0010 ef9bafcd f8acd191 01000000 91e4d0b2 .*
+ 0014 87d3aeee 7e000000 81808080 80806000 .*
 #
 # -0x7ff       :                             1_1000_00 .........
 #    000000000 :           000_0000 0000_000 0_0000_00 00_0000_0 000_0000
@@ -40,18 +42,19 @@
 #    fffffffff :           000_0000 0000_000 0_0000_00 00_0000_0 000_0001
 # -0x7ffffff   : .................. 0000_000 0_0000_00 00_0000_0
 #
- 00.. 60808080 80808060 81808080 80808080 .*
+ 0018 80808080 80806000 81808080 80808080 .*
 #
 # -0x7ffffff   : 11_1111_1 000_0000 ............................
 #    000000000 :           000_0000 0000_000 0_0000_00 00_0000_0 000_0000
 # -0x8000000   : 11_1111_1 000_0000 0000_000 0_0000_00 00_0000_0
 # -0x100000000 :           ........ 0000_000 0_0000_00 00_0000_0 000_0000
 #
- 00.. 807f8080 80808080 8080807f 80808080 .*
+ 00.. 807f0000 80808080 80808080 807f0000 .*
 #
 # -0x100000000 :           111_0000 .....................................
 #    000000000 :           000_0000 0000_000 0_0000_00 00_0000_0 000_0000
 # -0x1000      :                             1_0000_00 00_0000_0
 #
- 00.. 70808080 80808040 00000000 00000000 .*
+ 00.. 80808080 70000000 80808080 80804000 .*
+ 00.. 00000000 00000000 00000000 00000000 .*
 #pass
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/string.d binutils-2.25/gas/testsuite/gas/all/string.d
--- binutils-2.25-original/gas/testsuite/gas/all/string.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/string.d	2016-02-05 07:02:23.441937894 -0500
@@ -4,8 +4,11 @@
 .*: .*
 
 Contents of section (\.data|\$DATA\$):
- 0000 7374726e 65773800 00000000 00000000  strnew8.*
- 00.. (73007400 72003100 36000000 00000000|00730074 00720031 00360000 00000000).*
- 00.. (33000000 32000000 00000000 00000000|00000033 00000032 00000000 00000000).*
- 00.. (36000000 00000000 34000000 00000000|00000000 00000036 00000000 00000034).*
+ 0000 00000073 00000074 00000072 0000006e  ...s...t...r...n
+ 0004 00000065 00000077 00000038 00000000  ...e...w...8....
+ 0008 00000073 00000074 00000072 00000031  ...s...t...r...1
+ 000c 00000036 00000000 00000000 00000000  ...6............
+ 0010 00000033 00000032 00000000 00000000  ...3...2........
+ 0014 00000000 00000036 00000000 00000034  .......6.......4
+ 0018 00000000 00000000.*
 #pass
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/all/struct.d binutils-2.25/gas/testsuite/gas/all/struct.d
--- binutils-2.25-original/gas/testsuite/gas/all/struct.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/all/struct.d	2016-02-04 22:04:56.639045164 -0500
@@ -4,5 +4,5 @@
 # Test the .struct pseudo-op.
 
 0+00 A w1
-0+02 A w2
-0+04 A w3
+0+01 A w2
+0+02 A w3
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/lns/lns.exp binutils-2.25/gas/testsuite/gas/lns/lns.exp
--- binutils-2.25-original/gas/testsuite/gas/lns/lns.exp	2014-10-14 03:32:03.000000000 -0400
+++ binutils-2.25/gas/testsuite/gas/lns/lns.exp	2016-02-04 21:12:13.355418158 -0500
@@ -30,6 +30,7 @@
      && ![istarget mcore-*-*]
      && ![istarget rx-*-*]
      && ![istarget s390*-*-*]
+     && ![istarget zip*]
 } {
     # Use alternate file for targets using DW_LNS_fixed_advance_pc opcodes.
     if {    [istarget xtensa*-*-*]
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/macros/dot.l binutils-2.25/gas/testsuite/gas/macros/dot.l
--- binutils-2.25-original/gas/testsuite/gas/macros/dot.l	2014-10-14 03:32:03.000000000 -0400
+++ binutils-2.25/gas/testsuite/gas/macros/dot.l	2016-02-05 07:32:06.897386485 -0500
@@ -7,11 +7,14 @@
 [ 	]*[1-9][0-9]*[ 	]+>  \.data
 [ 	]*[1-9][0-9]*[ 	]+> labelA:labelB:labelC:labelD:x\.y\.z 4\+2
 [ 	]*[1-9][0-9]*[ 	]+>>  \.balign 4
-[ 	]*[1-9][0-9]*[ 	]+\?+[ 	]+06 ?06[ 	]+>>  \.byte 4\+2,4\+2
+[ 	]*[1-9][0-9]*[ 	]+\?+[ 	]+00000006[ 	]+>>  \.byte 4\+2,4\+2
+[ 	]*[1-9][0-9]*[ 	]+\?*[ 	]+00000006[ ]+
 [ 	]*[1-9][0-9]*[ 	]+\?+[ 	]+00 ?00[ 	]+>  \.skip 2
 [ 	]*[1-9][0-9]*[ 	]+> labelZ:labelY:labelX:labelW:\.xyz 4-2
-[ 	]*[1-9][0-9]*[ 	]+\?+[ 	]+00 ?00 ?00 ?00[ 	]+>>  \.balign 8
-[ 	]*[1-9][0-9]*[ 	]+\?+[ 	]+02 ?02[ 	]+>>  \.byte 4-2,4-2
+[ 	]*[1-9][0-9]*[ 	]+\?+[ 	]+00000000[ 	]+>>  \.balign 8
+[ 	]*[1-9][0-9]*[ 	]+\?*[ 	]+0000[ ]*
+[ 	]*[1-9][0-9]*[ 	]+\?+[ 	]+00000002[ 	]+>>  \.byte 4-2,4-2
+[ 	]*[1-9][0-9]*[ 	]+\?*[ 	]+00000002[ ]+
 [ 	]*[1-9][0-9]*[ 	]+\?+[ 	]+00 ?00 ?00 ?00[ 	]+>  \.skip 4\*2
 [ 	]*[1-9][0-9]*[ 	]+00 ?00 ?00 ?00[ 	]*
 [ 	]*[1-9][0-9]*[ 	]+> label9:label8:label7:label6:
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/macros/irp.d binutils-2.25/gas/testsuite/gas/macros/irp.d
--- binutils-2.25-original/gas/testsuite/gas/macros/irp.d	2014-10-14 03:32:03.000000000 -0400
+++ binutils-2.25/gas/testsuite/gas/macros/irp.d	2016-02-05 07:04:12.705168814 -0500
@@ -8,8 +8,8 @@
 RELOCATION RECORDS FOR .*
 OFFSET[ 	]+TYPE[ 	]+VALUE.*
 0+00[ 	]+[a-zA-Z0-9_]+[ 	]+foo1
-0+04[ 	]+[a-zA-Z0-9_]+[ 	]+foo2
-0+08[ 	]+[a-zA-Z0-9_]+[ 	]+foo3
-0+0c[ 	]+[a-zA-Z0-9_]+[ 	]+bar1
-0+10[ 	]+[a-zA-Z0-9_]+[ 	]+bar2
-0+14[ 	]+[a-zA-Z0-9_]+[ 	]+bar3
+0+01[ 	]+[a-zA-Z0-9_]+[ 	]+foo2
+0+02[ 	]+[a-zA-Z0-9_]+[ 	]+foo3
+0+03[ 	]+[a-zA-Z0-9_]+[ 	]+bar1
+0+04[ 	]+[a-zA-Z0-9_]+[ 	]+bar2
+0+05[ 	]+[a-zA-Z0-9_]+[ 	]+bar3
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/macros/paren.d binutils-2.25/gas/testsuite/gas/macros/paren.d
--- binutils-2.25-original/gas/testsuite/gas/macros/paren.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/macros/paren.d	2016-02-05 07:16:00.860188859 -0500
@@ -5,5 +5,6 @@
 .*: .*
 
 Contents of section .data:
- 0000 01000202 020402.. ........ ........  ................
+ 0000 00000001 00000000 00000002 00000002.*
+ 0004 00000002 00000004 00000002.*
 #pass
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/macros/repeat.d binutils-2.25/gas/testsuite/gas/macros/repeat.d
--- binutils-2.25-original/gas/testsuite/gas/macros/repeat.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/macros/repeat.d	2016-02-05 07:05:38.264566195 -0500
@@ -8,38 +8,38 @@
 RELOCATION RECORDS FOR .*
 OFFSET[ 	]+TYPE[ 	]+VALUE.*
 0+00[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irp_19
-0+04[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irp_18
-0+08[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irp_29
-0+0c[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irp_28
-0+10[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irpc_19
-0+14[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irpc_18
-0+18[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irpc_29
-0+1c[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irpc_28
-0+20[ 	]+[a-zA-Z0-9_]+[ 	]+irp_rept_1
-0+24[ 	]+[a-zA-Z0-9_]+[ 	]+irp_rept_1
-0+28[ 	]+[a-zA-Z0-9_]+[ 	]+irp_rept_2
-0+2c[ 	]+[a-zA-Z0-9_]+[ 	]+irp_rept_2
-0+30[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irp_19
-0+34[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irp_18
-0+38[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irp_29
-0+3c[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irp_28
-0+40[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irpc_19
-0+44[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irpc_18
-0+48[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irpc_29
-0+4c[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irpc_28
-0+50[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_rept_1
-0+54[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_rept_1
-0+58[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_rept_2
-0+5c[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_rept_2
-0+60[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irp_9
-0+64[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irp_8
-0+68[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irp_9
-0+6c[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irp_8
-0+70[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irpc_9
-0+74[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irpc_8
-0+78[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irpc_9
-0+7c[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irpc_8
-0+80[ 	]+[a-zA-Z0-9_]+[ 	]+rept_rept
-0+84[ 	]+[a-zA-Z0-9_]+[ 	]+rept_rept
-0+88[ 	]+[a-zA-Z0-9_]+[ 	]+rept_rept
-0+8c[ 	]+[a-zA-Z0-9_]+[ 	]+rept_rept
+0+01[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irp_18
+0+02[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irp_29
+0+03[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irp_28
+0+04[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irpc_19
+0+05[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irpc_18
+0+06[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irpc_29
+0+07[ 	]+[a-zA-Z0-9_]+[ 	]+irp_irpc_28
+0+08[ 	]+[a-zA-Z0-9_]+[ 	]+irp_rept_1
+0+09[ 	]+[a-zA-Z0-9_]+[ 	]+irp_rept_1
+0+0a[ 	]+[a-zA-Z0-9_]+[ 	]+irp_rept_2
+0+0b[ 	]+[a-zA-Z0-9_]+[ 	]+irp_rept_2
+0+0c[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irp_19
+0+0d[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irp_18
+0+0e[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irp_29
+0+0f[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irp_28
+0+10[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irpc_19
+0+11[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irpc_18
+0+12[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irpc_29
+0+13[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_irpc_28
+0+14[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_rept_1
+0+15[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_rept_1
+0+16[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_rept_2
+0+17[ 	]+[a-zA-Z0-9_]+[ 	]+irpc_rept_2
+0+18[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irp_9
+0+19[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irp_8
+0+1a[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irp_9
+0+1b[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irp_8
+0+1c[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irpc_9
+0+1d[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irpc_8
+0+1e[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irpc_9
+0+1f[ 	]+[a-zA-Z0-9_]+[ 	]+rept_irpc_8
+0+20[ 	]+[a-zA-Z0-9_]+[ 	]+rept_rept
+0+21[ 	]+[a-zA-Z0-9_]+[ 	]+rept_rept
+0+22[ 	]+[a-zA-Z0-9_]+[ 	]+rept_rept
+0+23[ 	]+[a-zA-Z0-9_]+[ 	]+rept_rept
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/macros/rept.d binutils-2.25/gas/testsuite/gas/macros/rept.d
--- binutils-2.25-original/gas/testsuite/gas/macros/rept.d	2014-10-14 03:32:03.000000000 -0400
+++ binutils-2.25/gas/testsuite/gas/macros/rept.d	2016-02-05 07:04:42.844956568 -0500
@@ -8,5 +8,5 @@
 RELOCATION RECORDS FOR .*
 OFFSET[ 	]+TYPE[ 	]+VALUE.*
 0+00[ 	]+[a-zA-Z0-9_]+[ 	]+foo1
-0+04[ 	]+[a-zA-Z0-9_]+[ 	]+foo1
-0+08[ 	]+[a-zA-Z0-9_]+[ 	]+foo1
+0+01[ 	]+[a-zA-Z0-9_]+[ 	]+foo1
+0+02[ 	]+[a-zA-Z0-9_]+[ 	]+foo1
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/macros/semi.d binutils-2.25/gas/testsuite/gas/macros/semi.d
--- binutils-2.25-original/gas/testsuite/gas/macros/semi.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/macros/semi.d	2016-02-05 07:32:56.241037955 -0500
@@ -5,5 +5,5 @@
 .*: .*
 
 Contents of section .text:
- 0000 3b203b20 3a203a20 11111111 11111111  ; ; : : ........
- 0010 11111111 11111111 11111111 11111111  ................
+ 0000 0000003b 00000020 0000003b 00000020  ...;... ...;... 
+ 0004 0000003a 00000020 0000003a 00000020  ...:... ...:... 
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/macros/strings.d binutils-2.25/gas/testsuite/gas/macros/strings.d
--- binutils-2.25-original/gas/testsuite/gas/macros/strings.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/macros/strings.d	2016-02-05 07:11:54.477916649 -0500
@@ -3,5 +3,8 @@
 .*: .*
 
 Contents of section .data:
- 0000 5c22666f 6f5c2200 62617200 62617a(00|  )  \\\"foo\\\".bar.baz(.| )
+ 0000 0000005c 00000022 00000066 0000006f  ...\\...\"...f...o
+ 0004 0000006f 0000005c 00000022 00000062  ...o...\\...\"...b
+ 0008 00000061 00000072 00000062 00000061  ...a...r...b...a
+ 000c 0000007a[ ]*...z.*
 
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/macros/test2.d binutils-2.25/gas/testsuite/gas/macros/test2.d
--- binutils-2.25-original/gas/testsuite/gas/macros/test2.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/macros/test2.d	2016-02-05 07:03:55.221291916 -0500
@@ -8,5 +8,5 @@
 RELOCATION RECORDS FOR .*
 OFFSET[ 	]+TYPE[ 	]+VALUE.*
 0+00[ 	]+[a-zA-Z0-9_]+[ 	]+foo1
-0+04[ 	]+[a-zA-Z0-9_]+[ 	]+foo2
-0+08[ 	]+[a-zA-Z0-9_]+[ 	]+foo3
+0+01[ 	]+[a-zA-Z0-9_]+[ 	]+foo2
+0+02[ 	]+[a-zA-Z0-9_]+[ 	]+foo3
diff -Naur '--exclude=*.swp' binutils-2.25-original/gas/testsuite/gas/macros/vararg.d binutils-2.25/gas/testsuite/gas/macros/vararg.d
--- binutils-2.25-original/gas/testsuite/gas/macros/vararg.d	2013-11-04 10:33:38.000000000 -0500
+++ binutils-2.25/gas/testsuite/gas/macros/vararg.d	2016-02-05 07:06:10.756337260 -0500
@@ -8,8 +8,8 @@
 RELOCATION RECORDS FOR .*
 OFFSET[ 	]+TYPE[ 	]+VALUE.*
 0+00[ 	]+[a-zA-Z0-9_]+[ 	]+foo1
-0+04[ 	]+[a-zA-Z0-9_]+[ 	]+foo2
-0+08[ 	]+[a-zA-Z0-9_]+[ 	]+foo3
-0+0c[ 	]+[a-zA-Z0-9_]+[ 	]+foo4
-0+10[ 	]+[a-zA-Z0-9_]+[ 	]+foo5
-0+14[ 	]+[a-zA-Z0-9_]+[ 	]+foo6
+0+01[ 	]+[a-zA-Z0-9_]+[ 	]+foo2
+0+02[ 	]+[a-zA-Z0-9_]+[ 	]+foo3
+0+03[ 	]+[a-zA-Z0-9_]+[ 	]+foo4
+0+04[ 	]+[a-zA-Z0-9_]+[ 	]+foo5
+0+05[ 	]+[a-zA-Z0-9_]+[ 	]+foo6
diff -Naur '--exclude=*.swp' binutils-2.25-original/include/dis-asm.h binutils-2.25/include/dis-asm.h
--- binutils-2.25-original/include/dis-asm.h	2014-10-14 03:32:04.000000000 -0400
+++ binutils-2.25/include/dis-asm.h	2016-02-21 16:39:11.605527259 -0500
@@ -305,9 +305,11 @@
 extern int print_insn_z8002		(bfd_vma, disassemble_info *);
 extern int print_insn_rx		(bfd_vma, disassemble_info *);
 extern int print_insn_rl78		(bfd_vma, disassemble_info *);
+extern int print_insn_zip		(bfd_vma, disassemble_info *);
 
 extern disassembler_ftype arc_get_disassembler (void *);
 extern disassembler_ftype cris_get_disassembler (bfd *);
+extern disassembler_ftype zip_get_disassembler (bfd *);
 
 extern void print_aarch64_disassembler_options (FILE *);
 extern void print_i386_disassembler_options (FILE *);
diff -Naur '--exclude=*.swp' binutils-2.25-original/include/elf/common.h binutils-2.25/include/elf/common.h
--- binutils-2.25-original/include/elf/common.h	2014-10-14 03:32:04.000000000 -0400
+++ binutils-2.25/include/elf/common.h	2016-02-04 21:12:13.355418158 -0500
@@ -405,6 +405,9 @@
 /* Old constant that might be in use by some software. */
 #define EM_OPENRISC		EM_OR1K
 
+/* */
+#define EM_ZIP			0xdadd
+
 /* See the above comment before you add a new EM_* value here.  */
 
 /* Values for e_version.  */
diff -Naur '--exclude=*.swp' binutils-2.25-original/include/elf/zip.h binutils-2.25/include/elf/zip.h
--- binutils-2.25-original/include/elf/zip.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/include/elf/zip.h	2016-04-19 07:25:33.241829488 -0400
@@ -0,0 +1,74 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Filename: 	zip.h
+//
+// Project:	Zip CPU backend for GNU Binutils
+//
+// Purpose:	
+//
+// Creator:	Dan Gisselquist, Ph.D.
+//		Gisselquist Technology, LLC
+//
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (C) 2016, Gisselquist Technology, LLC
+//
+// This program is free software (firmware): you can redistribute it and/or
+// modify it under the terms of  the GNU General Public License as published
+// by the Free Software Foundation, either version 3 of the License, or (at
+// your option) any later version.
+//
+// This program is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this program.  (It's in the $(ROOT)/doc directory, run make with no
+// target there if the PDF file isn't present.)  If not, see
+// <http://www.gnu.org/licenses/> for a copy.
+//
+// License:	GPL, v3, as defined and found on www.gnu.org,
+//		http://www.gnu.org/licenses/gpl.html
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+#ifndef	_ELF_ZIP_H
+#define	_ELF_ZIP_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocations.  */
+START_RELOC_NUMBERS(elf_zip_reloc_type)
+  RELOC_NUMBER (R_ZIP_NONE,        0)
+  RELOC_NUMBER (R_ZIP_VALUE,       1)
+  RELOC_NUMBER (R_ZIP_OPB_IMM,     2)
+  RELOC_NUMBER (R_ZIP_OPB_OFFSET,  3)
+  RELOC_NUMBER (R_ZIP_OPB_PCREL,   4)
+  RELOC_NUMBER (R_ZIP_OPB_GOTREL,  5)
+  RELOC_NUMBER (R_ZIP_MOV_OFFSET,  6)
+  RELOC_NUMBER (R_ZIP_MOV_PCREL,   7)
+  RELOC_NUMBER (R_ZIP_MOV_GOTREL,  8)
+  RELOC_NUMBER (R_ZIP_LDI,         9)
+  RELOC_NUMBER (R_ZIP_LLO,        10)
+  RELOC_NUMBER (R_ZIP_LHI,        11)
+  RELOC_NUMBER (R_ZIP_BREV       ,12)
+  RELOC_NUMBER (R_ZIP_BROKEN_BYTE,13)
+END_RELOC_NUMBERS(R_ZIP_max)
+
+/* ZIP-CPU Relocation Types */
+  //BFD_RELOC_ZIP_VALUE,		// Place the value of the symbol here
+  //BFD_RELOC_ZIP_OPB_IMM,
+  //BFD_RELOC_ZIP_OPB_OFFSET,
+  //BFD_RELOC_ZIP_OPB_PCREL,
+  //BFD_RELOC_ZIP_OPB_GOTREL,
+  //BFD_RELOC_ZIP_MOV_OFFSET,
+  //BFD_RELOC_ZIP_MOV_GOTREL,
+  //BFD_RELOC_ZIP_LDI,		// Splice in a 23-bit symbol value
+  //BFD_RELOC_ZIP_LHI,		// Splice in a 16-bit (symbol value >> 16)
+  //BFD_RELOC_ZIP_LLO,		// Splice in a 16-bit  symbol value
+  //BFD_RELOC_ZIP_PCREL,
+
+#else
+
+#endif /* _ELF_ZIP_H */
diff -Naur '--exclude=*.swp' binutils-2.25-original/ld/configure.tgt binutils-2.25/ld/configure.tgt
--- binutils-2.25-original/ld/configure.tgt	2014-10-14 03:32:04.000000000 -0400
+++ binutils-2.25/ld/configure.tgt	2016-02-04 21:12:13.355418158 -0500
@@ -770,6 +770,8 @@
 			;;
 z8k-*-coff) 		targ_emul=z8002; targ_extra_emuls=z8001
 			;;
+zip*) 			targ_emul=elf32zip
+			;;
 *-*-ieee*)		targ_emul=vanilla
 			;;
 *-tandem-none)		targ_emul=st2000
diff -Naur '--exclude=*.swp' binutils-2.25-original/ld/emulparams/elf32zip.sh binutils-2.25/ld/emulparams/elf32zip.sh
--- binutils-2.25-original/ld/emulparams/elf32zip.sh	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/ld/emulparams/elf32zip.sh	2016-02-05 14:59:23.300894584 -0500
@@ -0,0 +1,50 @@
+################################################################################
+#
+# Filename:	elf32zip.sh
+#
+# Project:	Zip CPU backend for GNU Binutils
+#
+# Purpose:	This is a simple shell script providing some variables used
+#		later and elsewhere by the ZipCPU linker.  Some things to note
+#	are: 1) the TEXT_START_ADDR is set for the Basys-3 board I am using and
+#	will likely need to change as your platform changes, 2) there currently
+#	aren't any "pages" since the ZipCPU doesn't yet	support a memory
+#	management unit, 3) the ENTRY point only works if a separate loader
+#	is loading the ZipCPU into RAM.  In all other cases, place your startup
+#	code directly at the top of the .start segment, and set the ZipCPU
+#	to run from there.  It'll start then at the first address loaded in
+#	memory.
+#
+# Creator:	Dan Gisselquist, Ph.D.
+#		Gisselquist Technology, LLC
+#
+################################################################################
+#
+# Copyright (C) 2016, Gisselquist Technology, LLC
+#
+# This program is free software (firmware): you can redistribute it and/or
+# modify it under the terms of  the GNU General Public License as published
+# by the Free Software Foundation, either version 3 of the License, or (at
+# your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# License:	GPL, v3, as defined and found on www.gnu.org,
+#		http://www.gnu.org/licenses/gpl.html
+#
+#
+################################################################################
+
+SCRIPT_NAME=elf
+TEMPLATE_NAME=elf32
+ARCH=zip
+OUTPUT_FORMAT="elf32-zip"
+ENTRY="_start"
+TEXT_START_ADDR="0x08000"
+MAXPAGESIZE=0x01000
+COMMONPAGESIZE=0x1000
+EMBEDDED=yes
+
diff -Naur '--exclude=*.swp' binutils-2.25-original/ld/ldlang.c binutils-2.25/ld/ldlang.c
--- binutils-2.25-original/ld/ldlang.c	2014-10-15 03:43:36.000000000 -0400
+++ binutils-2.25/ld/ldlang.c	2016-03-27 22:02:43.913871100 -0400
@@ -4007,7 +4007,7 @@
 	      ++len;
 	    }
 
-	  minfo ("0x%V %W", section->vma, section->size);
+	  minfo ("0x%V %W", section->vma, TO_ADDR(section->size));
 
 	  if (section->vma != section->lma)
 	    minfo (_(" load address 0x%V"), section->lma);
@@ -4385,7 +4385,8 @@
   addr = s->output_offset;
   if (s->output_section != NULL)
     addr += s->output_section->vma;
-  minfo ("0x%V %W ", addr, (bfd_vma) s->size);
+  // FIXME : Need to get rid of these fills
+  minfo ("0x%V %W xx", addr, (bfd_vma) TO_ADDR(s->size));
 
   if (s->fill->size != 0)
     {
@@ -5064,7 +5065,7 @@
 		   create overlapping LMAs.  */
 		if (dot < last->vma
 		    && os->bfd_section->size != 0
-		    && dot + os->bfd_section->size <= last->vma)
+		    && dot + TO_ADDR(os->bfd_section->size) <= last->vma)
 		  {
 		    /* If dot moved backwards then leave lma equal to
 		       vma.  This is the old default lma, which might
@@ -5081,7 +5082,7 @@
 		    /* If this is an overlay, set the current lma to that
 		       at the end of the previous section.  */
 		    if (os->sectype == overlay_section)
-		      lma = last->lma + last->size;
+		      lma = last->lma + TO_ADDR(last->size);
 
 		    /* Otherwise, keep the same lma to vma relationship
 		       as the previous section.  */
diff -Naur '--exclude=*.swp' binutils-2.25-original/ld/Makefile.am binutils-2.25/ld/Makefile.am
--- binutils-2.25-original/ld/Makefile.am	2014-10-14 03:32:04.000000000 -0400
+++ binutils-2.25/ld/Makefile.am	2016-02-04 21:12:13.355418158 -0500
@@ -269,6 +269,7 @@
 	eelf32xc16xs.c \
 	eelf32xstormy16.c \
 	eelf32xtensa.c \
+	eelf32zip.c \
 	eelf_i386.c \
 	eelf_i386_be.c \
 	eelf_i386_chaos.c \
@@ -1252,6 +1253,9 @@
   $(BFDDIR)/elf-bfd.h $(BFDDIR)/libbfd.h $(INCDIR)/elf/xtensa.h \
   $(srcdir)/scripttempl/elfxtensa.sc ${GEN_DEPENDS}
 
+eelf32zip.c: $(srcdir)/emulparams/elf32zip.sh $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
 eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
diff -Naur '--exclude=*.swp' binutils-2.25-original/ld/Makefile.in binutils-2.25/ld/Makefile.in
--- binutils-2.25-original/ld/Makefile.in	2014-10-14 03:32:04.000000000 -0400
+++ binutils-2.25/ld/Makefile.in	2016-02-04 21:12:13.355418158 -0500
@@ -577,6 +577,7 @@
 	eelf32xc16xs.c \
 	eelf32xstormy16.c \
 	eelf32xtensa.c \
+	eelf32zip.c \
 	eelf_i386.c \
 	eelf_i386_be.c \
 	eelf_i386_chaos.c \
@@ -1195,6 +1196,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xc16xs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xstormy16.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xtensa.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32zip.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_aix.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_ia64.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_ia64_fbsd.Po@am__quote@
@@ -2693,6 +2695,9 @@
   $(BFDDIR)/elf-bfd.h $(BFDDIR)/libbfd.h $(INCDIR)/elf/xtensa.h \
   $(srcdir)/scripttempl/elfxtensa.sc ${GEN_DEPENDS}
 
+eelf32zip.c: $(srcdir)/emulparams/elf32zip.sh $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
 eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
diff -Naur '--exclude=*.swp' binutils-2.25-original/ld/scripttempl/elf32zip.sc binutils-2.25/ld/scripttempl/elf32zip.sc
--- binutils-2.25-original/ld/scripttempl/elf32zip.sc	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/ld/scripttempl/elf32zip.sc	2016-02-12 22:17:11.286463743 -0500
@@ -0,0 +1,107 @@
+cat <<EOF
+/*******************************************************************************
+*
+* Filename:	elf32zip.sh
+*
+* Project:	Zip CPU backend for GNU Binutils
+*
+* Purpose:	This script provides for very basic Zip CPU linker
+*		functionality.  However, as I'm writing it, I am realizing that
+*	this script will not be sufficient for the diverse uses of the Zip CPU.
+*	Therefore, I highly recommend everyone that uses the ZipCPU build their
+*	own link scripts--essentially one for each platform they will be working
+*	with.
+*
+*	When doing that, here are some things to consider:
+*
+*	- The ZipCPU starts running at its reset address.  It seems simple to
+*		me to place this at the lowest address in the program code
+*		segment and just start from there.  This is the purpose of the
+*		.start segment below: to make certain that the routine at the
+*		top of that segment gets loaded first.
+*
+*	- Many boards will have multiple diverse memories.  One such memory is
+*		likely to be dependable ROM (FLASH) memory.  If you wish your
+*		program to start when the device starts up, the boot location
+*		and the program will need to be placed into this flash memory.
+*
+*	- On-chip block RAM memory may be available, but if you are loading from
+*		ROM it will be impossible to load into RAM at startup.  On the
+*		otherhand, if your plan is to load from a host-CPU command,
+*		on-chip RAM may be where you wish to place your CPU and code.
+*
+*	- Off-chip SRAM or DRAM may be available.  This may be the ideal place
+*		to run from, being both the fastest memory and (potentially) the
+*		largest.  However, you may need a separate program loader in
+*		flash just to get your program into off-chip SRAM, since nothing
+*		is written to place it there automagically yet.
+*
+*
+* Creator:	Dan Gisselquist, Ph.D.
+*		Gisselquist Technology, LLC
+*
+********************************************************************************
+*
+* Copyright (C) 2016, Gisselquist Technology, LLC
+*
+* This program is free software (firmware): you can redistribute it and/or
+* modify it under the terms of  the GNU General Public License as published
+* by the Free Software Foundation, either version 3 of the License, or (at
+* your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+* for more details.
+*
+* License:	GPL, v3, as defined and found on www.gnu.org,
+*		http://www.gnu.org/licenses/gpl.html
+*
+*
+*******************************************************************************/
+OUTPUT_ARCH(${ARCH})
+OUTPUT_FORMAT(${OUTPUT_FORMAT})
+ENTRY(${ENTRY})
+
+/*
+MEMORY	... for the Cmod S6
+{
+	blkram : ORIGIN = 0x002000, LEN=0x002000
+	flash  : ORIGIN = 0x400000, LEN=0x400000
+}
+*/
+
+/*
+MEMORY	... for the Xess XuLA2-LX25
+{
+	blkram : ORIGIN = 0x002000, LEN=0x002000
+	flash  : ORIGIN = 0x020000, LEN=0x020000
+	sram   : ORIGIN = 0x800000, LEN=0x800000
+}
+*/
+
+/*
+MEMORY	... for the Basys-3 board
+{
+	blkram : ORIGIN = 0x008000, LEN=0x008000
+	flash  : ORIGIN = 0x100000, LEN=0x100000
+}
+*/
+
+/*
+MEMORY	... for the Arty board
+{
+	blkram : ORIGIN = 0x0008000, LEN=0x0008000
+	flash  : ORIGIN = 0x0400000, LEN=0x0400000
+	sram   : ORIGIN = 0x4000000, LEN=0x4000000
+}
+*/
+
+SECTIONS
+{
+  . = ${TEXT_START_ADDRESS}
+  .start : { *(.start) }		/* > flash */
+  .text : { *(.text) *(.strings) }	/* > flash */
+  .data : { *(.data) *(.bss) *(COMMON) }
+}
+EOF
diff -Naur '--exclude=*.swp' binutils-2.25-original/ld/testsuite/lib/ld-lib.exp binutils-2.25/ld/testsuite/lib/ld-lib.exp
--- binutils-2.25-original/ld/testsuite/lib/ld-lib.exp	2014-11-04 04:54:41.000000000 -0500
+++ binutils-2.25/ld/testsuite/lib/ld-lib.exp	2016-02-04 21:12:13.355418158 -0500
@@ -1646,6 +1646,7 @@
 	 && ![istarget spu-*-*]
 	 && ![istarget v850*-*-*]
 	 && ![istarget xstormy16-*-*]
+	 && ![istarget zip-*-*]
 	 && ![istarget *-*-irix*]
 	 && ![istarget *-*-rtems] } {
 	return 1
diff -Naur '--exclude=*.swp' binutils-2.25-original/makdump.txt binutils-2.25/makdump.txt
--- binutils-2.25-original/makdump.txt	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/makdump.txt	2016-02-04 21:12:13.395417836 -0500
@@ -0,0 +1,144 @@
+make[1]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25'
+make[1]: Nothing to be done for `all-target'.
+Configuring in ./opcodes
+make[2]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/intl'
+make[2]: Nothing to be done for `all'.
+make[2]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/intl'
+make[2]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/libiberty'
+make[3]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/libiberty/testsuite'
+make[3]: Nothing to be done for `all'.
+make[3]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/libiberty/testsuite'
+make[2]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/etc'
+make[2]: Nothing to be done for `all'.
+make[2]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/etc'
+make[2]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/libiberty'
+make[2]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd'
+Making info in doc
+make[3]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd/doc'
+configure: loading cache ./config.cache
+make[3]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd/doc'
+Making info in po
+checking build system type... make[3]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd/po'
+make[3]: Nothing to be done for `info'.
+make[3]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd/po'
+x86_64-unknown-linux-gnu
+checking host system type... x86_64-unknown-linux-gnu
+checking target system type... zip-unknown-none
+checking for x86_64-unknown-linux-gnu-gcc... gcc
+make[3]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd'
+make[3]: Nothing to be done for `info-am'.
+make[3]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd'
+make  all-recursive
+checking for C compiler default output file name... make[3]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd'
+Making all in doc
+make[4]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd/doc'
+make[4]: Nothing to be done for `all'.
+make[4]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd/doc'
+Making all in po
+a.out
+checking whether the C compiler works... make[4]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd/po'
+make[4]: Nothing to be done for `all'.
+make[4]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd/po'
+yes
+checking whether we are cross compiling... no
+checking for suffix of executables... 
+checking for suffix of object files... make[4]: Entering directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd'
+make[4]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd'
+make[3]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd'
+make[2]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25/bfd'
+o
+checking whether we are using the GNU C compiler... yes
+checking whether gcc accepts -g... yes
+checking for gcc option to accept ISO C89... none needed
+checking for library containing strerror... none required
+checking for a BSD-compatible install... /usr/bin/install -c
+checking whether build environment is sane... yes
+checking for a thread-safe mkdir -p... /bin/mkdir -p
+checking for gawk... gawk
+checking whether make sets $(MAKE)... yes
+checking for style of include used by make... GNU
+checking dependency style of gcc... gcc3
+checking for x86_64-unknown-linux-gnu-gcc... (cached) gcc
+checking whether we are using the GNU C compiler... (cached) yes
+checking whether gcc accepts -g... (cached) yes
+checking for gcc option to accept ISO C89... (cached) none needed
+checking how to run the C preprocessor... gcc -E
+checking for grep that handles long lines and -e... /bin/grep
+checking for egrep... /bin/grep -E
+checking for ANSI C header files... yes
+checking for sys/types.h... yes
+checking for sys/stat.h... yes
+checking for stdlib.h... yes
+checking for string.h... yes
+checking for memory.h... yes
+checking for strings.h... yes
+checking for inttypes.h... yes
+checking for stdint.h... yes
+checking for unistd.h... yes
+checking minix/config.h usability... no
+checking minix/config.h presence... no
+checking for minix/config.h... no
+checking whether it is safe to define __EXTENSIONS__... yes
+checking for x86_64-unknown-linux-gnu-ar... ar
+checking for x86_64-unknown-linux-gnu-ranlib... ranlib
+checking how to print strings... printf
+checking for a sed that does not truncate output... /bin/sed
+checking for fgrep... /bin/grep -F
+checking for ld used by gcc... ld
+checking if the linker (ld) is GNU ld... yes
+checking for BSD- or MS-compatible name lister (nm)... nm
+checking the name lister (nm) interface... BSD nm
+checking whether ln -s works... yes
+checking the maximum length of command line arguments... 3458764513820540925
+checking whether the shell understands some XSI constructs... yes
+checking whether the shell understands "+="... yes
+checking for ld option to reload object files... -r
+checking for x86_64-unknown-linux-gnu-objdump... objdump
+checking how to recognize dependent libraries... pass_all
+checking for x86_64-unknown-linux-gnu-ar... (cached) ar
+checking for x86_64-unknown-linux-gnu-strip... no
+checking for strip... strip
+checking for x86_64-unknown-linux-gnu-ranlib... (cached) ranlib
+checking command to parse nm output from gcc object... ok
+checking for dlfcn.h... yes
+checking for objdir... .libs
+checking if gcc supports -fno-rtti -fno-exceptions... no
+checking for gcc option to produce PIC... -fPIC -DPIC
+checking if gcc PIC flag -fPIC -DPIC works... yes
+checking if gcc static flag -static works... yes
+checking if gcc supports -c -o file.o... yes
+checking if gcc supports -c -o file.o... (cached) yes
+checking whether the gcc linker (ld -m elf_x86_64) supports shared libraries... yes
+checking dynamic linker characteristics... GNU/Linux ld.so
+checking how to hardcode library paths into programs... immediate
+checking whether stripping libraries is possible... yes
+checking if libtool supports shared libraries... yes
+checking whether to build shared libraries... no
+checking whether to build static libraries... yes
+Setting warning flags = -W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow
+checking whether gcc supports -Wmissing-field-initializers... yes
+checking whether to enable maintainer-specific portions of Makefiles... no
+checking whether to install libbfd... no
+checking whether NLS is requested... yes
+checking for catalogs to be installed...  da de es fi fr ga id it nl pt_BR ro sv tr uk vi zh_CN da de es fi fr ga id it nl pt_BR ro sv tr uk vi zh_CN
+checking whether NLS is requested... yes
+checking for msgfmt... /usr/bin/msgfmt
+checking for gmsgfmt... /usr/bin/msgfmt
+checking for xgettext... /usr/bin/xgettext
+checking for msgmerge... /usr/bin/msgmerge
+checking for string.h... (cached) yes
+checking for strings.h... (cached) yes
+checking for stdlib.h... (cached) yes
+checking limits.h usability... yes
+checking limits.h presence... yes
+checking for limits.h... yes
+checking whether string.h and strings.h may both be included... yes
+checking whether basename is declared... yes
+checking whether stpcpy is declared... yes
+checking for sigsetjmp... 
+checking linker --as-needed support... yes
+checking for cos in -lm... yes
+configure: error: *** unknown target architecture bfd_zip_arch
+make[1]: *** [configure-opcodes] Error 1
+make[1]: Leaving directory `/home/dan/work/rnd/zipcpu/sw/binutils-2.25'
+make: *** [all] Error 2
diff -Naur '--exclude=*.swp' binutils-2.25-original/opcodes/configure binutils-2.25/opcodes/configure
--- binutils-2.25-original/opcodes/configure	2014-12-23 09:22:07.000000000 -0500
+++ binutils-2.25/opcodes/configure	2016-02-04 21:12:15.387401820 -0500
@@ -12634,6 +12634,7 @@
 	bfd_xtensa_arch)	ta="$ta xtensa-dis.lo" ;;
 	bfd_z80_arch)		ta="$ta z80-dis.lo" ;;
 	bfd_z8k_arch)		ta="$ta z8k-dis.lo" ;;
+	bfd_zip_arch)		ta="$ta zip-dis.lo zip-opc.lo" ;;
 
 	"")			;;
 	*)		as_fn_error "*** unknown target architecture $arch" "$LINENO" 5 ;;
diff -Naur '--exclude=*.swp' binutils-2.25-original/opcodes/configure.ac binutils-2.25/opcodes/configure.ac
--- binutils-2.25-original/opcodes/configure.ac	2014-10-14 03:32:04.000000000 -0400
+++ binutils-2.25/opcodes/configure.ac	2016-02-04 21:12:15.391401789 -0500
@@ -351,6 +351,7 @@
 	bfd_xtensa_arch)	ta="$ta xtensa-dis.lo" ;;
 	bfd_z80_arch)		ta="$ta z80-dis.lo" ;;
 	bfd_z8k_arch)		ta="$ta z8k-dis.lo" ;;
+	bfd_zip_arch)		ta="$ta zip-dis.lo zip-opc.lo" ;;
 
 	"")			;;
 	*)		AC_MSG_ERROR(*** unknown target architecture $arch) ;;
diff -Naur '--exclude=*.swp' binutils-2.25-original/opcodes/disassemble.c binutils-2.25/opcodes/disassemble.c
--- binutils-2.25-original/opcodes/disassemble.c	2014-10-14 03:32:04.000000000 -0400
+++ binutils-2.25/opcodes/disassemble.c	2016-02-04 21:12:15.391401789 -0500
@@ -96,6 +96,7 @@
 #define ARCH_xtensa
 #define ARCH_z80
 #define ARCH_z8k
+#define ARCH_zip
 #define INCLUDE_SHMEDIA
 #endif
 
@@ -488,6 +489,11 @@
 	disassemble = print_insn_z8002;
       break;
 #endif
+#ifdef ARCH_zip
+    case bfd_arch_zip:
+      disassemble = zip_get_disassembler(abfd);
+      break;
+#endif
 #ifdef ARCH_vax
     case bfd_arch_vax:
       disassemble = print_insn_vax;
diff -Naur '--exclude=*.swp' binutils-2.25-original/opcodes/Makefile.am binutils-2.25/opcodes/Makefile.am
--- binutils-2.25-original/opcodes/Makefile.am	2014-10-14 03:32:04.000000000 -0400
+++ binutils-2.25/opcodes/Makefile.am	2016-02-04 21:12:15.391401789 -0500
@@ -265,7 +265,8 @@
 	xgate-dis.c \
 	xgate-opc.c \
 	z80-dis.c \
-	z8k-dis.c
+	z8k-dis.c \
+	zip-dis.c
 
 # C source files that correspond to .o's ending up in libopcodes.
 LIBOPCODES_CFILES = \
@@ -603,6 +604,9 @@
 
 z8k-dis.lo: $(srcdir)/z8k-opc.h
 
+zip-dis.lo: $(srcdir)/zip-opc.h $(srcdir)/zip-dis.h config.h $(srcdir)/zip-dis.c
+zip-opc.lo: $(srcdir)/zip-opc.h $(srcdir)/zip-opc.c
+
 sh-dis.lo: sh-dis.c
 if am__fastdepCC
 	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ @archdefs@ $(srcdir)/sh-dis.c
diff -Naur '--exclude=*.swp' binutils-2.25-original/opcodes/Makefile.in binutils-2.25/opcodes/Makefile.in
--- binutils-2.25-original/opcodes/Makefile.in	2014-10-14 03:32:04.000000000 -0400
+++ binutils-2.25/opcodes/Makefile.in	2016-02-04 21:12:15.391401789 -0500
@@ -358,7 +358,8 @@
 	w65-opc.h \
 	xc16x-desc.h xc16x-opc.h \
 	xstormy16-desc.h xstormy16-opc.h \
-	z8k-opc.h
+	z8k-opc.h \
+	zip-opc.h zip-dis.h
 
 
 # C source files that correspond to .o's ending up in libopcodes
@@ -538,7 +539,9 @@
 	xgate-dis.c \
 	xgate-opc.c \
 	z80-dis.c \
-	z8k-dis.c
+	z8k-dis.c \
+	zip-op.c \
+	zip-dis.c
 
 
 # C source files that correspond to .o's ending up in libopcodes.
@@ -939,6 +942,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xtensa-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/z80-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/z8k-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/zip-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/zip-opc.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -1465,6 +1470,9 @@
 
 z8k-dis.lo: $(srcdir)/z8k-opc.h
 
+zip-dis.lo: $(srcdir)/zip-opc.h $(srcdir)/zip-dis.h config.h $(srcdir)/zip-dis.c
+zip-opc.lo: $(srcdir)/zip-opc.h $(srcdir)/zip-opc.c
+
 sh-dis.lo: sh-dis.c
 @am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ @archdefs@ $(srcdir)/sh-dis.c
 @am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
diff -Naur '--exclude=*.swp' binutils-2.25-original/opcodes/zip-dis.c binutils-2.25/opcodes/zip-dis.c
--- binutils-2.25-original/opcodes/zip-dis.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/opcodes/zip-dis.c	2016-04-20 19:51:51.082018704 -0400
@@ -0,0 +1,291 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Filename: 	zip-dis.c
+//
+// Project:	Zip CPU backend for GNU Binutils
+//
+// Purpose:	
+//
+// Creator:	Dan Gisselquist, Ph.D.
+//		Gisselquist Technology, LLC
+//
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (C) 2016, Gisselquist Technology, LLC
+//
+// This program is free software (firmware): you can redistribute it and/or
+// modify it under the terms of  the GNU General Public License as published
+// by the Free Software Foundation, either version 3 of the License, or (at
+// your option) any later version.
+//
+// This program is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this program.  (It's in the $(ROOT)/doc directory, run make with no
+// target there if the PDF file isn't present.)  If not, see
+// <http://www.gnu.org/licenses/> for a copy.
+//
+// License:	GPL, v3, as defined and found on www.gnu.org,
+//		http://www.gnu.org/licenses/gpl.html
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+#include "config.h"
+
+#include <stdio.h>
+#include <stdint.h>
+#include <ctype.h>
+#include <strings.h>
+#include <string.h>
+#include <assert.h>
+
+#include "zip-opc.h"
+#include "zip-dis.h"
+
+static inline	int
+TWOWORD_LOAD(uint32_t one, uint32_t two) {
+	if (((one&0x87c40000)==0x03000000)&&((two&0x87c40000)==0x02400000)
+		&&(((one^two)&0xf8380000)==0))
+		return 1;
+#ifdef	LONG_MPY
+	return 0;
+#else
+	return (((one&0x87c40000)==0x02000000)&&((two&0x87c40000)==0x02400000)
+		&&(((one^two)&0xf8380000)==0))?1:0;
+#endif
+}
+
+static uint32_t
+zip_bitreverse(uint32_t v) {
+	uint32_t r=0, b;
+	for(b=0; b<32; b++, v>>=1)
+		r = (r<<1)|(v&1);
+	return r;
+}
+
+static inline	uint32_t
+TWOWORD_VALUE(uint32_t one, uint32_t two) {
+#ifdef	LONG_MPY
+	return ((two&0x0ffff)|(zip_bitreverse(one&0x0ffff)));
+#else
+	if ((one&0x87c40000)==0x03000000)
+		return ((two&0x0ffff)|(zip_bitreverse(one&0x0ffff)));
+	else
+		return (two&0x0ffff)|((one&0x0ffff)<<16);
+#endif
+}
+
+static long
+zip_sbits(const long val, const int bits) {
+	long	r;
+
+	r = val & ((1l<<bits)-1);
+	if (r & (1l << (bits-1)))
+		r |= (-1l << bits);
+	return r;
+}
+
+static unsigned long
+zip_ubits(const long val, const int bits) {
+	unsigned long r = val & ((1l<<bits)-1);
+	return r;
+}
+
+static	int
+zip_getbits(const ZIPI ins, const int which)
+{
+	if (which & 0x40000000) {
+		return zip_sbits(ins>>(which & 0x03f), (which>>8)&0x03f);
+	} else { // if (which &0x03f)
+		return zip_ubits(ins>>(which & 0x03f), (which>>8)&0x03f)
+			+ ((which>>16)&0x0ff);
+	}
+}
+
+static	void
+zipi_to_halfstring(const uint32_t addr, const ZIPI ins, const ZIPI nxtword, char *line, const ZOPCODE *listp, uint32_t *refaddr)
+{
+	*refaddr = 0;
+
+	if ((TWOWORD_LOAD(ins,nxtword))&&(listp==zip_oplist)) {
+		int cv = zip_getbits(ins, ZIP_BITFIELD(3,19));
+		int dv = zip_getbits(ins, ZIP_REGFIELD(27));
+		
+		sprintf(line, "%s%s", "LDI", zip_ccstr[cv]);
+		sprintf(line, "%-11s", line);
+		sprintf(line, "%s0x%08x", line, TWOWORD_VALUE(ins,nxtword));
+		sprintf(&line[strlen(line)], ",%s", zip_regstr[dv]);
+
+		*refaddr = TWOWORD_VALUE(ins,nxtword);
+		return;
+	}
+
+	int	i;
+	for(i=0; i<nzip_oplist; i++) {
+		if (((~zip_oplist[i].s_mask)&zip_oplist[i].s_val)!=0) {
+			printf("Instruction %d, %s, fails consistency check\n",
+				i, zip_oplist[i].s_opstr);
+			printf("%08x & %08x = %08x != %08x\n",
+				zip_oplist[i].s_mask,
+				zip_oplist[i].s_val,
+				(~zip_oplist[i].s_mask)&zip_oplist[i].s_val,
+				0);
+			assert(((~zip_oplist[i].s_mask)&zip_oplist[i].s_val)==0);
+		}
+	} line[0] = '\0';
+	for(i=0; (listp[i].s_mask != 0); i++) {
+		// printf("%2d: %6s %08x & %08x == %08x\n",
+			// i, zip_oplist[i].s_opstr, ins,
+			// zip_oplist[i].s_mask, zip_oplist[i].s_val);
+		if ((ins & listp[i].s_mask) == listp[i].s_val) {
+			// Write the opcode onto our line
+			sprintf(line, "%s", listp[i].s_opstr);
+			if (listp[i].s_cf != ZIP_OPUNUSED) {
+				int bv = zip_getbits(ins, listp[i].s_cf);
+				strcat(line, zip_ccstr[bv]);
+			} sprintf(line, "%-11s", line); // Pad it to 11 chars
+
+			// Treat stores special
+			if (strncasecmp("STO",listp[i].s_opstr, 3)==0) {
+				int ra = zip_getbits(ins, listp[i].s_ra);
+				strcat(line, zip_regstr[ra]);
+				strcat(line, ",");
+					
+				if (listp[i].s_i != ZIP_OPUNUSED) {
+					int	imv = 0;
+					imv = zip_getbits(ins, listp[i].s_i);
+					if ((imv != 0)&&(listp[i].s_rb != ZIP_OPUNUSED))
+						sprintf(&line[strlen(line)],
+							"$%d", imv);
+					else if (imv != 0)
+						sprintf(&line[strlen(line)],
+							"($%d)", imv);
+				} if (listp[i].s_rb != ZIP_OPUNUSED) {
+					int rb = zip_getbits(ins, listp[i].s_rb);
+					sprintf(&line[strlen(line)],
+						"(%s)", zip_regstr[rb]);
+				}
+			// Treat long jumps special
+			} else if (strncasecmp("LJMP",listp[i].s_opstr, 3)==0) {
+				sprintf(&line[strlen(line)], "@0x%08x", nxtword);
+				*refaddr = nxtword;
+			// Treat relative jumps (branches) specially as well
+			} else if ((toupper(listp[i].s_opstr[0]=='B'))
+				&&(strcasecmp(listp[i].s_opstr,"BUSY")!=0)
+				&&(strcasecmp(listp[i].s_opstr,"BREV")!=0)
+				&&(strcasecmp(listp[i].s_opstr,"BRK")!=0)
+				&&(addr != 0)) {
+				// Branch instruction: starts with B and isn't
+				// BREV (bit reverse), BRK (break), or 
+				// BUSY
+				uint32_t target = addr;
+
+				target += zip_getbits(ins, listp[i].s_i)+1;
+				sprintf(&line[strlen(line)], "@0x%08x", target);
+				*refaddr = target;
+			} else {
+				int memop = (strncasecmp("LOD",
+						listp[i].s_opstr, 3)==0) ? 1:0;
+				if (listp[i].s_i != ZIP_OPUNUSED) {
+					int	imv = 0;
+
+					imv = zip_getbits(ins, listp[i].s_i);
+					if((memop)&&(listp[i].s_rb == ZIP_OPUNUSED))
+						sprintf(&line[strlen(line)],
+							"($%d)", imv);
+					else if((memop)&&(imv != 0))
+						sprintf(&line[strlen(line)],
+							"%d", imv);
+					else if((!memop)&&((imv != 0)||(listp[i].s_rb == ZIP_OPUNUSED)))
+						sprintf(&line[strlen(line)],
+							"$%d%s", imv,
+							(listp[i].s_rb!=ZIP_OPUNUSED)?"+":"");
+				} if (listp[i].s_rb != ZIP_OPUNUSED) {
+					int rb = zip_getbits(ins, listp[i].s_rb);
+					if (memop)
+						sprintf(&line[strlen(line)],
+							"(%s)", zip_regstr[rb]);
+					else
+						strcat(line, zip_regstr[rb]);
+				} if(((listp[i].s_i != ZIP_OPUNUSED)||(listp[i].s_rb != ZIP_OPUNUSED))
+					&&((listp[i].s_ra != ZIP_OPUNUSED)||(listp[i].s_result != ZIP_OPUNUSED)))
+					strcat(line, ",");
+
+				if (listp[i].s_ra != ZIP_OPUNUSED) {
+					int ra = zip_getbits(ins, listp[i].s_ra);
+					strcat(line, zip_regstr[ra]);
+				} else if (listp[i].s_result != ZIP_OPUNUSED) {
+					int ra = zip_getbits(ins, listp[i].s_result);
+					strcat(line, zip_regstr[ra]);
+				}
+					
+			}
+			break;
+		}
+	} if (line[0] == '\0') {
+		sprintf(line, "ILL %08x", ins);
+	}
+}
+
+static void
+zipi_to_double_string(const uint32_t addr, const ZIPI ins, const ZIPI nxtword, char *la, char *lb, uint32_t *refaddr) {
+	zipi_to_halfstring(addr, ins, nxtword, la, zip_oplist, refaddr);
+	if (lb) {
+		if (ins & 0x80000000) {
+			zipi_to_halfstring(addr, ins, nxtword, lb, zip_opbottomlist, refaddr);
+			*refaddr = 0;
+		} else lb[0] = '\0';
+	}
+}
+
+static int
+print_zip_insn(bfd_vma vma, disassemble_info *info)
+{
+	ZIPI	iword, nxtword;
+	char	astr[80], bstr[80];
+	unsigned char ibytes[8];
+	uint32_t	refaddr;
+
+	(*info->read_memory_func)(vma, ibytes, 8, info);
+	iword  = (ibytes[0]<<24)|(ibytes[1]<<16)|(ibytes[2]<<8)|(ibytes[3]);
+	nxtword= (ibytes[4]<<24)|(ibytes[5]<<16)|(ibytes[6]<<8)|(ibytes[7]);
+	zipi_to_double_string(vma, iword, nxtword, astr, bstr, &refaddr);
+
+	if (bstr[0])
+		(*info->fprintf_func)(info->stream, "%-25s | %-25s", astr, bstr);
+	else
+		(*info->fprintf_func)(info->stream, "%s", astr);
+
+	if ((info->print_address_func)&&(refaddr != 0)) {
+		(*info->fprintf_func)(info->stream, "\t// ");
+		(*info->print_address_func)(refaddr, info);
+	}
+
+	// Normal LOD (PC),PC = 0x7c87c000
+	//	1'b0, 4'hf, 5'h12, 3'h0, 1'b1, 4'hf, 14'h00
+	//	0111 1100 1000 0111 1100 0000 0000 0000
+	// or VLIW  x | LOD (PC),PC
+	//	1'b1, 4'hx 5'hx 1'b0 2'bx 5'hx 4'hf 5'h12 1'b1 4'hf
+	//	1xxx xxxx xx0x xxxx xx11 1110 0101 1111
+	//	0x80203fff mask, val = 0x80003e5f
+	if ((iword == 0x7c87c000)||((iword&0x80203fff)==0x80003e5f))
+		return 8;
+	// Two word load: Destination registers and conditional execution bits
+	// must match as well.
+	if (TWOWORD_LOAD(iword,nxtword))
+		return 8;
+	if ((iword&0xffc7ffff)==0x7c87c001) // Conditional long jump
+		return 12; // LOD.C 1(PC),PC, BRA 1+PC, @ADDRESS
+	return 4;
+}
+
+
+disassembler_ftype
+zip_get_disassembler(bfd *abfd ATTRIBUTE_UNUSED)
+{
+	return print_zip_insn;
+}
+
diff -Naur '--exclude=*.swp' binutils-2.25-original/opcodes/zip-dis.h binutils-2.25/opcodes/zip-dis.h
--- binutils-2.25-original/opcodes/zip-dis.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/opcodes/zip-dis.h	2016-02-04 21:33:12.945457256 -0500
@@ -0,0 +1,45 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Filename: 	zip-dis.h
+//
+// Project:	Zip CPU backend for GNU Binutils
+//
+// Purpose:	
+//
+// Creator:	Dan Gisselquist, Ph.D.
+//		Gisselquist Technology, LLC
+//
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (C) 2016, Gisselquist Technology, LLC
+//
+// This program is free software (firmware): you can redistribute it and/or
+// modify it under the terms of  the GNU General Public License as published
+// by the Free Software Foundation, either version 3 of the License, or (at
+// your option) any later version.
+//
+// This program is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this program.  (It's in the $(ROOT)/doc directory, run make with no
+// target there if the PDF file isn't present.)  If not, see
+// <http://www.gnu.org/licenses/> for a copy.
+//
+// License:	GPL, v3, as defined and found on www.gnu.org,
+//		http://www.gnu.org/licenses/gpl.html
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+#ifndef	ZIP_DIS_H
+#define	ZIP_DIS_H
+
+#include "config.h"
+#include "dis-asm.h"
+
+extern disassembler_ftype
+zip_get_disassembler(bfd *abfd);
+
+#endif
diff -Naur '--exclude=*.swp' binutils-2.25-original/opcodes/zip-opc.c binutils-2.25/opcodes/zip-opc.c
--- binutils-2.25-original/opcodes/zip-opc.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/opcodes/zip-opc.c	2016-04-19 09:12:35.702319550 -0400
@@ -0,0 +1,550 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Filename: 	zip-opc.c
+//
+// Project:	Zip CPU backend for GNU Binutils
+//
+// Purpose:	
+//
+// Creator:	Dan Gisselquist, Ph.D.
+//		Gisselquist Technology, LLC
+//
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (C) 2016, Gisselquist Technology, LLC
+//
+// This program is free software (firmware): you can redistribute it and/or
+// modify it under the terms of  the GNU General Public License as published
+// by the Free Software Foundation, either version 3 of the License, or (at
+// your option) any later version.
+//
+// This program is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this program.  (It's in the $(ROOT)/doc directory, run make with no
+// target there if the PDF file isn't present.)  If not, see
+// <http://www.gnu.org/licenses/> for a copy.
+//
+// License:	GPL, v3, as defined and found on www.gnu.org,
+//		http://www.gnu.org/licenses/gpl.html
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+#include "zip-opc.h"
+
+const	char	*zip_regstr[49] = {
+	"R0", "R1", "R2", "R3",
+	"R4", "R5", "R6", "R7",
+	"R8", "R9", "R10","R11",
+	"R12","SP", "CC", "PC",
+	"uR0", "uR1", "uR2", "uR3",
+	"uR4", "uR5", "uR6", "uR7",
+	"uR8", "uR9", "uR10", "uR11",
+	"uR12", "uSP", "uCC", "uPC",
+	"sR0", "sR1", "sR2", "sR3",
+	"sR4", "sR5", "sR6", "sR7",
+	"sR8", "sR9", "sR10","sR11",
+	"sR12","sSP", "sCC", "sPC", "ILL"
+};
+
+const	char	*zip_ccstr[8] = {
+	"", ".LT", ".Z", ".NZ", ".GT", ".GE", ".C", ".V"
+};
+
+static const ZOPCODE	zip_oplist_raw[] = {
+	// Special case instructions.  These are general instructions, but with
+	// special opcodes
+	// Conditional branches
+	//	0.1111.0111.ccc.0.111.10iiiii--
+	//	0111 1011 11cc c011 110i iiii iiii iiii
+	{ "BUSY", 0xffc7ffff, 0x7bc3dfff, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "BRA",  0xfffc0000, 0x78800000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_OPUNUSED },
+	{ "BLT",  0xfffc0000, 0x78880000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_OPUNUSED },
+	{ "BZ",  0xfffc0000, 0x78900000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_OPUNUSED },
+	{ "BNZ",  0xfffc0000, 0x78980000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_OPUNUSED },
+	{ "BGT",  0xfffc0000, 0x78a00000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_OPUNUSED },
+	{ "BGE",  0xfffc0000, 0x78a80000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_OPUNUSED },
+	{ "BC",  0xfffc0000, 0x78b00000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_OPUNUSED },
+	{ "BRV",  0xfffc0000, 0x78b80000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_OPUNUSED },
+	// CLRF ... an XOR w/ self instruction
+	//	0.rrrr.00100.ccc.1.rrrr.iiiii---
+	//	0rrr r001 00cc c1rr rr00 0000 0000 0000
+	{ "CLRF", 0xffc7cfff, 0x01040000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x09044000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x11048000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x1904c000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x21050000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x29054000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x31058000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x3905c000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x41060000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x49064000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x51068000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x5906c000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x61070000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x69074000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x71078000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "CLRF", 0xffc7cfff, 0x7907c000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	// CLR -- a LDI of zero
+	//	0.rrrr.1011.iiiiiii--
+	//	0rrr r101 1...
+	{ "CLR",  0x87ffffff, 0x05800000, ZIP_REGFIELD(27),ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED },
+	// HALT
+	//	0.1110.00011.ccc.0.0000000000010
+	//	0111.0000.11cc.c000.0000.0000.0000.0010
+	{ "HALT", 0xffc7ffff, 0x70c00010, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	// The "wait" instruction is identical, with the only difference being
+	// the interrrupt context of the processor.  Well, almost.  To
+	// facilitate waits from supervisor mode, the wait instruction
+	// explicitly forces the CPU into user mode.
+	{ "WAIT", 0xffc7ffff, 0x70c00030, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	//
+	// "INT", 0xff10007f, 0x9e00005f, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19),
+	// Return to user space
+	{ "RTU", 0xffc7ffff, 0x70c00020, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	// JMP (possibly a conditional jump, if not covered by branches above)
+	// 0.1111.01111.ccc.a.rrrr.biiiiiiiiiiiiiiii
+	// 0111.1011.11cc.c0rr.rrbi.iiii.iiii.iiii		MOV x,PC
+	{ "JMP",  0xffc40000, 0x7bc00000, ZIP_OPUNUSED,ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_IMMFIELD(13,0), ZIP_BITFIELD(3,19) },
+	// 0.1111.1011.ii.iiii.iiii.iiii.iiii.iiii.iiii
+	// 0111.1101.1iii.iiii.iiii.iiii.iiii.iiii		LDI x,PC
+	{ "JMP",  0xff800000, 0x7d800000, ZIP_REGFIELD(27),ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(23,0), ZIP_OPUNUSED },
+	// 0.1111.10010.000.1.1111.000000000000000
+	// 0111.1100.10cc.c111.11ii.iiii.iiii.iiii		LOD (PC),PC
+	{ "LJMP",	0xffffffff, 0x7c87c000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "LJMP",	0xffc7ffff, 0x7c87c001, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) }, // Conditional long jump, LOD.X 1(PC),PC
+	// NOT : XOR w/ -1
+	//	0.rrrr.00100.ccc.0111.11111111111
+	//	0rrr.r001.00cc.c011.f.f.f.f
+	{ "NOT", 0x87c7ffff, 0x0103ffff, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	// General instructions
+	// 0rrr.rooo.oocc.cxrr.rrii.iiii.iiii.iiii
+	{ "SUB", 0x87c40000, 0x00000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "SUB", 0x87c40000, 0x00040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "AND", 0x87c40000, 0x00400000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "AND", 0x87c40000, 0x00440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "ADD", 0x87c40000, 0x00800000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "ADD", 0x87c40000, 0x00840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "OR",	0x87c40000, 0x00c00000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "OR",	0x87c40000, 0x00c40000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "XOR", 0x87c40000, 0x01000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "XOR", 0x87c40000, 0x01040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "LSR", 0x87c40000, 0x01400000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "LSR", 0x87c40000, 0x01440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "LSL", 0x87c40000, 0x01800000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "LSL", 0x87c40000, 0x01840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "ASR", 0x87c40000, 0x01c00000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "ASR", 0x87c40000, 0x01c40000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+#ifdef	LONG_MPY
+	{ "MPY",0x87c40000, 0x02000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "MPY",0x87c40000, 0x02040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+#else
+	{ "LDIHI",0x87c40000, 0x02000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "LDIHI",0x87c40000, 0x02040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+#endif
+	//
+	{ "LDILO",0x87c40000, 0x02400000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "LDILO",0x87c40000, 0x02440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+#ifdef	LONG_MPY
+	//
+	{ "MPYUHI", 0x87c40000, 0x02800000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "MPYUHI", 0x87c40000, 0x02840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "MPYSHI", 0x87c40000, 0x02c00000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "MPYSHI", 0x87c40000, 0x02c40000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+#else
+	//
+	{ "MPYU", 0x87c40000, 0x02800000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "MPYU", 0x87c40000, 0x02840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "MPYS", 0x87c40000, 0x02c00000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "MPYS", 0x87c40000, 0x02c40000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+#endif
+	//
+	{ "BREV", 0x87c40000, 0x03000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "BREV", 0x87c40000, 0x03040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "POPC", 0x87c40000, 0x03400000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "POPC", 0x87c40000, 0x03440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "ROL", 0x87c40000, 0x03800000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "ROL", 0x87c40000, 0x03840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	// map bit = 1 (interrupts enabled) specifies user reg
+	// 0rrr.rooo.oocc.cxrr.rrxi.iiii.iiii.iiii
+	{ "MOV",  0x87c42000, 0x03c00000, ZIP_REGFIELD(27),ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_IMMFIELD(13,0), ZIP_BITFIELD(3,19) },
+	{ "MOV",  0x87c42000, 0x03c40000, ZIP_URGFIELD(27),ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_IMMFIELD(13,0), ZIP_BITFIELD(3,19) },
+	{ "MOV",  0x87c42000, 0x03c02000, ZIP_REGFIELD(27),ZIP_OPUNUSED, ZIP_URGFIELD(14), ZIP_IMMFIELD(13,0), ZIP_BITFIELD(3,19) },
+	{ "MOV",  0x87c42000, 0x03c42000, ZIP_URGFIELD(27),ZIP_OPUNUSED, ZIP_URGFIELD(14), ZIP_IMMFIELD(13,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "CMP", 0x87c40000, 0x04000000, ZIP_OPUNUSED, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "CMP", 0x87c40000, 0x04040000, ZIP_OPUNUSED, ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	{ "TST", 0x87c40000, 0x04400000, ZIP_OPUNUSED, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "TST", 0x87c40000, 0x04440000, ZIP_OPUNUSED, ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	// 0rrr.r101.1
+	{ "LDI",  0x87800000, 0x05800000, ZIP_REGFIELD(27),ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(23,0), ZIP_OPUNUSED },
+	//
+	// 0.111x.00000.xxx.xxx.xxxx.xxxx.xxxx.xxxx
+	// 0111.x000.00.xxx.xxx.xxxx.xxxx.xxxx.xxxx
+	{ "NOOP",  0xf7ffffff, 0x76000000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "BRK",   0xf7ffffff, 0x76400000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "LOCK",  0xf7ffffff, 0x76800000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	//
+	// LOD: 0rrr.r100.10cc.cxrr.rrii.iiii.iiii.iiii
+	{ "LOD", 0x87c40000, 0x04800000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "LOD", 0x87c40000, 0x04840000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	{ "STO", 0x87c40000, 0x04c00000, ZIP_OPUNUSED, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "STO", 0x87c40000, 0x04c40000, ZIP_OPUNUSED, ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	// 0rrr.r101.1dcc.cxrr.rrii.iiii.iiii.iiii
+	{ "DIVU", 0x87c40000, 0x05000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "DIVU", 0x87c40000, 0x05040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	{ "DIVS", 0x87c40000, 0x05400000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "DIVS", 0x87c40000, 0x05440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	// 0rrr.r11f.ffcc.cxrr.rrii.iiii.iiii.iiii
+	{ "FPADD",0x87c43fff, 0x06040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "FPSUB",0x87c43fff, 0x06440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "FPMPY",0x87c43fff, 0x06840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "FPDIV",0x87c43fff, 0x06c40000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(3,19) },
+	{ "FPCVT",0x87c40000, 0x07000000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(18,0), ZIP_BITFIELD(3,19) },
+	{ "FPCVT",0x87c40000, 0x07040000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	{ "FPINT",0x87c40000, 0x07440000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_IMMFIELD(14,0), ZIP_BITFIELD(3,19) },
+	//
+	//
+	//
+	//
+	//
+	//	16-bit instructions, high side
+	//
+	// 
+	//	1.1111.00010.xcc.0iiii.xxxx.xxxxx.xxxxx
+	//	1111.1000.10xc.c0ii.iixx.xxxx.xxxx.xxxx
+	{ "BRA",  0xffd40000, 0xf8800000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_OPUNUSED },
+	{ "BLT",  0xffd40000, 0xf8840000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_OPUNUSED },
+	{ "BZ",  0xffd40000, 0xf8900000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_OPUNUSED },
+	{ "BNZ",  0xffd40000, 0xf8940000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_OPUNUSED },
+	// LDI	1.rrrr.1011x.ccc.iiiii	-> 1rrr r101 1xcc ciii ii
+	{ "CLR", 0x8787c000, 0x85800000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	// JMP	1.1111.01111.ccc.1rrrr	-> 1111 1011 11cc c1rr rr (Mov to PC)
+	{ "JMP",  0xffc40000, 0xfbc40000, ZIP_REGFIELD(27),ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	// XOR	1.rrrr.00100.ccc.01111	-> 1rrr r001 00cc c011 11
+	{ "NOT", 0x87c7c000, 0x8103c000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	// General instructions, top half
+	// 1rrr.rooo.oocc.cxrr.rr
+	{ "SUB", 0x87c40000, 0x80000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "SUB", 0x87c40000, 0x80040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "AND", 0x87c40000, 0x80400000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "AND", 0x87c40000, 0x80440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "ADD", 0x87c40000, 0x80800000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "ADD", 0x87c40000, 0x80840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "OR",	0x87c40000, 0x80c00000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "OR",	0x87c40000, 0x80c40000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "XOR", 0x87c40000, 0x81000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "XOR", 0x87c40000, 0x81040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "LSR", 0x87c40000, 0x81400000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "LSR", 0x87c40000, 0x81440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "LSL", 0x87c40000, 0x81800000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "LSL", 0x87c40000, 0x81840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "ASR", 0x87c40000, 0x81c00000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "ASR", 0x87c40000, 0x81c40000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+#ifdef	LONG_MPY
+	{ "MPY",0x87c40000, 0x82000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(5,14), ZIP_BITFIELD(2,19) },
+#else
+	{ "LDIHI",0x87c40000, 0x82000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(5,14), ZIP_BITFIELD(2,19) },
+#endif
+	{ "LDILO",0x87c40000, 0x82400000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(5,14), ZIP_BITFIELD(2,19) },
+#ifdef	LONG_MPY
+	//
+	{ "MPYUHI", 0x87c40000, 0x82800000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "MPYUHI", 0x87c40000, 0x82840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "MPYSHI", 0x87c40000, 0x82c00000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "MPYSHI", 0x87c40000, 0x82c40000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+#else
+	//
+	{ "MPYU", 0x87c40000, 0x82800000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "MPYU", 0x87c40000, 0x82840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "MPYS", 0x87c40000, 0x82c00000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "MPYS", 0x87c40000, 0x82c40000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+#endif
+	//
+	{ "BREV", 0x87c40000, 0x83000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "BREV", 0x87c40000, 0x83040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "POPC", 0x87c40000, 0x83400000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "POPC", 0x87c40000, 0x83440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "ROL", 0x87c40000, 0x83800000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "ROL", 0x87c40000, 0x83840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "MOV", 0x87c40000, 0x83c40000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "CMP", 0x87c40000, 0x84000000, ZIP_OPUNUSED, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "CMP", 0x87c40000, 0x84040000, ZIP_OPUNUSED, ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "TST", 0x87c40000, 0x84400000, ZIP_OPUNUSED, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "TST", 0x87c40000, 0x84440000, ZIP_OPUNUSED, ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "LOD", 0x87c40000, 0x84840000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "STO", 0x87c40000, 0x84c40000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "DIVU", 0x87c40000, 0x85000000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "DIVU", 0x87c40000, 0x85040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "DIVS", 0x87c40000, 0x85400000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "DIVS", 0x87c40000, 0x85440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "CLR", 0x8787c000, 0x85800000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "LDI", 0x87c00000, 0x85800000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(5,14), ZIP_BITFIELD(2,19) },
+	//
+	{ "NOOP", 0xf7c00000, 0xf6000000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "BRK", 0xf7c00000, 0xf6400000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	//
+	{ "LOCK", 0xf7c00000, 0xf6800000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	//
+	//
+	{ "FPADD",0x87c40000, 0x86040000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "FPSUB",0x87c40000, 0x86440000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "FPMUL",0x87c40000, 0x86840000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "FPDIV",0x87c40000, 0x86c40000, ZIP_REGFIELD(27), ZIP_REGFIELD(27), ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "FPCVT",0x87c40000, 0x87000000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,14), ZIP_BITFIELD(2,19) },
+	{ "FPCVT",0x87c40000, 0x87040000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "FPINT",0x87c40000, 0x87440000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_REGFIELD(14), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	//
+	// Illegal instruction !!
+	{ "ILL", 0x00000000, 0x00000000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(32,0), ZIP_OPUNUSED }
+};
+
+static const ZOPCODE	zip_opbottomlist_raw[] = {
+	//
+	//
+	//
+	//	16-bit instructions, low side ... treat these as special
+	//
+	//
+	// Special case instructions.  These are general instructions, but with
+	// special opcodes
+	// Conditional branches
+	//	1.xxxx.xxxxx.1cc.xxxxx.1111.00010.0iiii
+	//	1xxx.xxxx.xx1c.cxxx.xx11.1100.0100.iiii
+	{ "BRA",  0x80203ff0, 0x80003c40, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "BLT",  0x80383ff0, 0x80283c40, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "BZ",  0x80383ff0, 0x80303c40, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "BNZ",  0x80383ff0, 0x80383c40, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	//
+	{ "LJMP", 0x80203fff, 0x80003e5f, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	// CLRF ... an XOR w/ self instruction
+	//	0.rrrr.00100.ccc.1.rrrr.iiiii---
+	//	0rrr r001 00cc c1rr rr00 0000 0000 0000
+	// "CLRF",	0xffc7cfff, 0x7907c000, ZIP_REGFIELD(27), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(3,19),
+	// CLR -- a LDI of zero
+	// LDI	1xxx.xxxx.xxxx.xxxx.xxrr.rroo.ooo.iiiii	-> 1rrr r100 1xcc ciii ii
+	// JMP	1xxx -- xx11.1101.1111.rrrr (Mov to PC)
+	{ "JMP",  0x80203ff0, 0x80003df0, ZIP_REGFIELD(10),ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	// Conditional jump, still move to PC at issue
+	{ "JMP",  0x80203ff0, 0x80203df0, ZIP_REGFIELD(10),ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	// XOR	1xxx -- xx00.1000.1111	-> 1rrr r001 00cc c011 11
+	{ "NOT", 0x802003ff, 0x8000008f, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "NOT", 0x802003ff, 0x8020008f, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	// General instructions, bottom half
+	// 1xxx -- xxrr.rroo.ooox.rrrr
+	{ "SUB", 0x800003f0, 0x80000000, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "SUB", 0x802003f0, 0x80200000, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "SUB", 0x800003f0, 0x80000010, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "SUB", 0x802003f0, 0x80200010, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "AND", 0x800003f0, 0x80000020, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "AND", 0x802003f0, 0x80200020, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "AND", 0x800003f0, 0x80000030, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "AND", 0x802003f0, 0x80200030, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "ADD", 0x800003f0, 0x80000040, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "ADD", 0x802003f0, 0x80200040, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "ADD", 0x800003f0, 0x80000050, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "ADD", 0x802003f0, 0x80200050, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "OR",	0x800003f0, 0x80000060, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "OR",	0x802003f0, 0x80200060, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "OR",	0x800003f0, 0x80000070, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "OR",	0x802003f0, 0x80200070, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "XOR", 0x800003f0, 0x80000080, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "XOR", 0x802003f0, 0x80200080, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "XOR", 0x800003f0, 0x80000090, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "XOR", 0x802003f0, 0x80200090, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "LSR", 0x800003f0, 0x800000a0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "LSR", 0x802003f0, 0x802000a0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "LSR", 0x800003f0, 0x800000b0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "LSR", 0x802003f0, 0x802000b0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "LSL", 0x800003f0, 0x800000c0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "LSL", 0x802003f0, 0x802000c0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "LSL", 0x800003f0, 0x800000d0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "LSL", 0x802003f0, 0x802000d0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "ASR", 0x800003f0, 0x800000e0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "ASR", 0x802003f0, 0x802000e0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "ASR", 0x800003f0, 0x800000f0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "ASR", 0x802003f0, 0x802000f0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+#ifdef	LONG_MPY
+	//
+	{ "MPY",0x800003e0, 0x80000100, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(5,0), ZIP_BITFIELD(2,19) },
+	{ "MPY",0x802003e0, 0x80200100, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(5,0), ZIP_OPUNUSED },
+#else
+	//
+	{ "LDIHI",0x800003e0, 0x80000100, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(5,0), ZIP_BITFIELD(2,19) },
+	{ "LDIHI",0x802003e0, 0x80200100, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(5,0), ZIP_OPUNUSED },
+#endif
+	//
+	{ "LDILO",0x800003e0, 0x80000120, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(5,0), ZIP_BITFIELD(2,19) },
+	{ "LDILO",0x802003e0, 0x80200120, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(5,0), ZIP_OPUNUSED },
+	//
+#ifdef	LONG_MPY
+	//
+	{ "MPYUHI", 0x800003f0, 0x80000140, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "MPYUHI", 0x802003f0, 0x80200140, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "MPYUHI", 0x800003f0, 0x80000150, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "MPYUHI", 0x802003f0, 0x80200150, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "MPYSHI", 0x800003f0, 0x80000160, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "MPYSHI", 0x802003f0, 0x80200160, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "MPYSHI", 0x800003f0, 0x80000170, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "MPYSHI", 0x802003f0, 0x80200170, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+#else
+	//
+	{ "MPYU", 0x800003f0, 0x80000140, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "MPYU", 0x802003f0, 0x80200140, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "MPYU", 0x800003f0, 0x80000150, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "MPYU", 0x802003f0, 0x80200150, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "MPYS", 0x800003f0, 0x80000160, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "MPYS", 0x802003f0, 0x80200160, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "MPYS", 0x800003f0, 0x80000170, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "MPYS", 0x802003f0, 0x80200170, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+#endif
+	//
+	{ "BREV", 0x800003f0, 0x80000180, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "BREV", 0x802003f0, 0x80200180, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "BREV", 0x800003f0, 0x80000190, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "BREV", 0x802003f0, 0x80200190, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "POPC", 0x800003f0, 0x800001a0, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "POPC", 0x802003f0, 0x802001a0, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "POPC", 0x800003f0, 0x800001b0, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "POPC", 0x802003f0, 0x802001b0, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "ROL", 0x800003f0, 0x800001c0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "ROL", 0x802003f0, 0x802001c0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "ROL", 0x800003f0, 0x800001d0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "ROL", 0x802003f0, 0x802001d0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "MOV", 0x800003f0, 0x800001f0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "MOV", 0x802003f0, 0x802001f0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "CMP", 0x800003f0, 0x80000200, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "CMP", 0x802003f0, 0x80200200, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "CMP", 0x800003f0, 0x80000210, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "CMP", 0x802003f0, 0x80200210, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "TST", 0x800003f0, 0x80000220, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "TST", 0x802003f0, 0x80200220, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "TST", 0x800003f0, 0x80000230, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "TST", 0x802003f0, 0x80200230, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "LOD", 0x800003f0, 0x80000250, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "LOD", 0x802003f0, 0x80200250, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "STO", 0x800003f0, 0x80000270, ZIP_OPUNUSED, ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "STO", 0x802003f0, 0x80200270, ZIP_OPUNUSED, ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "DIVU", 0x800003f0, 0x80000280, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "DIVU", 0x802003f0, 0x80200280, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "DIVU", 0x800003f0, 0x80000290, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "DIVU", 0x802003f0, 0x80200290, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "DIVS", 0x800003f0, 0x800002a0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "DIVS", 0x802003f0, 0x802002a0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "DIVS", 0x800003f0, 0x800002b0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "DIVS", 0x802003f0, 0x802002b0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "CLR", 0x802003df, 0x800002c0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "CLR", 0x802003df, 0x802002c0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	{ "LDI", 0x802003c0, 0x800002c0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(5,0), ZIP_OPUNUSED },
+	{ "LDI", 0x802003c0, 0x802002c0, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(5,0), ZIP_BITFIELD(2,19) },
+	//
+	{ "NOOP", 0x80003bf0, 0x80003b00, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED },
+	//
+	{ "BRK", 0x80003bf0, 0x80003b20, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	//
+	{ "LOCK", 0x80003bf0, 0x80003b40, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	//
+	// FPU instructions
+	//
+	{ "FPADD",0x802003f0, 0x80000310, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "FPADD",0x802003f0, 0x80200310, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "FPSUB",0x802003f0, 0x80000330, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "FPSUB",0x802003f0, 0x80200330, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "FPMUL",0x802003f0, 0x80000350, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "FPMUL",0x802003f0, 0x80200350, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	{ "FPDIV",0x802003f0, 0x80000370, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "FPDIV",0x802003f0, 0x80200370, ZIP_REGFIELD(10), ZIP_REGFIELD(10), ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	// Convert to floating point
+	{ "FPCVT",0x802003f0, 0x80000380, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_OPUNUSED },
+	{ "FPCVT",0x802003f0, 0x80200380, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(4,0), ZIP_BITFIELD(2,19) },
+	{ "FPCVT",0x802003f0, 0x80000390, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "FPCVT",0x802003f0, 0x80200390, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	// Convert to integer
+	{ "FPINT",0x802003f0, 0x800003b0, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_OPUNUSED },
+	{ "FPINT",0x802003f0, 0x802003b0, ZIP_REGFIELD(10), ZIP_OPUNUSED, ZIP_REGFIELD(0), ZIP_OPUNUSED, ZIP_BITFIELD(2,19) },
+	//
+	//
+	// Illegal instruction !!
+	{ "ILL",	0x00000000, 0x00000000, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_OPUNUSED, ZIP_IMMFIELD(32,0), ZIP_OPUNUSED }
+};
+
+const ZOPCODE	*zip_oplist = zip_oplist_raw,
+		*zip_opbottomlist = zip_opbottomlist_raw;
+
+const int	nzip_oplist = (sizeof(zip_oplist_raw)/sizeof(ZOPCODE));
+const int	nzip_opbottom = (sizeof(zip_opbottomlist_raw)/sizeof(ZOPCODE));
+
diff -Naur '--exclude=*.swp' binutils-2.25-original/opcodes/zip-opc.h binutils-2.25/opcodes/zip-opc.h
--- binutils-2.25-original/opcodes/zip-opc.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.25/opcodes/zip-opc.h	2016-04-19 09:58:59.566634476 -0400
@@ -0,0 +1,82 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Filename: 	zip-opc.h
+//
+// Project:	Zip CPU backend for GNU Binutils
+//
+// Purpose:	
+//
+// Creator:	Dan Gisselquist, Ph.D.
+//		Gisselquist Technology, LLC
+//
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (C) 2016, Gisselquist Technology, LLC
+//
+// This program is free software (firmware): you can redistribute it and/or
+// modify it under the terms of  the GNU General Public License as published
+// by the Free Software Foundation, either version 3 of the License, or (at
+// your option) any later version.
+//
+// This program is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this program.  (It's in the $(ROOT)/doc directory, run make with no
+// target there if the PDF file isn't present.)  If not, see
+// <http://www.gnu.org/licenses/> for a copy.
+//
+// License:	GPL, v3, as defined and found on www.gnu.org,
+//		http://www.gnu.org/licenses/gpl.html
+//
+//
+////////////////////////////////////////////////////////////////////////////////
+#ifndef	ZIP_OPC_H
+#define	ZIP_OPC_H
+
+#include <stdint.h>
+
+// MACROS used in the instruction definition list.
+#define	ZIP_OPUNUSED	-1
+#define	ZIP_BITFIELD(LN,MN) (((LN&0x0ff)<<8)+(MN&0x0ff)) // A generic bitfield
+#define	ZIP_REGFIELD(MN) (0x00000400 +(MN&0x0ff)) // Normal register field
+#define	ZIP_URGFIELD(MN) (0x0100400 +(MN&0x0ff))	// User register field
+#define	ZIP_IMMFIELD(LN,MN) (0x40000000 + (((LN&0x0ff)<<8)+(MN&0x0ff))) // Sgn extnd
+//
+// Some older definitions that are no longer used.
+// #define	ISUSEROP(A)	((a&(~0x0f))==0x000)	// User register
+// #define	ISSUPROP(A)	((a&(~0x0f))==0x010)	// Supervior register
+// #define	ISLCLROP(A)	((a&(~0x0f))==0x020)	// Current register set
+// #define	SRGFIELD(MN)	(0x0200400 +(MN&0x0ff))	// Supervisor reg fld
+
+typedef	uint32_t	ZIPI;	// A Zip CPU instruction
+
+typedef	struct {
+	char	s_opstr[8];	// OPCode name
+	ZIPI	s_mask,		// Bits that must match 4 this pattern to match
+		s_val;		// What those masked bits must be
+	//
+	// The following describe not the value, but the bits where there
+	// respective vaules will be found within the instruction.  For example,
+	// an instruction with no immediate will have an s_i value of -1
+	// (ZIP_OPUNUSED), whereas an instruction with an immediate value of -1
+	// might have an s_i value of ZIP_BITFIELD(14,0), or 0x0400.  The
+	// opcode itself will tell you what the value is--not this structure
+	// describing the opcode.
+	//
+	int	s_result,	// Register where the result will be placed
+		s_ra,		// A register, often the result
+		s_rb,		// B register, source operand (if used)
+		s_i,		// Immediate value, added to B if B is used
+		s_cf;		// Condition flags.
+} ZOPCODE;
+
+extern	const	char	*zip_regstr[49], *zip_ccstr[8];
+
+extern	const ZOPCODE	*zip_oplist, *zip_opbottomlist;
+extern	const int	nzip_oplist, nzip_opbottom;
+
+
+#endif
